/**
 * Generated by orval v7.19.0 üç∫
 * Do not edit manually.
 * django-allauth: Headless API
 * $ref: "./description.md"

 * OpenAPI spec version: 1
 */
import { useMutation, useQuery } from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query';

import { customInstance } from './mutator/custom-instance';
import type { BodyType, ErrorType } from './mutator/custom-instance';

export interface Session {
  user_agent: string;
  ip: string;
  created_at: Timestamp;
  is_current: boolean;
  id: number;
  last_seen_at?: Timestamp;
}

export type AccountConfigurationLoginMethodsItem =
  (typeof AccountConfigurationLoginMethodsItem)[keyof typeof AccountConfigurationLoginMethodsItem];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AccountConfigurationLoginMethodsItem = {
  email: 'email',
  username: 'username',
} as const;

/**
 * Configuration of the Django `allauth.account` app.

 */
export interface AccountConfiguration {
  login_methods?: AccountConfigurationLoginMethodsItem[];
  is_open_for_signup: boolean;
  email_verification_by_code_enabled: boolean;
  login_by_code_enabled: boolean;
  password_reset_by_code_enabled?: boolean;
}

export type AuthenticationResponseStatus =
  (typeof AuthenticationResponseStatus)[keyof typeof AuthenticationResponseStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AuthenticationResponseStatus = {
  number401: 401,
} as const;

export type AuthenticationResponseData = {
  flows: Flow[];
};

/**
 * An authentication related response.

 */
export interface AuthenticationResponse {
  status: AuthenticationResponseStatus;
  data: AuthenticationResponseData;
  meta: AuthenticationMeta;
}

export type ForbiddenResponseStatus =
  (typeof ForbiddenResponseStatus)[keyof typeof ForbiddenResponseStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ForbiddenResponseStatus = {
  number403: 403,
} as const;

export interface ForbiddenResponse {
  status: ForbiddenResponseStatus;
}

export type ConflictResponseStatus =
  (typeof ConflictResponseStatus)[keyof typeof ConflictResponseStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ConflictResponseStatus = {
  number409: 409,
} as const;

export interface ConflictResponse {
  status: ConflictResponseStatus;
}

export interface EndSessions {
  /** The IDs of the sessions that are to be ended.
   */
  sessions: number[];
}

/**
 * A phone number.

 */
export interface PhoneNumber {
  phone: string;
  verified: boolean;
}

export interface PhoneNumbersResponse {
  status: StatusOK;
  data: PhoneNumber[];
}

export interface PhoneNumberChangeResponse {
  status: StatusAccepted;
  data: PhoneNumber[];
}

export type ReauthenticationResponseStatus =
  (typeof ReauthenticationResponseStatus)[keyof typeof ReauthenticationResponseStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ReauthenticationResponseStatus = {
  number401: 401,
} as const;

/**
 * A response indicating reauthentication is required.

 */
export interface ReauthenticationResponse {
  status: ReauthenticationResponseStatus;
  data: ReauthenticationRequired;
  meta: AuthenticatedMeta;
}

export type SessionGoneResponseStatus =
  (typeof SessionGoneResponseStatus)[keyof typeof SessionGoneResponseStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SessionGoneResponseStatus = {
  number410: 410,
} as const;

export type SessionGoneResponseData = { [key: string]: unknown };

/**
 * The session is expired or invalid.

 */
export interface SessionGoneResponse {
  status: SessionGoneResponseStatus;
  data: SessionGoneResponseData;
  meta: AuthenticationMeta;
}

export interface BaseAuthenticationMeta {
  /** The session token (`app` clients only).
   */
  session_token?: string;
  /** The access token (`app` clients only).
   */
  access_token?: string;
}

/**
 * Metadata available in an authentication related response.

 */
export type AuthenticationMetaAllOf = {
  is_authenticated: boolean;
};

export type AuthenticationMeta = BaseAuthenticationMeta & AuthenticationMetaAllOf;

/**
 * Metadata available in an re-authentication related response.

 */
export type AuthenticatedMetaAllOf = {
  is_authenticated: boolean;
};

export type AuthenticatedMeta = BaseAuthenticationMeta & AuthenticatedMetaAllOf;

export type FlowId = (typeof FlowId)[keyof typeof FlowId];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const FlowId = {
  login: 'login',
  loginByCode: 'login_by_code',
  mfaAuthenticate: 'mfa_authenticate',
  mfaReauthenticate: 'mfa_reauthenticate',
  providerRedirect: 'provider_redirect',
  providerSignup: 'provider_signup',
  providerToken: 'provider_token',
  reauthenticate: 'reauthenticate',
  signup: 'signup',
  verifyEmail: 'verify_email',
  verifyPhone: 'verify_phone',
} as const;

export interface Flow {
  id: FlowId;
  provider?: Provider;
  is_pending?: boolean;
  /** Matches `settings.MFA_SUPPORTED_TYPES`. */
  types?: AuthenticatorType[];
}

export interface Authenticated {
  user: User;
  /** A list of methods used to authenticate.
   */
  methods: AuthenticationMethod[];
}

export interface ReauthenticationRequired {
  flows: Flow[];
  user: User;
  /** A list of methods used to authenticate.
   */
  methods: AuthenticationMethod[];
}

export type AuthenticationMethodOneOfMethod =
  (typeof AuthenticationMethodOneOfMethod)[keyof typeof AuthenticationMethodOneOfMethod];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AuthenticationMethodOneOfMethod = {
  password: 'password',
} as const;

export type AuthenticationMethodOneOf = {
  method: AuthenticationMethodOneOfMethod;
  at: Timestamp;
  email?: Email;
  username?: Username;
};

export type AuthenticationMethodOneOfThreeMethod =
  (typeof AuthenticationMethodOneOfThreeMethod)[keyof typeof AuthenticationMethodOneOfThreeMethod];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AuthenticationMethodOneOfThreeMethod = {
  passwordReset: 'password_reset',
} as const;

export type AuthenticationMethodOneOfThree = {
  method: AuthenticationMethodOneOfThreeMethod;
  at: Timestamp;
  email: Email;
};

export type AuthenticationMethodOneOfFiveMethod =
  (typeof AuthenticationMethodOneOfFiveMethod)[keyof typeof AuthenticationMethodOneOfFiveMethod];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AuthenticationMethodOneOfFiveMethod = {
  code: 'code',
} as const;

export type AuthenticationMethodOneOfFive = {
  method: AuthenticationMethodOneOfFiveMethod;
  at: Timestamp;
  email: Email;
};

export type AuthenticationMethodOneOfSevenMethod =
  (typeof AuthenticationMethodOneOfSevenMethod)[keyof typeof AuthenticationMethodOneOfSevenMethod];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AuthenticationMethodOneOfSevenMethod = {
  code: 'code',
} as const;

export type AuthenticationMethodOneOfSeven = {
  method: AuthenticationMethodOneOfSevenMethod;
  at: Timestamp;
  phone: Phone;
};

export type AuthenticationMethodOneOfNineMethod =
  (typeof AuthenticationMethodOneOfNineMethod)[keyof typeof AuthenticationMethodOneOfNineMethod];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AuthenticationMethodOneOfNineMethod = {
  password: 'password',
} as const;

export type AuthenticationMethodOneOfNine = {
  method: AuthenticationMethodOneOfNineMethod;
  at: Timestamp;
  reauthenticated: boolean;
};

export type AuthenticationMethodOneOfOneoneMethod =
  (typeof AuthenticationMethodOneOfOneoneMethod)[keyof typeof AuthenticationMethodOneOfOneoneMethod];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AuthenticationMethodOneOfOneoneMethod = {
  socialaccount: 'socialaccount',
} as const;

export type AuthenticationMethodOneOfOneone = {
  method: AuthenticationMethodOneOfOneoneMethod;
  at: Timestamp;
  provider: ProviderID;
  uid: ProviderAccountID;
};

export type AuthenticationMethodOneOfOnethreeMethod =
  (typeof AuthenticationMethodOneOfOnethreeMethod)[keyof typeof AuthenticationMethodOneOfOnethreeMethod];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AuthenticationMethodOneOfOnethreeMethod = {
  mfa: 'mfa',
} as const;

export type AuthenticationMethodOneOfOnethree = {
  method: AuthenticationMethodOneOfOnethreeMethod;
  at: Timestamp;
  type: AuthenticatorType;
  reauthenticated?: boolean;
};

export type AuthenticationMethod =
  | AuthenticationMethodOneOf
  | AuthenticationMethodOneOfThree
  | AuthenticationMethodOneOfFive
  | AuthenticationMethodOneOfSeven
  | AuthenticationMethodOneOfNine
  | AuthenticationMethodOneOfOneone
  | AuthenticationMethodOneOfOnethree;

export interface AuthenticatedResponse {
  status: StatusOK;
  data: Authenticated;
  meta: AuthenticationMeta;
}

export interface MFAAuthenticate {
  code: AuthenticatorCode;
}

export interface MFATrust {
  trust: boolean;
}

export interface ConfirmLoginCode {
  code: Code;
}

/**
 * The client ID (in case of OAuth2 or OpenID Connect based providers)

 */
export type ClientID = string;

/**
 * The token.

 */
export type ProviderTokenToken = {
  client_id: ClientID;
  /** The ID token.
   */
  id_token?: string;
  /** The access token.
   */
  access_token?: string;
};

export interface ProviderToken {
  provider: ProviderID;
  process: Process;
  /** The token.
   */
  token: ProviderTokenToken;
}

export interface ProviderRedirect {
  provider: ProviderID;
  /** The URL to return to after the redirect flow is complete.

Note that this is not to be mistaken with the callback URL that you
configure over at the OAuth provider during the OAuth app/client
setup. The flow is as follows:

  1. Your frontend redirects to the headless provider redirect
     endpoint in a synchronous (non-XHR) manner, informing allauth
     (by means of `callback_url`) where to redirect to after the
     provider handshake is completed.

  2. Headless will redirect to the (OAuth) identity provider to
     initiate the handshake, passing along a different callback URL
     to the provider: one that points to an allauth backend URL.
     This is the URL that you need to have setup at your OAuth
     app/client configuration. Note that this must be a backend URL
     as providers can use POST requests to perform their callbacks,
     which is something a frontend would not be able to handle.

  3. After the authorization at the provider is completed, the
     provider redirects to the *backend* allauth callback URL, which
     will then redirect back to the *frontend* callback URL.

  4. Your frontend is now expected to fetch the current session to
     determine what the next course of action is. The user could be
     authenticated at this point, or another flow is pending
     (e.g. email verification, or, provider signup). In case of
     errors a `?error=` is passed to the frontend callback URL.
 */
  callback_url: string;
  process: Process;
}

export interface RequestPassword {
  email: Email;
}

export type RequestLoginCodeAnyOf = {
  phone: Phone;
};

export type RequestLoginCodeAnyOfTwo = {
  email: Email;
};

export type RequestLoginCode = RequestLoginCodeAnyOf | RequestLoginCodeAnyOfTwo;

export interface Reauthenticate {
  password: Password;
}

export type ProviderSignup = BaseSignup;

export type PasskeySignup = BaseSignup;

export interface BaseSignup {
  email?: Email;
  phone?: Phone;
  username?: Username;
}

export type SignupAllOf = {
  password: Password;
};

export type Signup = BaseSignup & SignupAllOf;

/**
 * The username.

 */
export type Username = string;

/**
 * The email address.

 */
export type Email = string;

/**
 * The phone number.

 */
export type Phone = string;

/**
 * The access token.

 */
export type AccessToken = string;

/**
 * The refresh token.

 */
export type RefreshToken = string;

export type LoginAllOf = {
  password: Password;
};

export type LoginAllOfTwoAnyOf = {
  username: Username;
};

export type LoginAllOfTwoAnyOfTwo = {
  email: Email;
};

export type LoginAllOfTwoAnyOfThree = {
  phone: Phone;
};

export type LoginAllOfTwo = LoginAllOfTwoAnyOf | LoginAllOfTwoAnyOfTwo | LoginAllOfTwoAnyOfThree;

export type Login = LoginAllOf & LoginAllOfTwo;

export type StatusOK = (typeof StatusOK)[keyof typeof StatusOK];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const StatusOK = {
  number200: 200,
} as const;

export type StatusAccepted = (typeof StatusAccepted)[keyof typeof StatusAccepted];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const StatusAccepted = {
  number202: 202,
} as const;

/**
 * Authenticator ID.

 */
export type AuthenticatorID = number;

/**
 * Configuration of the Django `allauth.socialaccount` app.

 */
export interface SocialAccountConfiguration {
  providers: ProviderList;
}

/**
 * Configuration of the Django `allauth.mfa` app.

 */
export interface MFAConfiguration {
  /** Matches `settings.MFA_SUPPORTED_TYPES`.
   */
  supported_types: AuthenticatorType[];
}

/**
 * Configuration of the Django `allauth.usersessions` app.

 */
export interface UserSessionsConfiguration {
  /** Matches `settings.USERSESSIONS_TRACK_ACTIVITY`.
   */
  track_activity: boolean;
}

export type ConfigurationResponseData = {
  account: AccountConfiguration;
  socialaccount?: SocialAccountConfiguration;
  mfa?: MFAConfiguration;
  usersessions?: UserSessionsConfiguration;
};

export interface ConfigurationResponse {
  data: ConfigurationResponseData;
  status: StatusOK;
}

export interface ResetPassword {
  /** The password reset key */
  key: string;
  password: Password;
}

export interface VerifyEmail {
  /** The email verification key */
  key: string;
}

export interface VerifyPhone {
  /** The phone verification code */
  code: string;
}

/**
 * @nullable
 */
export type OptionalTimestamp = Timestamp;

/**
 * An epoch based timestamp (trivial to parse using: `new Date(value)*1000`)

 */
export type Timestamp = number;

/**
 * An authenticator code.

 */
export type AuthenticatorCode = string;

/**
 * An one-time code.

 */
export type Code = string;

/**
 * The type of authenticator.

 */
export type AuthenticatorType = (typeof AuthenticatorType)[keyof typeof AuthenticatorType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AuthenticatorType = {
  recoveryCodes: 'recovery_codes',
  totp: 'totp',
  webauthn: 'webauthn',
} as const;

/**
 * The password.

 */
export type Password = string;

export type ErrorResponseStatus = (typeof ErrorResponseStatus)[keyof typeof ErrorResponseStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ErrorResponseStatus = {
  number400: 400,
} as const;

export type ErrorResponseErrorsItem = {
  /** An error code.
   */
  code: string;
  /** The name of the input parameter that was incorrect.
   */
  param?: string;
  /** A human readable error message.
   */
  message: string;
};

export interface ErrorResponse {
  status?: ErrorResponseStatus;
  errors?: ErrorResponseErrorsItem[];
}

/**
 * The process to be executed when the user successfully
authenticates. When set to `login`, the user will be logged into the
account to which the provider account is connected, or if no such
account exists, a signup will occur. If set to `connect`, the provider
account will be connected to the list of provider accounts for the
currently authenticated user.

 */
export type Process = (typeof Process)[keyof typeof Process];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const Process = {
  login: 'login',
  connect: 'connect',
} as const;

/**
 * The provider ID.

 */
export type ProviderID = string;

/**
 * The provider specific account ID.

 */
export type ProviderAccountID = string;

/**
 * The user ID.

 */
export type UserId = number | string;

export interface User {
  /** The user ID.
   */
  id?: UserId;
  /** The display name for the user.
   */
  display?: string;
  /** Whether or not the account has a password set.
   */
  has_usable_password?: boolean;
  email?: Email;
  username?: Username;
}

export interface EmailAddress {
  email: Email;
  primary: boolean;
  verified: boolean;
}

export interface BaseAuthenticator {
  last_used_at: Timestamp;
  created_at: Timestamp;
}

export type TOTPAuthenticatorAllOfType =
  (typeof TOTPAuthenticatorAllOfType)[keyof typeof TOTPAuthenticatorAllOfType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TOTPAuthenticatorAllOfType = {
  totp: 'totp',
} as const;

export type TOTPAuthenticatorAllOf = {
  type: TOTPAuthenticatorAllOfType;
};

export type TOTPAuthenticator = BaseAuthenticator & TOTPAuthenticatorAllOf;

export type WebAuthnAuthenticatorAllOfType =
  (typeof WebAuthnAuthenticatorAllOfType)[keyof typeof WebAuthnAuthenticatorAllOfType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const WebAuthnAuthenticatorAllOfType = {
  webauthn: 'webauthn',
} as const;

export type WebAuthnAuthenticatorAllOf = {
  type: WebAuthnAuthenticatorAllOfType;
  id: AuthenticatorID;
  name: string;
  /** Whether or not this authenticator represents a passkey. Absent if it is not specified.
   */
  is_passwordless?: boolean;
};

export type WebAuthnAuthenticator = BaseAuthenticator & WebAuthnAuthenticatorAllOf;

/**
 * The authenticator type.

 */
export type RecoveryCodesAuthenticatorAllOfType =
  (typeof RecoveryCodesAuthenticatorAllOfType)[keyof typeof RecoveryCodesAuthenticatorAllOfType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const RecoveryCodesAuthenticatorAllOfType = {
  recoveryCodes: 'recovery_codes',
} as const;

export type RecoveryCodesAuthenticatorAllOf = {
  /** The authenticator type.
   */
  type: RecoveryCodesAuthenticatorAllOfType;
  /** The total number of recovery codes that initially were available.
   */
  total_code_count: number;
  /** The number of recovery codes that are unused.
   */
  unused_code_count: number;
};

export type RecoveryCodesAuthenticator = BaseAuthenticator & RecoveryCodesAuthenticatorAllOf;

export type SensitiveRecoveryCodesAuthenticatorAllOf = {
  /** The list of unused codes.
   */
  unused_codes: AuthenticatorCode[];
};

export type SensitiveRecoveryCodesAuthenticator = RecoveryCodesAuthenticator &
  SensitiveRecoveryCodesAuthenticatorAllOf;

export type AuthenticatorListItem =
  | TOTPAuthenticator
  | RecoveryCodesAuthenticator
  | WebAuthnAuthenticator;

export type AuthenticatorList = AuthenticatorListItem[];

export type ProviderList = Provider[];

export type ProviderFlowsItem = (typeof ProviderFlowsItem)[keyof typeof ProviderFlowsItem];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ProviderFlowsItem = {
  providerRedirect: 'provider_redirect',
  providerToken: 'provider_token',
} as const;

export interface Provider {
  /** The provider ID.
   */
  id: string;
  /** The name of the provider.
   */
  name: string;
  /** The client ID (in case of OAuth2 or OpenID Connect based providers)
   */
  client_id?: string;
  /** The OIDC discovery or well-known URL (in case of OAuth2 or OpenID Connect based providers)
   */
  openid_configuration_url?: string;
  /** The authentication flows the provider integration supports.
   */
  flows: ProviderFlowsItem[];
}

export interface ProviderAccount {
  uid: ProviderAccountID;
  /** A name derived from the third-party provider account data.
   */
  display: string;
  provider: Provider;
}

export type EmailVerificationInfoData = {
  email: Email;
  user: User;
};

export type EmailVerificationInfoMeta = {
  is_authenticating: boolean;
};

export interface EmailVerificationInfo {
  status: StatusOK;
  data: EmailVerificationInfoData;
  meta: EmailVerificationInfoMeta;
}

export type WebAuthnCredentialRequestOptionsRequestOptions = { [key: string]: unknown };

export interface WebAuthnCredentialRequestOptions {
  request_options: WebAuthnCredentialRequestOptionsRequestOptions;
}

export type WebAuthnCredentialCreationOptionsCreationOptions = { [key: string]: unknown };

export interface WebAuthnCredentialCreationOptions {
  creation_options: WebAuthnCredentialCreationOptionsCreationOptions;
}

export interface WebAuthnCredential {
  [key: string]: unknown;
}

/**
 * The account prohibits adding an authenticator, e.g. because of an unverified email address.

 */
export type AddAuthenticatorConflictResponse = ConflictResponse;

export type AuthenticatorsResponse = {
  status: StatusOK;
  data: AuthenticatorList;
};

/**
 * Authenticated by password.

 */
export type AuthenticatedByPasswordResponse = AuthenticatedResponse;

/**
 * Authenticated by code.

 */
export type AuthenticatedByCodeResponse = AuthenticatedResponse;

/**
 * Authenticated by password and 2FA.

 */
export type AuthenticatedByPasswordAnd2FAResponse = AuthenticatedResponse;

export type AuthenticationOrReauthenticationResponse =
  | AuthenticationResponse
  | ReauthenticationResponse;

export type EmailAddressesResponse = {
  status: StatusOK;
  data: EmailAddress[];
};

/**
 * Email verification information.
 */
export type EmailVerificationInfoResponse = EmailVerificationInfo;

export type NotFoundResponseStatus =
  (typeof NotFoundResponseStatus)[keyof typeof NotFoundResponseStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const NotFoundResponseStatus = {
  number404: 404,
} as const;

export type NotFoundResponse = {
  status: NotFoundResponseStatus;
};

export type PasswordResetInfoResponseData = {
  user?: User;
};

export type PasswordResetInfoResponse = {
  status: StatusOK;
  data: PasswordResetInfoResponseData;
};

export type ProviderAccountsResponse = {
  status: StatusOK;
  data: ProviderAccount[];
};

export type ProviderSignupResponseData = {
  email: EmailAddress[];
  account: ProviderAccount;
  user: User;
};

export type ProviderSignupResponse = {
  status: StatusOK;
  data: ProviderSignupResponseData;
};

/**
 * The response indicates reauthentication is required.

 */
export type ReauthenticationRequiredResponse = ReauthenticationResponse;

export type RecoveryCodesResponse = {
  status: StatusOK;
  data: SensitiveRecoveryCodesAuthenticator;
};

export type RefreshTokenResponseData = {
  access_token: AccessToken;
  refresh_token?: RefreshToken;
};

export type RefreshTokenResponse = {
  status: StatusOK;
  data: RefreshTokenResponseData;
};

export type SessionsResponse = {
  status: StatusOK;
  data: Session[];
};

export type StatusOKResponse = {
  status: StatusOK;
};

export type TooManyRequestsResponseStatus =
  (typeof TooManyRequestsResponseStatus)[keyof typeof TooManyRequestsResponseStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TooManyRequestsResponseStatus = {
  number429: 429,
} as const;

export type TooManyRequestsResponse = {
  status: TooManyRequestsResponseStatus;
};

export type TOTPAuthenticatorResponseMeta = {
  /** Whether or not recovery codes where generated automatically. */
  recovery_codes_generated?: boolean;
};

export type TOTPAuthenticatorResponse = {
  status: StatusOK;
  meta?: TOTPAuthenticatorResponseMeta;
  data: TOTPAuthenticator;
};

export type TOTPAuthenticatorNotFoundResponseStatus =
  (typeof TOTPAuthenticatorNotFoundResponseStatus)[keyof typeof TOTPAuthenticatorNotFoundResponseStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TOTPAuthenticatorNotFoundResponseStatus = {
  number404: 404,
} as const;

export type TOTPAuthenticatorNotFoundResponseMeta = {
  /** A TOTP secret that can be used to setup a new authenticator.
   */
  secret: string;
  /** otpauth URI from which a QR code can be generated and scanned by OTP clients.
   */
  totp_url: string;
};

export type TOTPAuthenticatorNotFoundResponse = {
  status: TOTPAuthenticatorNotFoundResponseStatus;
  meta: TOTPAuthenticatorNotFoundResponseMeta;
};

/**
 * There is no authenticated session.

 */
export type UnauthenticatedResponse = AuthenticationResponse;

export type WebAuthnRequestOptionsResponseResponse = {
  status: StatusOK;
  data: WebAuthnCredentialRequestOptions;
};

export type WebAuthnCreationOptionsResponseResponse = {
  status: StatusOK;
  data: WebAuthnCredentialCreationOptions;
};

export type WebAuthnAuthenticatorResponse = {
  status: StatusOK;
  data: WebAuthnAuthenticator;
};

export type AddWebAuthnAuthenticatorResponseMeta = {
  /** Whether or not recovery codes where generated automatically.
   */
  recovery_codes_generated?: boolean;
};

export type AddWebAuthnAuthenticatorResponse = {
  status: StatusOK;
  data: WebAuthnAuthenticator;
  meta: AddWebAuthnAuthenticatorResponseMeta;
};

/**
 * Login.
 */
export type LoginBody = Login;

export type LoginWebAuthnBody = {
  credential: WebAuthnCredential;
};

export type ReauthenticateWebAuthnBody = {
  credential: WebAuthnCredential;
};

export type AuthenticateWebAuthnBody = {
  credential: WebAuthnCredential;
};

export type MFAAuthenticateBody = MFAAuthenticate;

export type MFATrustBody = MFATrust;

export type ConfirmLoginCodeBody = ConfirmLoginCode;

export type EndSessionsBody = EndSessions;

/**
 * Signup using a passkey
 */
export type PasskeySignupBody = PasskeySignup;

export type ProviderAccountBody = {
  provider: ProviderID;
  account: ProviderAccountID;
};

/**
 * Initiate the provider redirect flow.

 */
export type ProviderRedirectBody = ProviderRedirect;

/**
 * Provider signup.
 */
export type ProviderSignupBody = ProviderSignup;

export type ProviderTokenBody = ProviderToken;

/**
 * Reauthenticate.
 */
export type ReauthenticateBody = Reauthenticate;

export type RefreshTokenBody = {
  refresh_token: RefreshToken;
};

/**
 * Request password.
 */
export type RequestPasswordBody = RequestPassword;

/**
 * Request a login code.
 */
export type RequestLoginCodeBody = RequestLoginCode;

export type SetupTOTPBody = {
  code: AuthenticatorCode;
};

/**
 * Signup
 */
export type SignupBody = Signup;

export type ChangePasswordBody = {
  current_password?: Password;
  /** The current password.
   */
  new_password: string;
};

export type EmailBody = {
  email: Email;
};

export type MarkPrimaryEmailBody = {
  /** An email address.
   */
  email: string;
  /** Primary flag.
   */
  primary: boolean;
};

export type PhoneBody = {
  phone: string;
};

export type ResetPasswordBody = ResetPassword;

export type VerifyEmailBody = VerifyEmail;

export type VerifyPhoneBody = VerifyPhone;

export type UpdateWebAuthnBody = {
  id?: AuthenticatorID;
  name?: string;
};

export type AddWebAuthnAuthenticatorBody = {
  name?: string;
  credential: WebAuthnCredential;
};

export type DeleteWebAuthnBody = {
  /** The IDs of the authenticator that are to be deleted.
   */
  authenticators: AuthenticatorID[];
};

/**
 * The email verification key
 */
export type EmailVerificationKeyParameter = string;

/**
 * The password reset key
 */
export type PasswordResetKeyParameter = string;

/**
 * Session token. Only needed when `client` is equal to `app`.

 */
export type SessionTokenParameter = string;

/**
 * When present (regardless of its value), enables passwordless sign-in via a WebAuthn credential (Passkey),
but may enforce additional multi-factor authentication (MFA) requirements. Omit the parameter to disable.

 */
export type PasswordLessParameter = boolean;

export type GetAccountAuthenticatorsWebauthnParams = {
  /**
 * When present (regardless of its value), enables passwordless sign-in via a WebAuthn credential (Passkey),
but may enforce additional multi-factor authentication (MFA) requirements. Omit the parameter to disable.

 */
  passwordless?: PasswordLessParameter;
};

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

/**
 * There are many configuration options that alter the functionality
and behavior of django-allauth, some of which can also impact the
frontend. Therefore, relevant configuration options are exposed via
this endpoint. The data returned is not user/authentication
dependent. Hence, it suffices to only fetch this data once at boot
time of your application.

 * @summary Get configuration
 */
export const getConfig = (
  client: 'app' | 'browser',
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<ConfigurationResponse>(
    { url: `/api/_allauth/${client}/v1/config`, method: 'GET', signal },
    options,
  );
};

export const getGetConfigQueryKey = (client?: 'app' | 'browser') => {
  return [`/api/_allauth/${client}/v1/config`] as const;
};

export const getGetConfigQueryOptions = <
  TData = Awaited<ReturnType<typeof getConfig>>,
  TError = ErrorType<unknown>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getConfig>>, TError, TData>>;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetConfigQueryKey(client);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getConfig>>> = ({ signal }) =>
    getConfig(client, requestOptions, signal);

  return { queryKey, queryFn, enabled: !!client, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getConfig>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetConfigQueryResult = NonNullable<Awaited<ReturnType<typeof getConfig>>>;
export type GetConfigQueryError = ErrorType<unknown>;

export function useGetConfig<
  TData = Awaited<ReturnType<typeof getConfig>>,
  TError = ErrorType<unknown>,
>(
  client: 'app' | 'browser',
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getConfig>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getConfig>>,
          TError,
          Awaited<ReturnType<typeof getConfig>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetConfig<
  TData = Awaited<ReturnType<typeof getConfig>>,
  TError = ErrorType<unknown>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getConfig>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getConfig>>,
          TError,
          Awaited<ReturnType<typeof getConfig>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetConfig<
  TData = Awaited<ReturnType<typeof getConfig>>,
  TError = ErrorType<unknown>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getConfig>>, TError, TData>>;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get configuration
 */

export function useGetConfig<
  TData = Awaited<ReturnType<typeof getConfig>>,
  TError = ErrorType<unknown>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getConfig>>, TError, TData>>;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetConfigQueryOptions(client, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Login using a username-password or email-password combination.

 * @summary Login
 */
export const postAuthLogin = (
  client: 'app' | 'browser',
  loginBody: BodyType<LoginBody>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<AuthenticatedByPasswordResponse>(
    {
      url: `/api/_allauth/${client}/v1/auth/login`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: loginBody,
      signal,
    },
    options,
  );
};

export const getPostAuthLoginMutationOptions = <
  TError = ErrorType<ErrorResponse | AuthenticationResponse | ConflictResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postAuthLogin>>,
    TError,
    { client: 'app' | 'browser'; data: BodyType<LoginBody> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postAuthLogin>>,
  TError,
  { client: 'app' | 'browser'; data: BodyType<LoginBody> },
  TContext
> => {
  const mutationKey = ['postAuthLogin'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postAuthLogin>>,
    { client: 'app' | 'browser'; data: BodyType<LoginBody> }
  > = props => {
    const { client, data } = props ?? {};

    return postAuthLogin(client, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostAuthLoginMutationResult = NonNullable<Awaited<ReturnType<typeof postAuthLogin>>>;
export type PostAuthLoginMutationBody = BodyType<LoginBody>;
export type PostAuthLoginMutationError = ErrorType<
  ErrorResponse | AuthenticationResponse | ConflictResponse
>;

/**
 * @summary Login
 */
export const usePostAuthLogin = <
  TError = ErrorType<ErrorResponse | AuthenticationResponse | ConflictResponse>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postAuthLogin>>,
      TError,
      { client: 'app' | 'browser'; data: BodyType<LoginBody> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof postAuthLogin>>,
  TError,
  { client: 'app' | 'browser'; data: BodyType<LoginBody> },
  TContext
> => {
  const mutationOptions = getPostAuthLoginMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Whether or not `username`, `email`, `phone` or combination of those are
required depends on the configuration of django-allauth. Additionally,
if a custom signup form is used there may be other custom properties
required.

 * @summary Signup
 */
export const postAuthSignup = (
  client: 'app' | 'browser',
  signupBody: BodyType<SignupBody>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<AuthenticatedByPasswordResponse>(
    {
      url: `/api/_allauth/${client}/v1/auth/signup`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: signupBody,
      signal,
    },
    options,
  );
};

export const getPostAuthSignupMutationOptions = <
  TError = ErrorType<ErrorResponse | AuthenticationResponse | ForbiddenResponse | ConflictResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postAuthSignup>>,
    TError,
    { client: 'app' | 'browser'; data: BodyType<SignupBody> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postAuthSignup>>,
  TError,
  { client: 'app' | 'browser'; data: BodyType<SignupBody> },
  TContext
> => {
  const mutationKey = ['postAuthSignup'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postAuthSignup>>,
    { client: 'app' | 'browser'; data: BodyType<SignupBody> }
  > = props => {
    const { client, data } = props ?? {};

    return postAuthSignup(client, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostAuthSignupMutationResult = NonNullable<Awaited<ReturnType<typeof postAuthSignup>>>;
export type PostAuthSignupMutationBody = BodyType<SignupBody>;
export type PostAuthSignupMutationError = ErrorType<
  ErrorResponse | AuthenticationResponse | ForbiddenResponse | ConflictResponse
>;

/**
 * @summary Signup
 */
export const usePostAuthSignup = <
  TError = ErrorType<ErrorResponse | AuthenticationResponse | ForbiddenResponse | ConflictResponse>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postAuthSignup>>,
      TError,
      { client: 'app' | 'browser'; data: BodyType<SignupBody> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof postAuthSignup>>,
  TError,
  { client: 'app' | 'browser'; data: BodyType<SignupBody> },
  TContext
> => {
  const mutationOptions = getPostAuthSignupMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Obtain email verification information, given the token that was sent to
the user by email.

 * @summary Get email verification information
 */
export const getAuthEmailVerify = (
  client: 'app' | 'browser',
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<EmailVerificationInfoResponse>(
    { url: `/api/_allauth/${client}/v1/auth/email/verify`, method: 'GET', signal },
    options,
  );
};

export const getGetAuthEmailVerifyQueryKey = (client?: 'app' | 'browser') => {
  return [`/api/_allauth/${client}/v1/auth/email/verify`] as const;
};

export const getGetAuthEmailVerifyQueryOptions = <
  TData = Awaited<ReturnType<typeof getAuthEmailVerify>>,
  TError = ErrorType<ErrorResponse | ConflictResponse>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAuthEmailVerify>>, TError, TData>>;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAuthEmailVerifyQueryKey(client);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAuthEmailVerify>>> = ({ signal }) =>
    getAuthEmailVerify(client, requestOptions, signal);

  return { queryKey, queryFn, enabled: !!client, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getAuthEmailVerify>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetAuthEmailVerifyQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAuthEmailVerify>>
>;
export type GetAuthEmailVerifyQueryError = ErrorType<ErrorResponse | ConflictResponse>;

export function useGetAuthEmailVerify<
  TData = Awaited<ReturnType<typeof getAuthEmailVerify>>,
  TError = ErrorType<ErrorResponse | ConflictResponse>,
>(
  client: 'app' | 'browser',
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAuthEmailVerify>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAuthEmailVerify>>,
          TError,
          Awaited<ReturnType<typeof getAuthEmailVerify>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAuthEmailVerify<
  TData = Awaited<ReturnType<typeof getAuthEmailVerify>>,
  TError = ErrorType<ErrorResponse | ConflictResponse>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAuthEmailVerify>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAuthEmailVerify>>,
          TError,
          Awaited<ReturnType<typeof getAuthEmailVerify>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAuthEmailVerify<
  TData = Awaited<ReturnType<typeof getAuthEmailVerify>>,
  TError = ErrorType<ErrorResponse | ConflictResponse>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAuthEmailVerify>>, TError, TData>>;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get email verification information
 */

export function useGetAuthEmailVerify<
  TData = Awaited<ReturnType<typeof getAuthEmailVerify>>,
  TError = ErrorType<ErrorResponse | ConflictResponse>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAuthEmailVerify>>, TError, TData>>;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetAuthEmailVerifyQueryOptions(client, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Complete the email verification process. Depending on the configuration,
email addresses are either verified by opening a link that is sent to
their email address, or, by inputting a code that is sent. On the API,
both cases are handled identically. Meaning, the required key is either
the one from the link, or, the code itself.

Note that a status code of 401 does not imply failure. It indicates that
the email verification was successful, yet, the user is still not signed
in. For example, in case `ACCOUNT_LOGIN_ON_EMAIL_CONFIRMATION` is set to
`False`, a 401 is returned when verifying as part of login/signup.

 * @summary Verify an email
 */
export const postAuthEmailVerify = (
  client: 'app' | 'browser',
  verifyEmailBody: BodyType<VerifyEmailBody>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<AuthenticatedResponse>(
    {
      url: `/api/_allauth/${client}/v1/auth/email/verify`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: verifyEmailBody,
      signal,
    },
    options,
  );
};

export const getPostAuthEmailVerifyMutationOptions = <
  TError = ErrorType<ErrorResponse | UnauthenticatedResponse | ConflictResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postAuthEmailVerify>>,
    TError,
    { client: 'app' | 'browser'; data: BodyType<VerifyEmailBody> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postAuthEmailVerify>>,
  TError,
  { client: 'app' | 'browser'; data: BodyType<VerifyEmailBody> },
  TContext
> => {
  const mutationKey = ['postAuthEmailVerify'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postAuthEmailVerify>>,
    { client: 'app' | 'browser'; data: BodyType<VerifyEmailBody> }
  > = props => {
    const { client, data } = props ?? {};

    return postAuthEmailVerify(client, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostAuthEmailVerifyMutationResult = NonNullable<
  Awaited<ReturnType<typeof postAuthEmailVerify>>
>;
export type PostAuthEmailVerifyMutationBody = BodyType<VerifyEmailBody>;
export type PostAuthEmailVerifyMutationError = ErrorType<
  ErrorResponse | UnauthenticatedResponse | ConflictResponse
>;

/**
 * @summary Verify an email
 */
export const usePostAuthEmailVerify = <
  TError = ErrorType<ErrorResponse | UnauthenticatedResponse | ConflictResponse>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postAuthEmailVerify>>,
      TError,
      { client: 'app' | 'browser'; data: BodyType<VerifyEmailBody> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof postAuthEmailVerify>>,
  TError,
  { client: 'app' | 'browser'; data: BodyType<VerifyEmailBody> },
  TContext
> => {
  const mutationOptions = getPostAuthEmailVerifyMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Requests a new email verification code.
Requires `ACCOUNT_EMAIL_VERIFICATION_SUPPORTS_RESEND = True`.

 * @summary Resend email verification code
 */
export const postAuthEmailVerifyResend = (
  client: 'app' | 'browser',
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<StatusOKResponse>(
    { url: `/api/_allauth/${client}/v1/auth/email/verify/resend`, method: 'POST', signal },
    options,
  );
};

export const getPostAuthEmailVerifyResendMutationOptions = <
  TError = ErrorType<ConflictResponse | TooManyRequestsResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postAuthEmailVerifyResend>>,
    TError,
    { client: 'app' | 'browser' },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postAuthEmailVerifyResend>>,
  TError,
  { client: 'app' | 'browser' },
  TContext
> => {
  const mutationKey = ['postAuthEmailVerifyResend'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postAuthEmailVerifyResend>>,
    { client: 'app' | 'browser' }
  > = props => {
    const { client } = props ?? {};

    return postAuthEmailVerifyResend(client, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostAuthEmailVerifyResendMutationResult = NonNullable<
  Awaited<ReturnType<typeof postAuthEmailVerifyResend>>
>;

export type PostAuthEmailVerifyResendMutationError = ErrorType<
  ConflictResponse | TooManyRequestsResponse
>;

/**
 * @summary Resend email verification code
 */
export const usePostAuthEmailVerifyResend = <
  TError = ErrorType<ConflictResponse | TooManyRequestsResponse>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postAuthEmailVerifyResend>>,
      TError,
      { client: 'app' | 'browser' },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof postAuthEmailVerifyResend>>,
  TError,
  { client: 'app' | 'browser' },
  TContext
> => {
  const mutationOptions = getPostAuthEmailVerifyResendMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Complete the phone number verification process. Note that a status code
of 401 does not imply failure. It merely indicates that the phone number
verification was successful, yet, the user is still not signed in.

 * @summary Verify a phone number
 */
export const postAuthPhoneVerify = (
  client: 'app' | 'browser',
  verifyPhoneBody: BodyType<VerifyPhoneBody>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<AuthenticatedResponse>(
    {
      url: `/api/_allauth/${client}/v1/auth/phone/verify`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: verifyPhoneBody,
      signal,
    },
    options,
  );
};

export const getPostAuthPhoneVerifyMutationOptions = <
  TError = ErrorType<ErrorResponse | UnauthenticatedResponse | ConflictResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postAuthPhoneVerify>>,
    TError,
    { client: 'app' | 'browser'; data: BodyType<VerifyPhoneBody> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postAuthPhoneVerify>>,
  TError,
  { client: 'app' | 'browser'; data: BodyType<VerifyPhoneBody> },
  TContext
> => {
  const mutationKey = ['postAuthPhoneVerify'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postAuthPhoneVerify>>,
    { client: 'app' | 'browser'; data: BodyType<VerifyPhoneBody> }
  > = props => {
    const { client, data } = props ?? {};

    return postAuthPhoneVerify(client, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostAuthPhoneVerifyMutationResult = NonNullable<
  Awaited<ReturnType<typeof postAuthPhoneVerify>>
>;
export type PostAuthPhoneVerifyMutationBody = BodyType<VerifyPhoneBody>;
export type PostAuthPhoneVerifyMutationError = ErrorType<
  ErrorResponse | UnauthenticatedResponse | ConflictResponse
>;

/**
 * @summary Verify a phone number
 */
export const usePostAuthPhoneVerify = <
  TError = ErrorType<ErrorResponse | UnauthenticatedResponse | ConflictResponse>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postAuthPhoneVerify>>,
      TError,
      { client: 'app' | 'browser'; data: BodyType<VerifyPhoneBody> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof postAuthPhoneVerify>>,
  TError,
  { client: 'app' | 'browser'; data: BodyType<VerifyPhoneBody> },
  TContext
> => {
  const mutationOptions = getPostAuthPhoneVerifyMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Requests a new phone number verification code.
Requires `ACCOUNT_PHONE_VERIFICATION_SUPPORTS_RESEND = True`.

 * @summary Resend phone number verification code
 */
export const postAuthPhoneVerifyResend = (
  client: 'app' | 'browser',
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<StatusOKResponse>(
    { url: `/api/_allauth/${client}/v1/auth/phone/verify/resend`, method: 'POST', signal },
    options,
  );
};

export const getPostAuthPhoneVerifyResendMutationOptions = <
  TError = ErrorType<ConflictResponse | TooManyRequestsResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postAuthPhoneVerifyResend>>,
    TError,
    { client: 'app' | 'browser' },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postAuthPhoneVerifyResend>>,
  TError,
  { client: 'app' | 'browser' },
  TContext
> => {
  const mutationKey = ['postAuthPhoneVerifyResend'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postAuthPhoneVerifyResend>>,
    { client: 'app' | 'browser' }
  > = props => {
    const { client } = props ?? {};

    return postAuthPhoneVerifyResend(client, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostAuthPhoneVerifyResendMutationResult = NonNullable<
  Awaited<ReturnType<typeof postAuthPhoneVerifyResend>>
>;

export type PostAuthPhoneVerifyResendMutationError = ErrorType<
  ConflictResponse | TooManyRequestsResponse
>;

/**
 * @summary Resend phone number verification code
 */
export const usePostAuthPhoneVerifyResend = <
  TError = ErrorType<ConflictResponse | TooManyRequestsResponse>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postAuthPhoneVerifyResend>>,
      TError,
      { client: 'app' | 'browser' },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof postAuthPhoneVerifyResend>>,
  TError,
  { client: 'app' | 'browser' },
  TContext
> => {
  const mutationOptions = getPostAuthPhoneVerifyResendMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * In order to safeguard the account, some actions require the user to be
recently authenticated.  If you try to perform such an action without
having been recently authenticated, a `401` status is returned, listing
flows that can be performed to reauthenticate. One such flow is the flow
with ID `reauthenticate`, which allows for the user to input the
password. This is the endpoint related towards that flow.

 * @summary Reauthenticate
 */
export const postAuthReauthenticate = (
  client: 'app' | 'browser',
  reauthenticateBody: BodyType<ReauthenticateBody>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<AuthenticatedByPasswordResponse>(
    {
      url: `/api/_allauth/${client}/v1/auth/reauthenticate`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: reauthenticateBody,
      signal,
    },
    options,
  );
};

export const getPostAuthReauthenticateMutationOptions = <
  TError = ErrorType<ErrorResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postAuthReauthenticate>>,
    TError,
    { client: 'app' | 'browser'; data: BodyType<ReauthenticateBody> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postAuthReauthenticate>>,
  TError,
  { client: 'app' | 'browser'; data: BodyType<ReauthenticateBody> },
  TContext
> => {
  const mutationKey = ['postAuthReauthenticate'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postAuthReauthenticate>>,
    { client: 'app' | 'browser'; data: BodyType<ReauthenticateBody> }
  > = props => {
    const { client, data } = props ?? {};

    return postAuthReauthenticate(client, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostAuthReauthenticateMutationResult = NonNullable<
  Awaited<ReturnType<typeof postAuthReauthenticate>>
>;
export type PostAuthReauthenticateMutationBody = BodyType<ReauthenticateBody>;
export type PostAuthReauthenticateMutationError = ErrorType<ErrorResponse>;

/**
 * @summary Reauthenticate
 */
export const usePostAuthReauthenticate = <TError = ErrorType<ErrorResponse>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postAuthReauthenticate>>,
      TError,
      { client: 'app' | 'browser'; data: BodyType<ReauthenticateBody> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof postAuthReauthenticate>>,
  TError,
  { client: 'app' | 'browser'; data: BodyType<ReauthenticateBody> },
  TContext
> => {
  const mutationOptions = getPostAuthReauthenticateMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Initiates the password reset procedure. Depending on whether or not
`ACCOUNT_PASSWORD_RESET_BY_CODE_ENABLED` is `True`, the procedure is
either stateless or stateful.

In case codes are used, it is stateful, and a new
`password_reset_by_code` flow is started. In this case, on a successful
password reset request, you will receive a 401 indicating the pending
status of this flow.

In case password reset is configured to use (stateless) links, you will
receive a 200 on a successful password reset request.

 * @summary Request password
 */
export const postAuthPasswordRequest = (
  client: 'app' | 'browser',
  requestPasswordBody: BodyType<RequestPasswordBody>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<StatusOKResponse>(
    {
      url: `/api/_allauth/${client}/v1/auth/password/request`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: requestPasswordBody,
      signal,
    },
    options,
  );
};

export const getPostAuthPasswordRequestMutationOptions = <
  TError = ErrorType<ErrorResponse | AuthenticationResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postAuthPasswordRequest>>,
    TError,
    { client: 'app' | 'browser'; data: BodyType<RequestPasswordBody> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postAuthPasswordRequest>>,
  TError,
  { client: 'app' | 'browser'; data: BodyType<RequestPasswordBody> },
  TContext
> => {
  const mutationKey = ['postAuthPasswordRequest'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postAuthPasswordRequest>>,
    { client: 'app' | 'browser'; data: BodyType<RequestPasswordBody> }
  > = props => {
    const { client, data } = props ?? {};

    return postAuthPasswordRequest(client, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostAuthPasswordRequestMutationResult = NonNullable<
  Awaited<ReturnType<typeof postAuthPasswordRequest>>
>;
export type PostAuthPasswordRequestMutationBody = BodyType<RequestPasswordBody>;
export type PostAuthPasswordRequestMutationError = ErrorType<
  ErrorResponse | AuthenticationResponse
>;

/**
 * @summary Request password
 */
export const usePostAuthPasswordRequest = <
  TError = ErrorType<ErrorResponse | AuthenticationResponse>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postAuthPasswordRequest>>,
      TError,
      { client: 'app' | 'browser'; data: BodyType<RequestPasswordBody> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof postAuthPasswordRequest>>,
  TError,
  { client: 'app' | 'browser'; data: BodyType<RequestPasswordBody> },
  TContext
> => {
  const mutationOptions = getPostAuthPasswordRequestMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Used to obtain information on and validate a password reset key.  The
key passed is either the key encoded in the password reset URL that the
user has received per email, or, the password reset code in case of
`ACCOUNT_PASSWORD_RESET_BY_CODE_ENABLED`. Note that in case of a code,
the number of requests you can make is limited (by
`ACCOUNT_PASSWORD_RESET_BY_CODE_MAX_ATTEMPTS`).

 * @summary Get password reset information
 */
export const getAuthPasswordReset = (
  client: 'app' | 'browser',
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<PasswordResetInfoResponse>(
    { url: `/api/_allauth/${client}/v1/auth/password/reset`, method: 'GET', signal },
    options,
  );
};

export const getGetAuthPasswordResetQueryKey = (client?: 'app' | 'browser') => {
  return [`/api/_allauth/${client}/v1/auth/password/reset`] as const;
};

export const getGetAuthPasswordResetQueryOptions = <
  TData = Awaited<ReturnType<typeof getAuthPasswordReset>>,
  TError = ErrorType<ErrorResponse | ConflictResponse>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAuthPasswordReset>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAuthPasswordResetQueryKey(client);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAuthPasswordReset>>> = ({ signal }) =>
    getAuthPasswordReset(client, requestOptions, signal);

  return { queryKey, queryFn, enabled: !!client, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getAuthPasswordReset>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetAuthPasswordResetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAuthPasswordReset>>
>;
export type GetAuthPasswordResetQueryError = ErrorType<ErrorResponse | ConflictResponse>;

export function useGetAuthPasswordReset<
  TData = Awaited<ReturnType<typeof getAuthPasswordReset>>,
  TError = ErrorType<ErrorResponse | ConflictResponse>,
>(
  client: 'app' | 'browser',
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAuthPasswordReset>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAuthPasswordReset>>,
          TError,
          Awaited<ReturnType<typeof getAuthPasswordReset>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAuthPasswordReset<
  TData = Awaited<ReturnType<typeof getAuthPasswordReset>>,
  TError = ErrorType<ErrorResponse | ConflictResponse>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAuthPasswordReset>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAuthPasswordReset>>,
          TError,
          Awaited<ReturnType<typeof getAuthPasswordReset>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAuthPasswordReset<
  TData = Awaited<ReturnType<typeof getAuthPasswordReset>>,
  TError = ErrorType<ErrorResponse | ConflictResponse>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAuthPasswordReset>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get password reset information
 */

export function useGetAuthPasswordReset<
  TData = Awaited<ReturnType<typeof getAuthPasswordReset>>,
  TError = ErrorType<ErrorResponse | ConflictResponse>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAuthPasswordReset>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetAuthPasswordResetQueryOptions(client, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Perform the password reset, by handing over the password reset key and
the new password. After successfully completing the password reset, the
user is either logged in (in case `ACCOUNT_LOGIN_ON_PASSWORD_RESET` is
`True`), or, the user will need to proceed to the login page.  In case
of the former, a `200` status code is returned, in case of the latter a
401.

 * @summary Reset password
 */
export const postAuthPasswordReset = (
  client: 'app' | 'browser',
  resetPasswordBody: BodyType<ResetPasswordBody>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<AuthenticatedByPasswordResponse>(
    {
      url: `/api/_allauth/${client}/v1/auth/password/reset`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: resetPasswordBody,
      signal,
    },
    options,
  );
};

export const getPostAuthPasswordResetMutationOptions = <
  TError = ErrorType<ErrorResponse | AuthenticationResponse | ConflictResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postAuthPasswordReset>>,
    TError,
    { client: 'app' | 'browser'; data: BodyType<ResetPasswordBody> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postAuthPasswordReset>>,
  TError,
  { client: 'app' | 'browser'; data: BodyType<ResetPasswordBody> },
  TContext
> => {
  const mutationKey = ['postAuthPasswordReset'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postAuthPasswordReset>>,
    { client: 'app' | 'browser'; data: BodyType<ResetPasswordBody> }
  > = props => {
    const { client, data } = props ?? {};

    return postAuthPasswordReset(client, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostAuthPasswordResetMutationResult = NonNullable<
  Awaited<ReturnType<typeof postAuthPasswordReset>>
>;
export type PostAuthPasswordResetMutationBody = BodyType<ResetPasswordBody>;
export type PostAuthPasswordResetMutationError = ErrorType<
  ErrorResponse | AuthenticationResponse | ConflictResponse
>;

/**
 * @summary Reset password
 */
export const usePostAuthPasswordReset = <
  TError = ErrorType<ErrorResponse | AuthenticationResponse | ConflictResponse>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postAuthPasswordReset>>,
      TError,
      { client: 'app' | 'browser'; data: BodyType<ResetPasswordBody> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof postAuthPasswordReset>>,
  TError,
  { client: 'app' | 'browser'; data: BodyType<ResetPasswordBody> },
  TContext
> => {
  const mutationOptions = getPostAuthPasswordResetMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Initiates the third-party provider authentication redirect flow. As calling
this endpoint results in a user facing redirect (302), this call is only
available in a browser, and must be called in a synchronous (non-XHR)
manner.

 * @summary Provider redirect
 */
export const postBrowserAuthProviderRedirect = (
  providerRedirectBody: BodyType<ProviderRedirectBody>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  const formUrlEncoded = new URLSearchParams();
  formUrlEncoded.append(`provider`, providerRedirectBody.provider);
  formUrlEncoded.append(`callback_url`, providerRedirectBody.callback_url);
  formUrlEncoded.append(`process`, providerRedirectBody.process);

  return customInstance<unknown>(
    {
      url: `/api/_allauth/browser/v1/auth/provider/redirect`,
      method: 'POST',
      headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
      data: formUrlEncoded,
      signal,
    },
    options,
  );
};

export const getPostBrowserAuthProviderRedirectMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postBrowserAuthProviderRedirect>>,
    TError,
    { data: BodyType<ProviderRedirectBody> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postBrowserAuthProviderRedirect>>,
  TError,
  { data: BodyType<ProviderRedirectBody> },
  TContext
> => {
  const mutationKey = ['postBrowserAuthProviderRedirect'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postBrowserAuthProviderRedirect>>,
    { data: BodyType<ProviderRedirectBody> }
  > = props => {
    const { data } = props ?? {};

    return postBrowserAuthProviderRedirect(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostBrowserAuthProviderRedirectMutationResult = NonNullable<
  Awaited<ReturnType<typeof postBrowserAuthProviderRedirect>>
>;
export type PostBrowserAuthProviderRedirectMutationBody = BodyType<ProviderRedirectBody>;
export type PostBrowserAuthProviderRedirectMutationError = ErrorType<void>;

/**
 * @summary Provider redirect
 */
export const usePostBrowserAuthProviderRedirect = <TError = ErrorType<void>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postBrowserAuthProviderRedirect>>,
      TError,
      { data: BodyType<ProviderRedirectBody> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof postBrowserAuthProviderRedirect>>,
  TError,
  { data: BodyType<ProviderRedirectBody> },
  TContext
> => {
  const mutationOptions = getPostBrowserAuthProviderRedirectMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Authenticates with a third-party provider using provider tokens received
by other means. For example, in case of a mobile app, the authentication
flow runs completely on the device itself, without any interaction with
the API. Then, when the (device) authentication completes and the mobile
app receives an access and/or ID token, it can hand over these tokens
via this endpoint to authenticate on the server.

 * @summary Provider token
 */
export const postAuthProviderToken = (
  client: 'app' | 'browser',
  providerTokenBody: BodyType<ProviderTokenBody>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<AuthenticatedResponse>(
    {
      url: `/api/_allauth/${client}/v1/auth/provider/token`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: providerTokenBody,
      signal,
    },
    options,
  );
};

export const getPostAuthProviderTokenMutationOptions = <
  TError = ErrorType<ErrorResponse | AuthenticationResponse | ForbiddenResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postAuthProviderToken>>,
    TError,
    { client: 'app' | 'browser'; data: BodyType<ProviderTokenBody> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postAuthProviderToken>>,
  TError,
  { client: 'app' | 'browser'; data: BodyType<ProviderTokenBody> },
  TContext
> => {
  const mutationKey = ['postAuthProviderToken'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postAuthProviderToken>>,
    { client: 'app' | 'browser'; data: BodyType<ProviderTokenBody> }
  > = props => {
    const { client, data } = props ?? {};

    return postAuthProviderToken(client, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostAuthProviderTokenMutationResult = NonNullable<
  Awaited<ReturnType<typeof postAuthProviderToken>>
>;
export type PostAuthProviderTokenMutationBody = BodyType<ProviderTokenBody>;
export type PostAuthProviderTokenMutationError = ErrorType<
  ErrorResponse | AuthenticationResponse | ForbiddenResponse
>;

/**
 * @summary Provider token
 */
export const usePostAuthProviderToken = <
  TError = ErrorType<ErrorResponse | AuthenticationResponse | ForbiddenResponse>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postAuthProviderToken>>,
      TError,
      { client: 'app' | 'browser'; data: BodyType<ProviderTokenBody> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof postAuthProviderToken>>,
  TError,
  { client: 'app' | 'browser'; data: BodyType<ProviderTokenBody> },
  TContext
> => {
  const mutationOptions = getPostAuthProviderTokenMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * If, while signing up using a third-party provider account, there is
insufficient information received from the provider to automatically
complete the signup process, an additional step is needed to complete
the missing data before the user is fully signed up and authenticated.
The information available so far, such as the pending provider account,
can be retrieved via this endpoint.

 * @summary Provider signup information
 */
export const getAuthProviderSignup = (
  client: 'app' | 'browser',
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<ProviderSignupResponse>(
    { url: `/api/_allauth/${client}/v1/auth/provider/signup`, method: 'GET', signal },
    options,
  );
};

export const getGetAuthProviderSignupQueryKey = (client?: 'app' | 'browser') => {
  return [`/api/_allauth/${client}/v1/auth/provider/signup`] as const;
};

export const getGetAuthProviderSignupQueryOptions = <
  TData = Awaited<ReturnType<typeof getAuthProviderSignup>>,
  TError = ErrorType<ConflictResponse>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAuthProviderSignup>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAuthProviderSignupQueryKey(client);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAuthProviderSignup>>> = ({ signal }) =>
    getAuthProviderSignup(client, requestOptions, signal);

  return { queryKey, queryFn, enabled: !!client, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getAuthProviderSignup>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetAuthProviderSignupQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAuthProviderSignup>>
>;
export type GetAuthProviderSignupQueryError = ErrorType<ConflictResponse>;

export function useGetAuthProviderSignup<
  TData = Awaited<ReturnType<typeof getAuthProviderSignup>>,
  TError = ErrorType<ConflictResponse>,
>(
  client: 'app' | 'browser',
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAuthProviderSignup>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAuthProviderSignup>>,
          TError,
          Awaited<ReturnType<typeof getAuthProviderSignup>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAuthProviderSignup<
  TData = Awaited<ReturnType<typeof getAuthProviderSignup>>,
  TError = ErrorType<ConflictResponse>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAuthProviderSignup>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAuthProviderSignup>>,
          TError,
          Awaited<ReturnType<typeof getAuthProviderSignup>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAuthProviderSignup<
  TData = Awaited<ReturnType<typeof getAuthProviderSignup>>,
  TError = ErrorType<ConflictResponse>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAuthProviderSignup>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Provider signup information
 */

export function useGetAuthProviderSignup<
  TData = Awaited<ReturnType<typeof getAuthProviderSignup>>,
  TError = ErrorType<ConflictResponse>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAuthProviderSignup>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetAuthProviderSignupQueryOptions(client, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * If, while signing up using a third-party provider account, there is
insufficient information received from the provider to automatically
complete the signup process, an additional step is needed to complete
the missing data before the user is fully signed up and authenticated.

 * @summary Provider signup
 */
export const postAuthProviderSignup = (
  client: 'app' | 'browser',
  providerSignupBody: BodyType<ProviderSignupBody>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<AuthenticatedResponse>(
    {
      url: `/api/_allauth/${client}/v1/auth/provider/signup`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: providerSignupBody,
      signal,
    },
    options,
  );
};

export const getPostAuthProviderSignupMutationOptions = <
  TError = ErrorType<ErrorResponse | AuthenticationResponse | ForbiddenResponse | ConflictResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postAuthProviderSignup>>,
    TError,
    { client: 'app' | 'browser'; data: BodyType<ProviderSignupBody> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postAuthProviderSignup>>,
  TError,
  { client: 'app' | 'browser'; data: BodyType<ProviderSignupBody> },
  TContext
> => {
  const mutationKey = ['postAuthProviderSignup'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postAuthProviderSignup>>,
    { client: 'app' | 'browser'; data: BodyType<ProviderSignupBody> }
  > = props => {
    const { client, data } = props ?? {};

    return postAuthProviderSignup(client, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostAuthProviderSignupMutationResult = NonNullable<
  Awaited<ReturnType<typeof postAuthProviderSignup>>
>;
export type PostAuthProviderSignupMutationBody = BodyType<ProviderSignupBody>;
export type PostAuthProviderSignupMutationError = ErrorType<
  ErrorResponse | AuthenticationResponse | ForbiddenResponse | ConflictResponse
>;

/**
 * @summary Provider signup
 */
export const usePostAuthProviderSignup = <
  TError = ErrorType<ErrorResponse | AuthenticationResponse | ForbiddenResponse | ConflictResponse>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postAuthProviderSignup>>,
      TError,
      { client: 'app' | 'browser'; data: BodyType<ProviderSignupBody> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof postAuthProviderSignup>>,
  TError,
  { client: 'app' | 'browser'; data: BodyType<ProviderSignupBody> },
  TContext
> => {
  const mutationOptions = getPostAuthProviderSignupMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * If, during authentication,  a response with status 401 is encountered where one of the pending
flows has ID `mfa_authenticate`, that indicates that the Two-Factor Authentication stage needs to
be completed.

 * @summary Two-factor authentication
 */
export const postAuth2faAuthenticate = (
  client: 'app' | 'browser',
  mFAAuthenticateBody: BodyType<MFAAuthenticateBody>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<AuthenticatedByPasswordAnd2FAResponse>(
    {
      url: `/api/_allauth/${client}/v1/auth/2fa/authenticate`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: mFAAuthenticateBody,
      signal,
    },
    options,
  );
};

export const getPostAuth2faAuthenticateMutationOptions = <
  TError = ErrorType<ErrorResponse | AuthenticationResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postAuth2faAuthenticate>>,
    TError,
    { client: 'app' | 'browser'; data: BodyType<MFAAuthenticateBody> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postAuth2faAuthenticate>>,
  TError,
  { client: 'app' | 'browser'; data: BodyType<MFAAuthenticateBody> },
  TContext
> => {
  const mutationKey = ['postAuth2faAuthenticate'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postAuth2faAuthenticate>>,
    { client: 'app' | 'browser'; data: BodyType<MFAAuthenticateBody> }
  > = props => {
    const { client, data } = props ?? {};

    return postAuth2faAuthenticate(client, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostAuth2faAuthenticateMutationResult = NonNullable<
  Awaited<ReturnType<typeof postAuth2faAuthenticate>>
>;
export type PostAuth2faAuthenticateMutationBody = BodyType<MFAAuthenticateBody>;
export type PostAuth2faAuthenticateMutationError = ErrorType<
  ErrorResponse | AuthenticationResponse
>;

/**
 * @summary Two-factor authentication
 */
export const usePostAuth2faAuthenticate = <
  TError = ErrorType<ErrorResponse | AuthenticationResponse>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postAuth2faAuthenticate>>,
      TError,
      { client: 'app' | 'browser'; data: BodyType<MFAAuthenticateBody> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof postAuth2faAuthenticate>>,
  TError,
  { client: 'app' | 'browser'; data: BodyType<MFAAuthenticateBody> },
  TContext
> => {
  const mutationOptions = getPostAuth2faAuthenticateMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * In order to safeguard the account, some actions require the user to be
recently authenticated.  If you try to perform such an action without
having been recently authenticated, a `401` status is returned, listing
flows that can be performed to reauthenticate. One such flow is the flow
with ID `mfa_reauthenticate`, which allows for the user to input an
authenticator code (e.g. TOTP or recovery code). This is the endpoint
related towards that flow.

 * @summary Reauthenticate using 2FA
 */
export const postAuth2faReauthenticate = (
  client: 'app' | 'browser',
  mFAAuthenticateBody: BodyType<MFAAuthenticateBody>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<AuthenticatedByPasswordAnd2FAResponse>(
    {
      url: `/api/_allauth/${client}/v1/auth/2fa/reauthenticate`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: mFAAuthenticateBody,
      signal,
    },
    options,
  );
};

export const getPostAuth2faReauthenticateMutationOptions = <
  TError = ErrorType<ErrorResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postAuth2faReauthenticate>>,
    TError,
    { client: 'app' | 'browser'; data: BodyType<MFAAuthenticateBody> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postAuth2faReauthenticate>>,
  TError,
  { client: 'app' | 'browser'; data: BodyType<MFAAuthenticateBody> },
  TContext
> => {
  const mutationKey = ['postAuth2faReauthenticate'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postAuth2faReauthenticate>>,
    { client: 'app' | 'browser'; data: BodyType<MFAAuthenticateBody> }
  > = props => {
    const { client, data } = props ?? {};

    return postAuth2faReauthenticate(client, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostAuth2faReauthenticateMutationResult = NonNullable<
  Awaited<ReturnType<typeof postAuth2faReauthenticate>>
>;
export type PostAuth2faReauthenticateMutationBody = BodyType<MFAAuthenticateBody>;
export type PostAuth2faReauthenticateMutationError = ErrorType<ErrorResponse>;

/**
 * @summary Reauthenticate using 2FA
 */
export const usePostAuth2faReauthenticate = <TError = ErrorType<ErrorResponse>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postAuth2faReauthenticate>>,
      TError,
      { client: 'app' | 'browser'; data: BodyType<MFAAuthenticateBody> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof postAuth2faReauthenticate>>,
  TError,
  { client: 'app' | 'browser'; data: BodyType<MFAAuthenticateBody> },
  TContext
> => {
  const mutationOptions = getPostAuth2faReauthenticateMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * If "Trust this browser?" is enabled (`MFA_TRUST_ENABLED`), the
`mfa_trust` flow activates after the user completes the MFA
authentication flow, offering to skip MFA for this particular
browser. This endpoint is used to complete the `mfa_trust` flow.

 * @summary Trust this browser
 */
export const postBrowserAuth2faTrust = (
  mFATrustBody: BodyType<MFATrustBody>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<AuthenticatedByPasswordAnd2FAResponse>(
    {
      url: `/api/_allauth/browser/v1/auth/2fa/trust`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: mFATrustBody,
      signal,
    },
    options,
  );
};

export const getPostBrowserAuth2faTrustMutationOptions = <
  TError = ErrorType<ErrorResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postBrowserAuth2faTrust>>,
    TError,
    { data: BodyType<MFATrustBody> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postBrowserAuth2faTrust>>,
  TError,
  { data: BodyType<MFATrustBody> },
  TContext
> => {
  const mutationKey = ['postBrowserAuth2faTrust'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postBrowserAuth2faTrust>>,
    { data: BodyType<MFATrustBody> }
  > = props => {
    const { data } = props ?? {};

    return postBrowserAuth2faTrust(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostBrowserAuth2faTrustMutationResult = NonNullable<
  Awaited<ReturnType<typeof postBrowserAuth2faTrust>>
>;
export type PostBrowserAuth2faTrustMutationBody = BodyType<MFATrustBody>;
export type PostBrowserAuth2faTrustMutationError = ErrorType<ErrorResponse>;

/**
 * @summary Trust this browser
 */
export const usePostBrowserAuth2faTrust = <TError = ErrorType<ErrorResponse>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postBrowserAuth2faTrust>>,
      TError,
      { data: BodyType<MFATrustBody> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof postBrowserAuth2faTrust>>,
  TError,
  { data: BodyType<MFATrustBody> },
  TContext
> => {
  const mutationOptions = getPostBrowserAuth2faTrustMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Returns the WebAuthn credential request options, that can be
processed using `parseRequestOptionsFromJSON()` on the frontend.

 * @summary Get WebAuthn credential request options for 2FA
 */
export const getAuthWebauthnAuthenticate = (
  client: 'app' | 'browser',
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<WebAuthnRequestOptionsResponseResponse>(
    { url: `/api/_allauth/${client}/v1/auth/webauthn/authenticate`, method: 'GET', signal },
    options,
  );
};

export const getGetAuthWebauthnAuthenticateQueryKey = (client?: 'app' | 'browser') => {
  return [`/api/_allauth/${client}/v1/auth/webauthn/authenticate`] as const;
};

export const getGetAuthWebauthnAuthenticateQueryOptions = <
  TData = Awaited<ReturnType<typeof getAuthWebauthnAuthenticate>>,
  TError = ErrorType<unknown>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAuthWebauthnAuthenticate>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAuthWebauthnAuthenticateQueryKey(client);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAuthWebauthnAuthenticate>>> = ({
    signal,
  }) => getAuthWebauthnAuthenticate(client, requestOptions, signal);

  return { queryKey, queryFn, enabled: !!client, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getAuthWebauthnAuthenticate>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetAuthWebauthnAuthenticateQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAuthWebauthnAuthenticate>>
>;
export type GetAuthWebauthnAuthenticateQueryError = ErrorType<unknown>;

export function useGetAuthWebauthnAuthenticate<
  TData = Awaited<ReturnType<typeof getAuthWebauthnAuthenticate>>,
  TError = ErrorType<unknown>,
>(
  client: 'app' | 'browser',
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAuthWebauthnAuthenticate>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAuthWebauthnAuthenticate>>,
          TError,
          Awaited<ReturnType<typeof getAuthWebauthnAuthenticate>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAuthWebauthnAuthenticate<
  TData = Awaited<ReturnType<typeof getAuthWebauthnAuthenticate>>,
  TError = ErrorType<unknown>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAuthWebauthnAuthenticate>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAuthWebauthnAuthenticate>>,
          TError,
          Awaited<ReturnType<typeof getAuthWebauthnAuthenticate>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAuthWebauthnAuthenticate<
  TData = Awaited<ReturnType<typeof getAuthWebauthnAuthenticate>>,
  TError = ErrorType<unknown>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAuthWebauthnAuthenticate>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get WebAuthn credential request options for 2FA
 */

export function useGetAuthWebauthnAuthenticate<
  TData = Awaited<ReturnType<typeof getAuthWebauthnAuthenticate>>,
  TError = ErrorType<unknown>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAuthWebauthnAuthenticate>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetAuthWebauthnAuthenticateQueryOptions(client, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Perform Two-Factor Authentication using a WebAuthn credential.

 * @summary Perform 2FA using WebAuthn
 */
export const postAuthWebauthnAuthenticate = (
  client: 'app' | 'browser',
  authenticateWebAuthnBody: BodyType<AuthenticateWebAuthnBody>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<AuthenticatedResponse>(
    {
      url: `/api/_allauth/${client}/v1/auth/webauthn/authenticate`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: authenticateWebAuthnBody,
      signal,
    },
    options,
  );
};

export const getPostAuthWebauthnAuthenticateMutationOptions = <
  TError = ErrorType<ErrorResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postAuthWebauthnAuthenticate>>,
    TError,
    { client: 'app' | 'browser'; data: BodyType<AuthenticateWebAuthnBody> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postAuthWebauthnAuthenticate>>,
  TError,
  { client: 'app' | 'browser'; data: BodyType<AuthenticateWebAuthnBody> },
  TContext
> => {
  const mutationKey = ['postAuthWebauthnAuthenticate'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postAuthWebauthnAuthenticate>>,
    { client: 'app' | 'browser'; data: BodyType<AuthenticateWebAuthnBody> }
  > = props => {
    const { client, data } = props ?? {};

    return postAuthWebauthnAuthenticate(client, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostAuthWebauthnAuthenticateMutationResult = NonNullable<
  Awaited<ReturnType<typeof postAuthWebauthnAuthenticate>>
>;
export type PostAuthWebauthnAuthenticateMutationBody = BodyType<AuthenticateWebAuthnBody>;
export type PostAuthWebauthnAuthenticateMutationError = ErrorType<ErrorResponse>;

/**
 * @summary Perform 2FA using WebAuthn
 */
export const usePostAuthWebauthnAuthenticate = <
  TError = ErrorType<ErrorResponse>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postAuthWebauthnAuthenticate>>,
      TError,
      { client: 'app' | 'browser'; data: BodyType<AuthenticateWebAuthnBody> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof postAuthWebauthnAuthenticate>>,
  TError,
  { client: 'app' | 'browser'; data: BodyType<AuthenticateWebAuthnBody> },
  TContext
> => {
  const mutationOptions = getPostAuthWebauthnAuthenticateMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Returns the WebAuthn credential request options, that can be
processed using `parseRequestOptionsFromJSON()` on the frontend.

 * @summary Get WebAuthn credential request options for reauthentication
 */
export const getAuthWebauthnReauthenticate = (
  client: 'app' | 'browser',
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<WebAuthnRequestOptionsResponseResponse>(
    { url: `/api/_allauth/${client}/v1/auth/webauthn/reauthenticate`, method: 'GET', signal },
    options,
  );
};

export const getGetAuthWebauthnReauthenticateQueryKey = (client?: 'app' | 'browser') => {
  return [`/api/_allauth/${client}/v1/auth/webauthn/reauthenticate`] as const;
};

export const getGetAuthWebauthnReauthenticateQueryOptions = <
  TData = Awaited<ReturnType<typeof getAuthWebauthnReauthenticate>>,
  TError = ErrorType<unknown>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAuthWebauthnReauthenticate>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAuthWebauthnReauthenticateQueryKey(client);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAuthWebauthnReauthenticate>>> = ({
    signal,
  }) => getAuthWebauthnReauthenticate(client, requestOptions, signal);

  return { queryKey, queryFn, enabled: !!client, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getAuthWebauthnReauthenticate>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetAuthWebauthnReauthenticateQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAuthWebauthnReauthenticate>>
>;
export type GetAuthWebauthnReauthenticateQueryError = ErrorType<unknown>;

export function useGetAuthWebauthnReauthenticate<
  TData = Awaited<ReturnType<typeof getAuthWebauthnReauthenticate>>,
  TError = ErrorType<unknown>,
>(
  client: 'app' | 'browser',
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAuthWebauthnReauthenticate>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAuthWebauthnReauthenticate>>,
          TError,
          Awaited<ReturnType<typeof getAuthWebauthnReauthenticate>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAuthWebauthnReauthenticate<
  TData = Awaited<ReturnType<typeof getAuthWebauthnReauthenticate>>,
  TError = ErrorType<unknown>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAuthWebauthnReauthenticate>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAuthWebauthnReauthenticate>>,
          TError,
          Awaited<ReturnType<typeof getAuthWebauthnReauthenticate>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAuthWebauthnReauthenticate<
  TData = Awaited<ReturnType<typeof getAuthWebauthnReauthenticate>>,
  TError = ErrorType<unknown>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAuthWebauthnReauthenticate>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get WebAuthn credential request options for reauthentication
 */

export function useGetAuthWebauthnReauthenticate<
  TData = Awaited<ReturnType<typeof getAuthWebauthnReauthenticate>>,
  TError = ErrorType<unknown>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAuthWebauthnReauthenticate>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetAuthWebauthnReauthenticateQueryOptions(client, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Reauthenticate the user using a WebAuthn credential.

 * @summary Reauthenticate using WebAuthn
 */
export const postAuthWebauthnReauthenticate = (
  client: 'app' | 'browser',
  reauthenticateWebAuthnBody: BodyType<ReauthenticateWebAuthnBody>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<AuthenticatedResponse>(
    {
      url: `/api/_allauth/${client}/v1/auth/webauthn/reauthenticate`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: reauthenticateWebAuthnBody,
      signal,
    },
    options,
  );
};

export const getPostAuthWebauthnReauthenticateMutationOptions = <
  TError = ErrorType<ErrorResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postAuthWebauthnReauthenticate>>,
    TError,
    { client: 'app' | 'browser'; data: BodyType<ReauthenticateWebAuthnBody> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postAuthWebauthnReauthenticate>>,
  TError,
  { client: 'app' | 'browser'; data: BodyType<ReauthenticateWebAuthnBody> },
  TContext
> => {
  const mutationKey = ['postAuthWebauthnReauthenticate'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postAuthWebauthnReauthenticate>>,
    { client: 'app' | 'browser'; data: BodyType<ReauthenticateWebAuthnBody> }
  > = props => {
    const { client, data } = props ?? {};

    return postAuthWebauthnReauthenticate(client, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostAuthWebauthnReauthenticateMutationResult = NonNullable<
  Awaited<ReturnType<typeof postAuthWebauthnReauthenticate>>
>;
export type PostAuthWebauthnReauthenticateMutationBody = BodyType<ReauthenticateWebAuthnBody>;
export type PostAuthWebauthnReauthenticateMutationError = ErrorType<ErrorResponse>;

/**
 * @summary Reauthenticate using WebAuthn
 */
export const usePostAuthWebauthnReauthenticate = <
  TError = ErrorType<ErrorResponse>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postAuthWebauthnReauthenticate>>,
      TError,
      { client: 'app' | 'browser'; data: BodyType<ReauthenticateWebAuthnBody> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof postAuthWebauthnReauthenticate>>,
  TError,
  { client: 'app' | 'browser'; data: BodyType<ReauthenticateWebAuthnBody> },
  TContext
> => {
  const mutationOptions = getPostAuthWebauthnReauthenticateMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Returns the WebAuthn credential request options, that can be
processed using `parseRequestOptionsFromJSON()` on the frontend.

 * @summary Get WebAuthn credential request options for login
 */
export const getAuthWebauthnLogin = (
  client: 'app' | 'browser',
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<WebAuthnRequestOptionsResponseResponse>(
    { url: `/api/_allauth/${client}/v1/auth/webauthn/login`, method: 'GET', signal },
    options,
  );
};

export const getGetAuthWebauthnLoginQueryKey = (client?: 'app' | 'browser') => {
  return [`/api/_allauth/${client}/v1/auth/webauthn/login`] as const;
};

export const getGetAuthWebauthnLoginQueryOptions = <
  TData = Awaited<ReturnType<typeof getAuthWebauthnLogin>>,
  TError = ErrorType<unknown>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAuthWebauthnLogin>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAuthWebauthnLoginQueryKey(client);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAuthWebauthnLogin>>> = ({ signal }) =>
    getAuthWebauthnLogin(client, requestOptions, signal);

  return { queryKey, queryFn, enabled: !!client, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getAuthWebauthnLogin>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetAuthWebauthnLoginQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAuthWebauthnLogin>>
>;
export type GetAuthWebauthnLoginQueryError = ErrorType<unknown>;

export function useGetAuthWebauthnLogin<
  TData = Awaited<ReturnType<typeof getAuthWebauthnLogin>>,
  TError = ErrorType<unknown>,
>(
  client: 'app' | 'browser',
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAuthWebauthnLogin>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAuthWebauthnLogin>>,
          TError,
          Awaited<ReturnType<typeof getAuthWebauthnLogin>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAuthWebauthnLogin<
  TData = Awaited<ReturnType<typeof getAuthWebauthnLogin>>,
  TError = ErrorType<unknown>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAuthWebauthnLogin>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAuthWebauthnLogin>>,
          TError,
          Awaited<ReturnType<typeof getAuthWebauthnLogin>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAuthWebauthnLogin<
  TData = Awaited<ReturnType<typeof getAuthWebauthnLogin>>,
  TError = ErrorType<unknown>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAuthWebauthnLogin>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get WebAuthn credential request options for login
 */

export function useGetAuthWebauthnLogin<
  TData = Awaited<ReturnType<typeof getAuthWebauthnLogin>>,
  TError = ErrorType<unknown>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAuthWebauthnLogin>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetAuthWebauthnLoginQueryOptions(client, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Login using a WebAuthn credential (Passkey). Both 200 and 401 can be
expected after a successful request.  The 401 can, for example, occur
when the credential passed was valid, but the email attached to the
account still requires verification.

 * @summary Login using WebAuthn
 */
export const postAuthWebauthnLogin = (
  client: 'app' | 'browser',
  loginWebAuthnBody: BodyType<LoginWebAuthnBody>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<AuthenticatedResponse>(
    {
      url: `/api/_allauth/${client}/v1/auth/webauthn/login`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: loginWebAuthnBody,
      signal,
    },
    options,
  );
};

export const getPostAuthWebauthnLoginMutationOptions = <
  TError = ErrorType<ErrorResponse | AuthenticationResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postAuthWebauthnLogin>>,
    TError,
    { client: 'app' | 'browser'; data: BodyType<LoginWebAuthnBody> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postAuthWebauthnLogin>>,
  TError,
  { client: 'app' | 'browser'; data: BodyType<LoginWebAuthnBody> },
  TContext
> => {
  const mutationKey = ['postAuthWebauthnLogin'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postAuthWebauthnLogin>>,
    { client: 'app' | 'browser'; data: BodyType<LoginWebAuthnBody> }
  > = props => {
    const { client, data } = props ?? {};

    return postAuthWebauthnLogin(client, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostAuthWebauthnLoginMutationResult = NonNullable<
  Awaited<ReturnType<typeof postAuthWebauthnLogin>>
>;
export type PostAuthWebauthnLoginMutationBody = BodyType<LoginWebAuthnBody>;
export type PostAuthWebauthnLoginMutationError = ErrorType<ErrorResponse | AuthenticationResponse>;

/**
 * @summary Login using WebAuthn
 */
export const usePostAuthWebauthnLogin = <
  TError = ErrorType<ErrorResponse | AuthenticationResponse>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postAuthWebauthnLogin>>,
      TError,
      { client: 'app' | 'browser'; data: BodyType<LoginWebAuthnBody> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof postAuthWebauthnLogin>>,
  TError,
  { client: 'app' | 'browser'; data: BodyType<LoginWebAuthnBody> },
  TContext
> => {
  const mutationOptions = getPostAuthWebauthnLoginMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * You initiate the passkey signup flow by inputting (`POST`) the required properties (e.g. email)
similar to the regular account signup, except that the `password` is to be left out.
The user will then be required to verify the email address, after which WebAuthn credential
creation options can be retrieved (`GET`) and used to actually complete (`PUT`) the flow.

 * @summary Initiate the passkey signup flow
 */
export const postAuthWebauthnSignup = (
  client: 'app' | 'browser',
  passkeySignupBody: BodyType<PasskeySignupBody>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<unknown>(
    {
      url: `/api/_allauth/${client}/v1/auth/webauthn/signup`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: passkeySignupBody,
      signal,
    },
    options,
  );
};

export const getPostAuthWebauthnSignupMutationOptions = <
  TError = ErrorType<ErrorResponse | AuthenticationResponse | ForbiddenResponse | ConflictResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postAuthWebauthnSignup>>,
    TError,
    { client: 'app' | 'browser'; data: BodyType<PasskeySignupBody> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postAuthWebauthnSignup>>,
  TError,
  { client: 'app' | 'browser'; data: BodyType<PasskeySignupBody> },
  TContext
> => {
  const mutationKey = ['postAuthWebauthnSignup'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postAuthWebauthnSignup>>,
    { client: 'app' | 'browser'; data: BodyType<PasskeySignupBody> }
  > = props => {
    const { client, data } = props ?? {};

    return postAuthWebauthnSignup(client, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostAuthWebauthnSignupMutationResult = NonNullable<
  Awaited<ReturnType<typeof postAuthWebauthnSignup>>
>;
export type PostAuthWebauthnSignupMutationBody = BodyType<PasskeySignupBody>;
export type PostAuthWebauthnSignupMutationError = ErrorType<
  ErrorResponse | AuthenticationResponse | ForbiddenResponse | ConflictResponse
>;

/**
 * @summary Initiate the passkey signup flow
 */
export const usePostAuthWebauthnSignup = <
  TError = ErrorType<ErrorResponse | AuthenticationResponse | ForbiddenResponse | ConflictResponse>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postAuthWebauthnSignup>>,
      TError,
      { client: 'app' | 'browser'; data: BodyType<PasskeySignupBody> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof postAuthWebauthnSignup>>,
  TError,
  { client: 'app' | 'browser'; data: BodyType<PasskeySignupBody> },
  TContext
> => {
  const mutationOptions = getPostAuthWebauthnSignupMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Returns the WebAuthn credential request options, that can be
processed using `parseRequestOptionsFromJSON()` on the frontend.

 * @summary Get passkey credential request options
 */
export const getAuthWebauthnSignup = (
  client: 'app' | 'browser',
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<WebAuthnRequestOptionsResponseResponse>(
    { url: `/api/_allauth/${client}/v1/auth/webauthn/signup`, method: 'GET', signal },
    options,
  );
};

export const getGetAuthWebauthnSignupQueryKey = (client?: 'app' | 'browser') => {
  return [`/api/_allauth/${client}/v1/auth/webauthn/signup`] as const;
};

export const getGetAuthWebauthnSignupQueryOptions = <
  TData = Awaited<ReturnType<typeof getAuthWebauthnSignup>>,
  TError = ErrorType<ConflictResponse>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAuthWebauthnSignup>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAuthWebauthnSignupQueryKey(client);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAuthWebauthnSignup>>> = ({ signal }) =>
    getAuthWebauthnSignup(client, requestOptions, signal);

  return { queryKey, queryFn, enabled: !!client, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getAuthWebauthnSignup>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetAuthWebauthnSignupQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAuthWebauthnSignup>>
>;
export type GetAuthWebauthnSignupQueryError = ErrorType<ConflictResponse>;

export function useGetAuthWebauthnSignup<
  TData = Awaited<ReturnType<typeof getAuthWebauthnSignup>>,
  TError = ErrorType<ConflictResponse>,
>(
  client: 'app' | 'browser',
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAuthWebauthnSignup>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAuthWebauthnSignup>>,
          TError,
          Awaited<ReturnType<typeof getAuthWebauthnSignup>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAuthWebauthnSignup<
  TData = Awaited<ReturnType<typeof getAuthWebauthnSignup>>,
  TError = ErrorType<ConflictResponse>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAuthWebauthnSignup>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAuthWebauthnSignup>>,
          TError,
          Awaited<ReturnType<typeof getAuthWebauthnSignup>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAuthWebauthnSignup<
  TData = Awaited<ReturnType<typeof getAuthWebauthnSignup>>,
  TError = ErrorType<ConflictResponse>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAuthWebauthnSignup>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get passkey credential request options
 */

export function useGetAuthWebauthnSignup<
  TData = Awaited<ReturnType<typeof getAuthWebauthnSignup>>,
  TError = ErrorType<ConflictResponse>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAuthWebauthnSignup>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetAuthWebauthnSignupQueryOptions(client, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Complete the passkey signup flow by handing over the WebAuthn credential.

 * @summary Complete the passkey signup flow
 */
export const putAuthWebauthnSignup = (
  client: 'app' | 'browser',
  addWebAuthnAuthenticatorBody: BodyType<AddWebAuthnAuthenticatorBody>,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<AuthenticatedResponse>(
    {
      url: `/api/_allauth/${client}/v1/auth/webauthn/signup`,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      data: addWebAuthnAuthenticatorBody,
    },
    options,
  );
};

export const getPutAuthWebauthnSignupMutationOptions = <
  TError = ErrorType<ErrorResponse | AuthenticationResponse | ConflictResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof putAuthWebauthnSignup>>,
    TError,
    { client: 'app' | 'browser'; data: BodyType<AddWebAuthnAuthenticatorBody> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof putAuthWebauthnSignup>>,
  TError,
  { client: 'app' | 'browser'; data: BodyType<AddWebAuthnAuthenticatorBody> },
  TContext
> => {
  const mutationKey = ['putAuthWebauthnSignup'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof putAuthWebauthnSignup>>,
    { client: 'app' | 'browser'; data: BodyType<AddWebAuthnAuthenticatorBody> }
  > = props => {
    const { client, data } = props ?? {};

    return putAuthWebauthnSignup(client, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PutAuthWebauthnSignupMutationResult = NonNullable<
  Awaited<ReturnType<typeof putAuthWebauthnSignup>>
>;
export type PutAuthWebauthnSignupMutationBody = BodyType<AddWebAuthnAuthenticatorBody>;
export type PutAuthWebauthnSignupMutationError = ErrorType<
  ErrorResponse | AuthenticationResponse | ConflictResponse
>;

/**
 * @summary Complete the passkey signup flow
 */
export const usePutAuthWebauthnSignup = <
  TError = ErrorType<ErrorResponse | AuthenticationResponse | ConflictResponse>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof putAuthWebauthnSignup>>,
      TError,
      { client: 'app' | 'browser'; data: BodyType<AddWebAuthnAuthenticatorBody> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof putAuthWebauthnSignup>>,
  TError,
  { client: 'app' | 'browser'; data: BodyType<AddWebAuthnAuthenticatorBody> },
  TContext
> => {
  const mutationOptions = getPutAuthWebauthnSignupMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Request a "special" login code that is sent to the user by email.

 * @summary Request login code
 */
export const postAuthCodeRequest = (
  client: 'app' | 'browser',
  requestLoginCodeBody: BodyType<RequestLoginCodeBody>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<unknown>(
    {
      url: `/api/_allauth/${client}/v1/auth/code/request`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: requestLoginCodeBody,
      signal,
    },
    options,
  );
};

export const getPostAuthCodeRequestMutationOptions = <
  TError = ErrorType<ErrorResponse | AuthenticationResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postAuthCodeRequest>>,
    TError,
    { client: 'app' | 'browser'; data: BodyType<RequestLoginCodeBody> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postAuthCodeRequest>>,
  TError,
  { client: 'app' | 'browser'; data: BodyType<RequestLoginCodeBody> },
  TContext
> => {
  const mutationKey = ['postAuthCodeRequest'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postAuthCodeRequest>>,
    { client: 'app' | 'browser'; data: BodyType<RequestLoginCodeBody> }
  > = props => {
    const { client, data } = props ?? {};

    return postAuthCodeRequest(client, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostAuthCodeRequestMutationResult = NonNullable<
  Awaited<ReturnType<typeof postAuthCodeRequest>>
>;
export type PostAuthCodeRequestMutationBody = BodyType<RequestLoginCodeBody>;
export type PostAuthCodeRequestMutationError = ErrorType<ErrorResponse | AuthenticationResponse>;

/**
 * @summary Request login code
 */
export const usePostAuthCodeRequest = <
  TError = ErrorType<ErrorResponse | AuthenticationResponse>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postAuthCodeRequest>>,
      TError,
      { client: 'app' | 'browser'; data: BodyType<RequestLoginCodeBody> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof postAuthCodeRequest>>,
  TError,
  { client: 'app' | 'browser'; data: BodyType<RequestLoginCodeBody> },
  TContext
> => {
  const mutationOptions = getPostAuthCodeRequestMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Use this endpoint to pass along the received "special" login code.

 * @summary Confirm login code
 */
export const postAuthCodeConfirm = (
  client: 'app' | 'browser',
  confirmLoginCodeBody: BodyType<ConfirmLoginCodeBody>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<AuthenticatedByCodeResponse>(
    {
      url: `/api/_allauth/${client}/v1/auth/code/confirm`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: confirmLoginCodeBody,
      signal,
    },
    options,
  );
};

export const getPostAuthCodeConfirmMutationOptions = <
  TError = ErrorType<ErrorResponse | AuthenticationResponse | ConflictResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postAuthCodeConfirm>>,
    TError,
    { client: 'app' | 'browser'; data: BodyType<ConfirmLoginCodeBody> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postAuthCodeConfirm>>,
  TError,
  { client: 'app' | 'browser'; data: BodyType<ConfirmLoginCodeBody> },
  TContext
> => {
  const mutationKey = ['postAuthCodeConfirm'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postAuthCodeConfirm>>,
    { client: 'app' | 'browser'; data: BodyType<ConfirmLoginCodeBody> }
  > = props => {
    const { client, data } = props ?? {};

    return postAuthCodeConfirm(client, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostAuthCodeConfirmMutationResult = NonNullable<
  Awaited<ReturnType<typeof postAuthCodeConfirm>>
>;
export type PostAuthCodeConfirmMutationBody = BodyType<ConfirmLoginCodeBody>;
export type PostAuthCodeConfirmMutationError = ErrorType<
  ErrorResponse | AuthenticationResponse | ConflictResponse
>;

/**
 * @summary Confirm login code
 */
export const usePostAuthCodeConfirm = <
  TError = ErrorType<ErrorResponse | AuthenticationResponse | ConflictResponse>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postAuthCodeConfirm>>,
      TError,
      { client: 'app' | 'browser'; data: BodyType<ConfirmLoginCodeBody> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof postAuthCodeConfirm>>,
  TError,
  { client: 'app' | 'browser'; data: BodyType<ConfirmLoginCodeBody> },
  TContext
> => {
  const mutationOptions = getPostAuthCodeConfirmMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary List the connected third-party provider accounts
 */
export const getAccountProviders = (
  client: 'app' | 'browser',
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<ProviderAccountsResponse>(
    { url: `/api/_allauth/${client}/v1/account/providers`, method: 'GET', signal },
    options,
  );
};

export const getGetAccountProvidersQueryKey = (client?: 'app' | 'browser') => {
  return [`/api/_allauth/${client}/v1/account/providers`] as const;
};

export const getGetAccountProvidersQueryOptions = <
  TData = Awaited<ReturnType<typeof getAccountProviders>>,
  TError = ErrorType<unknown>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAccountProviders>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAccountProvidersQueryKey(client);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAccountProviders>>> = ({ signal }) =>
    getAccountProviders(client, requestOptions, signal);

  return { queryKey, queryFn, enabled: !!client, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getAccountProviders>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetAccountProvidersQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAccountProviders>>
>;
export type GetAccountProvidersQueryError = ErrorType<unknown>;

export function useGetAccountProviders<
  TData = Awaited<ReturnType<typeof getAccountProviders>>,
  TError = ErrorType<unknown>,
>(
  client: 'app' | 'browser',
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAccountProviders>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAccountProviders>>,
          TError,
          Awaited<ReturnType<typeof getAccountProviders>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAccountProviders<
  TData = Awaited<ReturnType<typeof getAccountProviders>>,
  TError = ErrorType<unknown>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAccountProviders>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAccountProviders>>,
          TError,
          Awaited<ReturnType<typeof getAccountProviders>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAccountProviders<
  TData = Awaited<ReturnType<typeof getAccountProviders>>,
  TError = ErrorType<unknown>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAccountProviders>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary List the connected third-party provider accounts
 */

export function useGetAccountProviders<
  TData = Awaited<ReturnType<typeof getAccountProviders>>,
  TError = ErrorType<unknown>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAccountProviders>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetAccountProvidersQueryOptions(client, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Disconnect a third-party provider account, returning the remaining
accounts that are still connected. The disconnect is not allowed if it
would leave the account unusable. For example, if no password was
set up yet.

 * @summary Disconnect a third-party provider account

 */
export const deleteAccountProviders = (
  client: 'app' | 'browser',
  providerAccountBody: BodyType<ProviderAccountBody>,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<ProviderAccountsResponse>(
    {
      url: `/api/_allauth/${client}/v1/account/providers`,
      method: 'DELETE',
      headers: { 'Content-Type': 'application/json' },
      data: providerAccountBody,
    },
    options,
  );
};

export const getDeleteAccountProvidersMutationOptions = <
  TError = ErrorType<ErrorResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteAccountProviders>>,
    TError,
    { client: 'app' | 'browser'; data: BodyType<ProviderAccountBody> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteAccountProviders>>,
  TError,
  { client: 'app' | 'browser'; data: BodyType<ProviderAccountBody> },
  TContext
> => {
  const mutationKey = ['deleteAccountProviders'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteAccountProviders>>,
    { client: 'app' | 'browser'; data: BodyType<ProviderAccountBody> }
  > = props => {
    const { client, data } = props ?? {};

    return deleteAccountProviders(client, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteAccountProvidersMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteAccountProviders>>
>;
export type DeleteAccountProvidersMutationBody = BodyType<ProviderAccountBody>;
export type DeleteAccountProvidersMutationError = ErrorType<ErrorResponse>;

/**
 * @summary Disconnect a third-party provider account

 */
export const useDeleteAccountProviders = <TError = ErrorType<ErrorResponse>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteAccountProviders>>,
      TError,
      { client: 'app' | 'browser'; data: BodyType<ProviderAccountBody> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof deleteAccountProviders>>,
  TError,
  { client: 'app' | 'browser'; data: BodyType<ProviderAccountBody> },
  TContext
> => {
  const mutationOptions = getDeleteAccountProvidersMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Retrieves the list of email addresses of the account.

 * @summary List email addresses
 */
export const getAccountEmail = (
  client: 'app' | 'browser',
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<EmailAddressesResponse>(
    { url: `/api/_allauth/${client}/v1/account/email`, method: 'GET', signal },
    options,
  );
};

export const getGetAccountEmailQueryKey = (client?: 'app' | 'browser') => {
  return [`/api/_allauth/${client}/v1/account/email`] as const;
};

export const getGetAccountEmailQueryOptions = <
  TData = Awaited<ReturnType<typeof getAccountEmail>>,
  TError = ErrorType<AuthenticationResponse>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAccountEmail>>, TError, TData>>;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAccountEmailQueryKey(client);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAccountEmail>>> = ({ signal }) =>
    getAccountEmail(client, requestOptions, signal);

  return { queryKey, queryFn, enabled: !!client, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getAccountEmail>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetAccountEmailQueryResult = NonNullable<Awaited<ReturnType<typeof getAccountEmail>>>;
export type GetAccountEmailQueryError = ErrorType<AuthenticationResponse>;

export function useGetAccountEmail<
  TData = Awaited<ReturnType<typeof getAccountEmail>>,
  TError = ErrorType<AuthenticationResponse>,
>(
  client: 'app' | 'browser',
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAccountEmail>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAccountEmail>>,
          TError,
          Awaited<ReturnType<typeof getAccountEmail>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAccountEmail<
  TData = Awaited<ReturnType<typeof getAccountEmail>>,
  TError = ErrorType<AuthenticationResponse>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAccountEmail>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAccountEmail>>,
          TError,
          Awaited<ReturnType<typeof getAccountEmail>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAccountEmail<
  TData = Awaited<ReturnType<typeof getAccountEmail>>,
  TError = ErrorType<AuthenticationResponse>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAccountEmail>>, TError, TData>>;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary List email addresses
 */

export function useGetAccountEmail<
  TData = Awaited<ReturnType<typeof getAccountEmail>>,
  TError = ErrorType<AuthenticationResponse>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAccountEmail>>, TError, TData>>;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetAccountEmailQueryOptions(client, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * The following functionality is available:

  - Adding a new email address for an already signed in user (`ACCOUNT_CHANGE_EMAIL = False`).
  - Change to a new email address for an already signed in user   (`ACCOUNT_CHANGE_EMAIL = True`).
  - Change to a new email address during the email verification process at signup (`ACCOUNT_EMAIL_VERIFICATION_SUPPORTS_CHANGE = True`).

In all cases, an email verification mail will be sent containing a link or code that needs to be verified.

 * @summary Add/Change email address

 */
export const postAccountEmail = (
  client: 'app' | 'browser',
  emailBody: BodyType<EmailBody>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<EmailAddressesResponse>(
    {
      url: `/api/_allauth/${client}/v1/account/email`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: emailBody,
      signal,
    },
    options,
  );
};

export const getPostAccountEmailMutationOptions = <
  TError = ErrorType<ErrorResponse | AuthenticationOrReauthenticationResponse | ConflictResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postAccountEmail>>,
    TError,
    { client: 'app' | 'browser'; data: BodyType<EmailBody> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postAccountEmail>>,
  TError,
  { client: 'app' | 'browser'; data: BodyType<EmailBody> },
  TContext
> => {
  const mutationKey = ['postAccountEmail'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postAccountEmail>>,
    { client: 'app' | 'browser'; data: BodyType<EmailBody> }
  > = props => {
    const { client, data } = props ?? {};

    return postAccountEmail(client, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostAccountEmailMutationResult = NonNullable<
  Awaited<ReturnType<typeof postAccountEmail>>
>;
export type PostAccountEmailMutationBody = BodyType<EmailBody>;
export type PostAccountEmailMutationError = ErrorType<
  ErrorResponse | AuthenticationOrReauthenticationResponse | ConflictResponse
>;

/**
 * @summary Add/Change email address

 */
export const usePostAccountEmail = <
  TError = ErrorType<ErrorResponse | AuthenticationOrReauthenticationResponse | ConflictResponse>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postAccountEmail>>,
      TError,
      { client: 'app' | 'browser'; data: BodyType<EmailBody> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof postAccountEmail>>,
  TError,
  { client: 'app' | 'browser'; data: BodyType<EmailBody> },
  TContext
> => {
  const mutationOptions = getPostAccountEmailMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Requests for (another) email verification email to be sent. Note that
sending emails is rate limited, so when you send too many requests the
email will not be sent.

 * @summary Request email verification
 */
export const putAccountEmail = (
  client: 'app' | 'browser',
  emailBody: BodyType<EmailBody>,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<StatusOKResponse>(
    {
      url: `/api/_allauth/${client}/v1/account/email`,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      data: emailBody,
    },
    options,
  );
};

export const getPutAccountEmailMutationOptions = <
  TError = ErrorType<ErrorResponse | ForbiddenResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof putAccountEmail>>,
    TError,
    { client: 'app' | 'browser'; data: BodyType<EmailBody> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof putAccountEmail>>,
  TError,
  { client: 'app' | 'browser'; data: BodyType<EmailBody> },
  TContext
> => {
  const mutationKey = ['putAccountEmail'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof putAccountEmail>>,
    { client: 'app' | 'browser'; data: BodyType<EmailBody> }
  > = props => {
    const { client, data } = props ?? {};

    return putAccountEmail(client, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PutAccountEmailMutationResult = NonNullable<
  Awaited<ReturnType<typeof putAccountEmail>>
>;
export type PutAccountEmailMutationBody = BodyType<EmailBody>;
export type PutAccountEmailMutationError = ErrorType<ErrorResponse | ForbiddenResponse>;

/**
 * @summary Request email verification
 */
export const usePutAccountEmail = <
  TError = ErrorType<ErrorResponse | ForbiddenResponse>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof putAccountEmail>>,
      TError,
      { client: 'app' | 'browser'; data: BodyType<EmailBody> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof putAccountEmail>>,
  TError,
  { client: 'app' | 'browser'; data: BodyType<EmailBody> },
  TContext
> => {
  const mutationOptions = getPutAccountEmailMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Used to change primary email address to a different one. Note that only verified email addresses
can be marked as primary.

 * @summary Change primary email address
 */
export const patchAccountEmail = (
  client: 'app' | 'browser',
  markPrimaryEmailBody: BodyType<MarkPrimaryEmailBody>,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<EmailAddressesResponse>(
    {
      url: `/api/_allauth/${client}/v1/account/email`,
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      data: markPrimaryEmailBody,
    },
    options,
  );
};

export const getPatchAccountEmailMutationOptions = <
  TError = ErrorType<ErrorResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof patchAccountEmail>>,
    TError,
    { client: 'app' | 'browser'; data: BodyType<MarkPrimaryEmailBody> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof patchAccountEmail>>,
  TError,
  { client: 'app' | 'browser'; data: BodyType<MarkPrimaryEmailBody> },
  TContext
> => {
  const mutationKey = ['patchAccountEmail'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof patchAccountEmail>>,
    { client: 'app' | 'browser'; data: BodyType<MarkPrimaryEmailBody> }
  > = props => {
    const { client, data } = props ?? {};

    return patchAccountEmail(client, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PatchAccountEmailMutationResult = NonNullable<
  Awaited<ReturnType<typeof patchAccountEmail>>
>;
export type PatchAccountEmailMutationBody = BodyType<MarkPrimaryEmailBody>;
export type PatchAccountEmailMutationError = ErrorType<ErrorResponse>;

/**
 * @summary Change primary email address
 */
export const usePatchAccountEmail = <TError = ErrorType<ErrorResponse>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof patchAccountEmail>>,
      TError,
      { client: 'app' | 'browser'; data: BodyType<MarkPrimaryEmailBody> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof patchAccountEmail>>,
  TError,
  { client: 'app' | 'browser'; data: BodyType<MarkPrimaryEmailBody> },
  TContext
> => {
  const mutationOptions = getPatchAccountEmailMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Used to remove an email address.

 * @summary Remove an email address
 */
export const deleteAccountEmail = (
  client: 'app' | 'browser',
  emailBody: BodyType<EmailBody>,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<EmailAddressesResponse>(
    {
      url: `/api/_allauth/${client}/v1/account/email`,
      method: 'DELETE',
      headers: { 'Content-Type': 'application/json' },
      data: emailBody,
    },
    options,
  );
};

export const getDeleteAccountEmailMutationOptions = <
  TError = ErrorType<ErrorResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteAccountEmail>>,
    TError,
    { client: 'app' | 'browser'; data: BodyType<EmailBody> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteAccountEmail>>,
  TError,
  { client: 'app' | 'browser'; data: BodyType<EmailBody> },
  TContext
> => {
  const mutationKey = ['deleteAccountEmail'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteAccountEmail>>,
    { client: 'app' | 'browser'; data: BodyType<EmailBody> }
  > = props => {
    const { client, data } = props ?? {};

    return deleteAccountEmail(client, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteAccountEmailMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteAccountEmail>>
>;
export type DeleteAccountEmailMutationBody = BodyType<EmailBody>;
export type DeleteAccountEmailMutationError = ErrorType<ErrorResponse>;

/**
 * @summary Remove an email address
 */
export const useDeleteAccountEmail = <TError = ErrorType<ErrorResponse>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteAccountEmail>>,
      TError,
      { client: 'app' | 'browser'; data: BodyType<EmailBody> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof deleteAccountEmail>>,
  TError,
  { client: 'app' | 'browser'; data: BodyType<EmailBody> },
  TContext
> => {
  const mutationOptions = getDeleteAccountEmailMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Retrieves the phone number of the account, if any. Note that while the
endpoint returns a list of phone numbers, at most one entry is returned.

 * @summary Get the phone number
 */
export const getAccountPhone = (
  client: 'app' | 'browser',
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<PhoneNumbersResponse>(
    { url: `/api/_allauth/${client}/v1/account/phone`, method: 'GET', signal },
    options,
  );
};

export const getGetAccountPhoneQueryKey = (client?: 'app' | 'browser') => {
  return [`/api/_allauth/${client}/v1/account/phone`] as const;
};

export const getGetAccountPhoneQueryOptions = <
  TData = Awaited<ReturnType<typeof getAccountPhone>>,
  TError = ErrorType<AuthenticationResponse>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAccountPhone>>, TError, TData>>;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAccountPhoneQueryKey(client);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAccountPhone>>> = ({ signal }) =>
    getAccountPhone(client, requestOptions, signal);

  return { queryKey, queryFn, enabled: !!client, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getAccountPhone>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetAccountPhoneQueryResult = NonNullable<Awaited<ReturnType<typeof getAccountPhone>>>;
export type GetAccountPhoneQueryError = ErrorType<AuthenticationResponse>;

export function useGetAccountPhone<
  TData = Awaited<ReturnType<typeof getAccountPhone>>,
  TError = ErrorType<AuthenticationResponse>,
>(
  client: 'app' | 'browser',
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAccountPhone>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAccountPhone>>,
          TError,
          Awaited<ReturnType<typeof getAccountPhone>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAccountPhone<
  TData = Awaited<ReturnType<typeof getAccountPhone>>,
  TError = ErrorType<AuthenticationResponse>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAccountPhone>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAccountPhone>>,
          TError,
          Awaited<ReturnType<typeof getAccountPhone>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAccountPhone<
  TData = Awaited<ReturnType<typeof getAccountPhone>>,
  TError = ErrorType<AuthenticationResponse>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAccountPhone>>, TError, TData>>;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get the phone number
 */

export function useGetAccountPhone<
  TData = Awaited<ReturnType<typeof getAccountPhone>>,
  TError = ErrorType<AuthenticationResponse>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAccountPhone>>, TError, TData>>;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetAccountPhoneQueryOptions(client, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * The following functionality is available:

- Initiate the phone number change process for signed in users.
- Change to a new phone number during the phone number verification
  process at signup for unauthenticated users. Note that this requires:
  `ACCOUNT_PHONE_VERIFICATION_SUPPORTS_CHANGE = True`.

In both cases, after posting a new phone number, proceed with the phone
verification endpoint to confirm the change of the phone number by
posting the verification code.

 * @summary Change the phone number

 */
export const postAccountPhone = (
  client: 'app' | 'browser',
  phoneBody: BodyType<PhoneBody>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<PhoneNumberChangeResponse>(
    {
      url: `/api/_allauth/${client}/v1/account/phone`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: phoneBody,
      signal,
    },
    options,
  );
};

export const getPostAccountPhoneMutationOptions = <
  TError = ErrorType<ErrorResponse | AuthenticationOrReauthenticationResponse | ConflictResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postAccountPhone>>,
    TError,
    { client: 'app' | 'browser'; data: BodyType<PhoneBody> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postAccountPhone>>,
  TError,
  { client: 'app' | 'browser'; data: BodyType<PhoneBody> },
  TContext
> => {
  const mutationKey = ['postAccountPhone'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postAccountPhone>>,
    { client: 'app' | 'browser'; data: BodyType<PhoneBody> }
  > = props => {
    const { client, data } = props ?? {};

    return postAccountPhone(client, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostAccountPhoneMutationResult = NonNullable<
  Awaited<ReturnType<typeof postAccountPhone>>
>;
export type PostAccountPhoneMutationBody = BodyType<PhoneBody>;
export type PostAccountPhoneMutationError = ErrorType<
  ErrorResponse | AuthenticationOrReauthenticationResponse | ConflictResponse
>;

/**
 * @summary Change the phone number

 */
export const usePostAccountPhone = <
  TError = ErrorType<ErrorResponse | AuthenticationOrReauthenticationResponse | ConflictResponse>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postAccountPhone>>,
      TError,
      { client: 'app' | 'browser'; data: BodyType<PhoneBody> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof postAccountPhone>>,
  TError,
  { client: 'app' | 'browser'; data: BodyType<PhoneBody> },
  TContext
> => {
  const mutationOptions = getPostAccountPhoneMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary List authenticators
 */
export const getAccountAuthenticators = (
  client: 'app' | 'browser',
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<AuthenticatorsResponse>(
    { url: `/api/_allauth/${client}/v1/account/authenticators`, method: 'GET', signal },
    options,
  );
};

export const getGetAccountAuthenticatorsQueryKey = (client?: 'app' | 'browser') => {
  return [`/api/_allauth/${client}/v1/account/authenticators`] as const;
};

export const getGetAccountAuthenticatorsQueryOptions = <
  TData = Awaited<ReturnType<typeof getAccountAuthenticators>>,
  TError = ErrorType<AuthenticationResponse | SessionGoneResponse>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAccountAuthenticators>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAccountAuthenticatorsQueryKey(client);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAccountAuthenticators>>> = ({
    signal,
  }) => getAccountAuthenticators(client, requestOptions, signal);

  return { queryKey, queryFn, enabled: !!client, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getAccountAuthenticators>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetAccountAuthenticatorsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAccountAuthenticators>>
>;
export type GetAccountAuthenticatorsQueryError = ErrorType<
  AuthenticationResponse | SessionGoneResponse
>;

export function useGetAccountAuthenticators<
  TData = Awaited<ReturnType<typeof getAccountAuthenticators>>,
  TError = ErrorType<AuthenticationResponse | SessionGoneResponse>,
>(
  client: 'app' | 'browser',
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAccountAuthenticators>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAccountAuthenticators>>,
          TError,
          Awaited<ReturnType<typeof getAccountAuthenticators>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAccountAuthenticators<
  TData = Awaited<ReturnType<typeof getAccountAuthenticators>>,
  TError = ErrorType<AuthenticationResponse | SessionGoneResponse>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAccountAuthenticators>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAccountAuthenticators>>,
          TError,
          Awaited<ReturnType<typeof getAccountAuthenticators>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAccountAuthenticators<
  TData = Awaited<ReturnType<typeof getAccountAuthenticators>>,
  TError = ErrorType<AuthenticationResponse | SessionGoneResponse>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAccountAuthenticators>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary List authenticators
 */

export function useGetAccountAuthenticators<
  TData = Awaited<ReturnType<typeof getAccountAuthenticators>>,
  TError = ErrorType<AuthenticationResponse | SessionGoneResponse>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAccountAuthenticators>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetAccountAuthenticatorsQueryOptions(client, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Retrieve the information about the current TOTP authenticator, if any.

 * @summary TOTP authenticator status
 */
export const getAccountAuthenticatorsTotp = (
  client: 'app' | 'browser',
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<TOTPAuthenticatorResponse>(
    { url: `/api/_allauth/${client}/v1/account/authenticators/totp`, method: 'GET', signal },
    options,
  );
};

export const getGetAccountAuthenticatorsTotpQueryKey = (client?: 'app' | 'browser') => {
  return [`/api/_allauth/${client}/v1/account/authenticators/totp`] as const;
};

export const getGetAccountAuthenticatorsTotpQueryOptions = <
  TData = Awaited<ReturnType<typeof getAccountAuthenticatorsTotp>>,
  TError = ErrorType<TOTPAuthenticatorNotFoundResponse | AddAuthenticatorConflictResponse>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAccountAuthenticatorsTotp>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAccountAuthenticatorsTotpQueryKey(client);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAccountAuthenticatorsTotp>>> = ({
    signal,
  }) => getAccountAuthenticatorsTotp(client, requestOptions, signal);

  return { queryKey, queryFn, enabled: !!client, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getAccountAuthenticatorsTotp>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetAccountAuthenticatorsTotpQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAccountAuthenticatorsTotp>>
>;
export type GetAccountAuthenticatorsTotpQueryError = ErrorType<
  TOTPAuthenticatorNotFoundResponse | AddAuthenticatorConflictResponse
>;

export function useGetAccountAuthenticatorsTotp<
  TData = Awaited<ReturnType<typeof getAccountAuthenticatorsTotp>>,
  TError = ErrorType<TOTPAuthenticatorNotFoundResponse | AddAuthenticatorConflictResponse>,
>(
  client: 'app' | 'browser',
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAccountAuthenticatorsTotp>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAccountAuthenticatorsTotp>>,
          TError,
          Awaited<ReturnType<typeof getAccountAuthenticatorsTotp>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAccountAuthenticatorsTotp<
  TData = Awaited<ReturnType<typeof getAccountAuthenticatorsTotp>>,
  TError = ErrorType<TOTPAuthenticatorNotFoundResponse | AddAuthenticatorConflictResponse>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAccountAuthenticatorsTotp>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAccountAuthenticatorsTotp>>,
          TError,
          Awaited<ReturnType<typeof getAccountAuthenticatorsTotp>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAccountAuthenticatorsTotp<
  TData = Awaited<ReturnType<typeof getAccountAuthenticatorsTotp>>,
  TError = ErrorType<TOTPAuthenticatorNotFoundResponse | AddAuthenticatorConflictResponse>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAccountAuthenticatorsTotp>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary TOTP authenticator status
 */

export function useGetAccountAuthenticatorsTotp<
  TData = Awaited<ReturnType<typeof getAccountAuthenticatorsTotp>>,
  TError = ErrorType<TOTPAuthenticatorNotFoundResponse | AddAuthenticatorConflictResponse>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAccountAuthenticatorsTotp>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetAccountAuthenticatorsTotpQueryOptions(client, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * The code should be provided from the consuming TOTP authenticator
application which was generated using the TOTP authenticator secret
retrieved from the TOTP authenticator status endpoint.

 * @summary Activate TOTP
 */
export const postAccountAuthenticatorsTotp = (
  client: 'app' | 'browser',
  setupTOTPBody: BodyType<SetupTOTPBody>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<TOTPAuthenticatorResponse>(
    {
      url: `/api/_allauth/${client}/v1/account/authenticators/totp`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: setupTOTPBody,
      signal,
    },
    options,
  );
};

export const getPostAccountAuthenticatorsTotpMutationOptions = <
  TError = ErrorType<
    ErrorResponse | ReauthenticationRequiredResponse | AddAuthenticatorConflictResponse
  >,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postAccountAuthenticatorsTotp>>,
    TError,
    { client: 'app' | 'browser'; data: BodyType<SetupTOTPBody> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postAccountAuthenticatorsTotp>>,
  TError,
  { client: 'app' | 'browser'; data: BodyType<SetupTOTPBody> },
  TContext
> => {
  const mutationKey = ['postAccountAuthenticatorsTotp'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postAccountAuthenticatorsTotp>>,
    { client: 'app' | 'browser'; data: BodyType<SetupTOTPBody> }
  > = props => {
    const { client, data } = props ?? {};

    return postAccountAuthenticatorsTotp(client, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostAccountAuthenticatorsTotpMutationResult = NonNullable<
  Awaited<ReturnType<typeof postAccountAuthenticatorsTotp>>
>;
export type PostAccountAuthenticatorsTotpMutationBody = BodyType<SetupTOTPBody>;
export type PostAccountAuthenticatorsTotpMutationError = ErrorType<
  ErrorResponse | ReauthenticationRequiredResponse | AddAuthenticatorConflictResponse
>;

/**
 * @summary Activate TOTP
 */
export const usePostAccountAuthenticatorsTotp = <
  TError = ErrorType<
    ErrorResponse | ReauthenticationRequiredResponse | AddAuthenticatorConflictResponse
  >,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postAccountAuthenticatorsTotp>>,
      TError,
      { client: 'app' | 'browser'; data: BodyType<SetupTOTPBody> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof postAccountAuthenticatorsTotp>>,
  TError,
  { client: 'app' | 'browser'; data: BodyType<SetupTOTPBody> },
  TContext
> => {
  const mutationOptions = getPostAccountAuthenticatorsTotpMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Deactivates TOTP authentication. If the user authentication is not
sufficiently recent, a reauthentication flow (`401`) will is presented.

 * @summary Deactivate TOTP
 */
export const deleteAccountAuthenticatorsTotp = (
  client: 'app' | 'browser',
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<StatusOKResponse>(
    { url: `/api/_allauth/${client}/v1/account/authenticators/totp`, method: 'DELETE' },
    options,
  );
};

export const getDeleteAccountAuthenticatorsTotpMutationOptions = <
  TError = ErrorType<ReauthenticationRequiredResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteAccountAuthenticatorsTotp>>,
    TError,
    { client: 'app' | 'browser' },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteAccountAuthenticatorsTotp>>,
  TError,
  { client: 'app' | 'browser' },
  TContext
> => {
  const mutationKey = ['deleteAccountAuthenticatorsTotp'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteAccountAuthenticatorsTotp>>,
    { client: 'app' | 'browser' }
  > = props => {
    const { client } = props ?? {};

    return deleteAccountAuthenticatorsTotp(client, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteAccountAuthenticatorsTotpMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteAccountAuthenticatorsTotp>>
>;

export type DeleteAccountAuthenticatorsTotpMutationError =
  ErrorType<ReauthenticationRequiredResponse>;

/**
 * @summary Deactivate TOTP
 */
export const useDeleteAccountAuthenticatorsTotp = <
  TError = ErrorType<ReauthenticationRequiredResponse>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteAccountAuthenticatorsTotp>>,
      TError,
      { client: 'app' | 'browser' },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof deleteAccountAuthenticatorsTotp>>,
  TError,
  { client: 'app' | 'browser' },
  TContext
> => {
  const mutationOptions = getDeleteAccountAuthenticatorsTotpMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * List recovery codes.

 * @summary List recovery codes
 */
export const getAccountAuthenticatorsRecoveryCodes = (
  client: 'app' | 'browser',
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<RecoveryCodesResponse>(
    {
      url: `/api/_allauth/${client}/v1/account/authenticators/recovery-codes`,
      method: 'GET',
      signal,
    },
    options,
  );
};

export const getGetAccountAuthenticatorsRecoveryCodesQueryKey = (client?: 'app' | 'browser') => {
  return [`/api/_allauth/${client}/v1/account/authenticators/recovery-codes`] as const;
};

export const getGetAccountAuthenticatorsRecoveryCodesQueryOptions = <
  TData = Awaited<ReturnType<typeof getAccountAuthenticatorsRecoveryCodes>>,
  TError = ErrorType<ReauthenticationRequiredResponse | NotFoundResponse>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAccountAuthenticatorsRecoveryCodes>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetAccountAuthenticatorsRecoveryCodesQueryKey(client);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getAccountAuthenticatorsRecoveryCodes>>
  > = ({ signal }) => getAccountAuthenticatorsRecoveryCodes(client, requestOptions, signal);

  return { queryKey, queryFn, enabled: !!client, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getAccountAuthenticatorsRecoveryCodes>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetAccountAuthenticatorsRecoveryCodesQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAccountAuthenticatorsRecoveryCodes>>
>;
export type GetAccountAuthenticatorsRecoveryCodesQueryError = ErrorType<
  ReauthenticationRequiredResponse | NotFoundResponse
>;

export function useGetAccountAuthenticatorsRecoveryCodes<
  TData = Awaited<ReturnType<typeof getAccountAuthenticatorsRecoveryCodes>>,
  TError = ErrorType<ReauthenticationRequiredResponse | NotFoundResponse>,
>(
  client: 'app' | 'browser',
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAccountAuthenticatorsRecoveryCodes>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAccountAuthenticatorsRecoveryCodes>>,
          TError,
          Awaited<ReturnType<typeof getAccountAuthenticatorsRecoveryCodes>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAccountAuthenticatorsRecoveryCodes<
  TData = Awaited<ReturnType<typeof getAccountAuthenticatorsRecoveryCodes>>,
  TError = ErrorType<ReauthenticationRequiredResponse | NotFoundResponse>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAccountAuthenticatorsRecoveryCodes>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAccountAuthenticatorsRecoveryCodes>>,
          TError,
          Awaited<ReturnType<typeof getAccountAuthenticatorsRecoveryCodes>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAccountAuthenticatorsRecoveryCodes<
  TData = Awaited<ReturnType<typeof getAccountAuthenticatorsRecoveryCodes>>,
  TError = ErrorType<ReauthenticationRequiredResponse | NotFoundResponse>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAccountAuthenticatorsRecoveryCodes>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary List recovery codes
 */

export function useGetAccountAuthenticatorsRecoveryCodes<
  TData = Awaited<ReturnType<typeof getAccountAuthenticatorsRecoveryCodes>>,
  TError = ErrorType<ReauthenticationRequiredResponse | NotFoundResponse>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAccountAuthenticatorsRecoveryCodes>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetAccountAuthenticatorsRecoveryCodesQueryOptions(client, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Regenerate recovery codes
 */
export const postAccountAuthenticatorsRecoveryCodes = (
  client: 'app' | 'browser',
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<unknown>(
    {
      url: `/api/_allauth/${client}/v1/account/authenticators/recovery-codes`,
      method: 'POST',
      signal,
    },
    options,
  );
};

export const getPostAccountAuthenticatorsRecoveryCodesMutationOptions = <
  TError = ErrorType<ErrorResponse | ReauthenticationRequiredResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postAccountAuthenticatorsRecoveryCodes>>,
    TError,
    { client: 'app' | 'browser' },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postAccountAuthenticatorsRecoveryCodes>>,
  TError,
  { client: 'app' | 'browser' },
  TContext
> => {
  const mutationKey = ['postAccountAuthenticatorsRecoveryCodes'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postAccountAuthenticatorsRecoveryCodes>>,
    { client: 'app' | 'browser' }
  > = props => {
    const { client } = props ?? {};

    return postAccountAuthenticatorsRecoveryCodes(client, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostAccountAuthenticatorsRecoveryCodesMutationResult = NonNullable<
  Awaited<ReturnType<typeof postAccountAuthenticatorsRecoveryCodes>>
>;

export type PostAccountAuthenticatorsRecoveryCodesMutationError = ErrorType<
  ErrorResponse | ReauthenticationRequiredResponse
>;

/**
 * @summary Regenerate recovery codes
 */
export const usePostAccountAuthenticatorsRecoveryCodes = <
  TError = ErrorType<ErrorResponse | ReauthenticationRequiredResponse>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postAccountAuthenticatorsRecoveryCodes>>,
      TError,
      { client: 'app' | 'browser' },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof postAccountAuthenticatorsRecoveryCodes>>,
  TError,
  { client: 'app' | 'browser' },
  TContext
> => {
  const mutationOptions = getPostAccountAuthenticatorsRecoveryCodesMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Returns the WebAuthn credential creation options, that can be
processed using `parseCreationOptionsFromJSON()` on the frontend.

 * @summary Get WebAuthn credential creation options

 */
export const getAccountAuthenticatorsWebauthn = (
  client: 'app' | 'browser',
  params?: GetAccountAuthenticatorsWebauthnParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<WebAuthnCreationOptionsResponseResponse>(
    {
      url: `/api/_allauth/${client}/v1/account/authenticators/webauthn`,
      method: 'GET',
      params,
      signal,
    },
    options,
  );
};

export const getGetAccountAuthenticatorsWebauthnQueryKey = (
  client?: 'app' | 'browser',
  params?: GetAccountAuthenticatorsWebauthnParams,
) => {
  return [
    `/api/_allauth/${client}/v1/account/authenticators/webauthn`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetAccountAuthenticatorsWebauthnQueryOptions = <
  TData = Awaited<ReturnType<typeof getAccountAuthenticatorsWebauthn>>,
  TError = ErrorType<ReauthenticationRequiredResponse | AddAuthenticatorConflictResponse>,
>(
  client: 'app' | 'browser',
  params?: GetAccountAuthenticatorsWebauthnParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAccountAuthenticatorsWebauthn>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetAccountAuthenticatorsWebauthnQueryKey(client, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAccountAuthenticatorsWebauthn>>> = ({
    signal,
  }) => getAccountAuthenticatorsWebauthn(client, params, requestOptions, signal);

  return { queryKey, queryFn, enabled: !!client, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getAccountAuthenticatorsWebauthn>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetAccountAuthenticatorsWebauthnQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAccountAuthenticatorsWebauthn>>
>;
export type GetAccountAuthenticatorsWebauthnQueryError = ErrorType<
  ReauthenticationRequiredResponse | AddAuthenticatorConflictResponse
>;

export function useGetAccountAuthenticatorsWebauthn<
  TData = Awaited<ReturnType<typeof getAccountAuthenticatorsWebauthn>>,
  TError = ErrorType<ReauthenticationRequiredResponse | AddAuthenticatorConflictResponse>,
>(
  client: 'app' | 'browser',
  params: undefined | GetAccountAuthenticatorsWebauthnParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAccountAuthenticatorsWebauthn>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAccountAuthenticatorsWebauthn>>,
          TError,
          Awaited<ReturnType<typeof getAccountAuthenticatorsWebauthn>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAccountAuthenticatorsWebauthn<
  TData = Awaited<ReturnType<typeof getAccountAuthenticatorsWebauthn>>,
  TError = ErrorType<ReauthenticationRequiredResponse | AddAuthenticatorConflictResponse>,
>(
  client: 'app' | 'browser',
  params?: GetAccountAuthenticatorsWebauthnParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAccountAuthenticatorsWebauthn>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAccountAuthenticatorsWebauthn>>,
          TError,
          Awaited<ReturnType<typeof getAccountAuthenticatorsWebauthn>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAccountAuthenticatorsWebauthn<
  TData = Awaited<ReturnType<typeof getAccountAuthenticatorsWebauthn>>,
  TError = ErrorType<ReauthenticationRequiredResponse | AddAuthenticatorConflictResponse>,
>(
  client: 'app' | 'browser',
  params?: GetAccountAuthenticatorsWebauthnParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAccountAuthenticatorsWebauthn>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get WebAuthn credential creation options

 */

export function useGetAccountAuthenticatorsWebauthn<
  TData = Awaited<ReturnType<typeof getAccountAuthenticatorsWebauthn>>,
  TError = ErrorType<ReauthenticationRequiredResponse | AddAuthenticatorConflictResponse>,
>(
  client: 'app' | 'browser',
  params?: GetAccountAuthenticatorsWebauthnParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAccountAuthenticatorsWebauthn>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetAccountAuthenticatorsWebauthnQueryOptions(client, params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * You can alter the name of a WebAuthn credential by PUT'ting the ID and
name of the authenticator representing that credential. You can obtain
the credentials via the "List authenticators" endpoint.

 * @summary Rename a WebAuthn credential

 */
export const putAccountAuthenticatorsWebauthn = (
  client: 'app' | 'browser',
  updateWebAuthnBody: BodyType<UpdateWebAuthnBody>,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<WebAuthnAuthenticatorResponse>(
    {
      url: `/api/_allauth/${client}/v1/account/authenticators/webauthn`,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      data: updateWebAuthnBody,
    },
    options,
  );
};

export const getPutAccountAuthenticatorsWebauthnMutationOptions = <
  TError = ErrorType<ReauthenticationRequiredResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof putAccountAuthenticatorsWebauthn>>,
    TError,
    { client: 'app' | 'browser'; data: BodyType<UpdateWebAuthnBody> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof putAccountAuthenticatorsWebauthn>>,
  TError,
  { client: 'app' | 'browser'; data: BodyType<UpdateWebAuthnBody> },
  TContext
> => {
  const mutationKey = ['putAccountAuthenticatorsWebauthn'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof putAccountAuthenticatorsWebauthn>>,
    { client: 'app' | 'browser'; data: BodyType<UpdateWebAuthnBody> }
  > = props => {
    const { client, data } = props ?? {};

    return putAccountAuthenticatorsWebauthn(client, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PutAccountAuthenticatorsWebauthnMutationResult = NonNullable<
  Awaited<ReturnType<typeof putAccountAuthenticatorsWebauthn>>
>;
export type PutAccountAuthenticatorsWebauthnMutationBody = BodyType<UpdateWebAuthnBody>;
export type PutAccountAuthenticatorsWebauthnMutationError =
  ErrorType<ReauthenticationRequiredResponse>;

/**
 * @summary Rename a WebAuthn credential

 */
export const usePutAccountAuthenticatorsWebauthn = <
  TError = ErrorType<ReauthenticationRequiredResponse>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof putAccountAuthenticatorsWebauthn>>,
      TError,
      { client: 'app' | 'browser'; data: BodyType<UpdateWebAuthnBody> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof putAccountAuthenticatorsWebauthn>>,
  TError,
  { client: 'app' | 'browser'; data: BodyType<UpdateWebAuthnBody> },
  TContext
> => {
  const mutationOptions = getPutAccountAuthenticatorsWebauthnMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Delete a WebAuthn credential

 */
export const deleteAccountAuthenticatorsWebauthn = (
  client: 'app' | 'browser',
  deleteWebAuthnBody: BodyType<DeleteWebAuthnBody>,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<StatusOKResponse>(
    {
      url: `/api/_allauth/${client}/v1/account/authenticators/webauthn`,
      method: 'DELETE',
      headers: { 'Content-Type': 'application/json' },
      data: deleteWebAuthnBody,
    },
    options,
  );
};

export const getDeleteAccountAuthenticatorsWebauthnMutationOptions = <
  TError = ErrorType<ReauthenticationRequiredResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteAccountAuthenticatorsWebauthn>>,
    TError,
    { client: 'app' | 'browser'; data: BodyType<DeleteWebAuthnBody> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteAccountAuthenticatorsWebauthn>>,
  TError,
  { client: 'app' | 'browser'; data: BodyType<DeleteWebAuthnBody> },
  TContext
> => {
  const mutationKey = ['deleteAccountAuthenticatorsWebauthn'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteAccountAuthenticatorsWebauthn>>,
    { client: 'app' | 'browser'; data: BodyType<DeleteWebAuthnBody> }
  > = props => {
    const { client, data } = props ?? {};

    return deleteAccountAuthenticatorsWebauthn(client, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteAccountAuthenticatorsWebauthnMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteAccountAuthenticatorsWebauthn>>
>;
export type DeleteAccountAuthenticatorsWebauthnMutationBody = BodyType<DeleteWebAuthnBody>;
export type DeleteAccountAuthenticatorsWebauthnMutationError =
  ErrorType<ReauthenticationRequiredResponse>;

/**
 * @summary Delete a WebAuthn credential

 */
export const useDeleteAccountAuthenticatorsWebauthn = <
  TError = ErrorType<ReauthenticationRequiredResponse>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteAccountAuthenticatorsWebauthn>>,
      TError,
      { client: 'app' | 'browser'; data: BodyType<DeleteWebAuthnBody> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof deleteAccountAuthenticatorsWebauthn>>,
  TError,
  { client: 'app' | 'browser'; data: BodyType<DeleteWebAuthnBody> },
  TContext
> => {
  const mutationOptions = getDeleteAccountAuthenticatorsWebauthnMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Add a WebAuthn credential

 */
export const postAccountAuthenticatorsWebauthn = (
  client: 'app' | 'browser',
  addWebAuthnAuthenticatorBody: BodyType<AddWebAuthnAuthenticatorBody>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<AddWebAuthnAuthenticatorResponse>(
    {
      url: `/api/_allauth/${client}/v1/account/authenticators/webauthn`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: addWebAuthnAuthenticatorBody,
      signal,
    },
    options,
  );
};

export const getPostAccountAuthenticatorsWebauthnMutationOptions = <
  TError = ErrorType<ReauthenticationRequiredResponse | AddAuthenticatorConflictResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postAccountAuthenticatorsWebauthn>>,
    TError,
    { client: 'app' | 'browser'; data: BodyType<AddWebAuthnAuthenticatorBody> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postAccountAuthenticatorsWebauthn>>,
  TError,
  { client: 'app' | 'browser'; data: BodyType<AddWebAuthnAuthenticatorBody> },
  TContext
> => {
  const mutationKey = ['postAccountAuthenticatorsWebauthn'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postAccountAuthenticatorsWebauthn>>,
    { client: 'app' | 'browser'; data: BodyType<AddWebAuthnAuthenticatorBody> }
  > = props => {
    const { client, data } = props ?? {};

    return postAccountAuthenticatorsWebauthn(client, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostAccountAuthenticatorsWebauthnMutationResult = NonNullable<
  Awaited<ReturnType<typeof postAccountAuthenticatorsWebauthn>>
>;
export type PostAccountAuthenticatorsWebauthnMutationBody = BodyType<AddWebAuthnAuthenticatorBody>;
export type PostAccountAuthenticatorsWebauthnMutationError = ErrorType<
  ReauthenticationRequiredResponse | AddAuthenticatorConflictResponse
>;

/**
 * @summary Add a WebAuthn credential

 */
export const usePostAccountAuthenticatorsWebauthn = <
  TError = ErrorType<ReauthenticationRequiredResponse | AddAuthenticatorConflictResponse>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postAccountAuthenticatorsWebauthn>>,
      TError,
      { client: 'app' | 'browser'; data: BodyType<AddWebAuthnAuthenticatorBody> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof postAccountAuthenticatorsWebauthn>>,
  TError,
  { client: 'app' | 'browser'; data: BodyType<AddWebAuthnAuthenticatorBody> },
  TContext
> => {
  const mutationOptions = getPostAccountAuthenticatorsWebauthnMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Retrieve information about the authentication status for the current
session.

 * @summary Get authentication status

 */
export const getAuthSession = (
  client: 'app' | 'browser',
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<AuthenticatedResponse>(
    { url: `/api/_allauth/${client}/v1/auth/session`, method: 'GET', signal },
    options,
  );
};

export const getGetAuthSessionQueryKey = (client?: 'app' | 'browser') => {
  return [`/api/_allauth/${client}/v1/auth/session`] as const;
};

export const getGetAuthSessionQueryOptions = <
  TData = Awaited<ReturnType<typeof getAuthSession>>,
  TError = ErrorType<AuthenticationResponse | SessionGoneResponse>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAuthSession>>, TError, TData>>;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAuthSessionQueryKey(client);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAuthSession>>> = ({ signal }) =>
    getAuthSession(client, requestOptions, signal);

  return { queryKey, queryFn, enabled: !!client, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getAuthSession>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetAuthSessionQueryResult = NonNullable<Awaited<ReturnType<typeof getAuthSession>>>;
export type GetAuthSessionQueryError = ErrorType<AuthenticationResponse | SessionGoneResponse>;

export function useGetAuthSession<
  TData = Awaited<ReturnType<typeof getAuthSession>>,
  TError = ErrorType<AuthenticationResponse | SessionGoneResponse>,
>(
  client: 'app' | 'browser',
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAuthSession>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAuthSession>>,
          TError,
          Awaited<ReturnType<typeof getAuthSession>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAuthSession<
  TData = Awaited<ReturnType<typeof getAuthSession>>,
  TError = ErrorType<AuthenticationResponse | SessionGoneResponse>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAuthSession>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAuthSession>>,
          TError,
          Awaited<ReturnType<typeof getAuthSession>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAuthSession<
  TData = Awaited<ReturnType<typeof getAuthSession>>,
  TError = ErrorType<AuthenticationResponse | SessionGoneResponse>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAuthSession>>, TError, TData>>;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get authentication status

 */

export function useGetAuthSession<
  TData = Awaited<ReturnType<typeof getAuthSession>>,
  TError = ErrorType<AuthenticationResponse | SessionGoneResponse>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAuthSession>>, TError, TData>>;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetAuthSessionQueryOptions(client, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Logs out the user from the current session.

 * @summary Logout
 */
export const deleteAuthSession = (
  client: 'app' | 'browser',
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<unknown>(
    { url: `/api/_allauth/${client}/v1/auth/session`, method: 'DELETE' },
    options,
  );
};

export const getDeleteAuthSessionMutationOptions = <
  TError = ErrorType<UnauthenticatedResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteAuthSession>>,
    TError,
    { client: 'app' | 'browser' },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteAuthSession>>,
  TError,
  { client: 'app' | 'browser' },
  TContext
> => {
  const mutationKey = ['deleteAuthSession'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteAuthSession>>,
    { client: 'app' | 'browser' }
  > = props => {
    const { client } = props ?? {};

    return deleteAuthSession(client, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteAuthSessionMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteAuthSession>>
>;

export type DeleteAuthSessionMutationError = ErrorType<UnauthenticatedResponse>;

/**
 * @summary Logout
 */
export const useDeleteAuthSession = <
  TError = ErrorType<UnauthenticatedResponse>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteAuthSession>>,
      TError,
      { client: 'app' | 'browser' },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof deleteAuthSession>>,
  TError,
  { client: 'app' | 'browser' },
  TContext
> => {
  const mutationOptions = getDeleteAuthSessionMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Used to retrieve a new access token. Depending on `settings.HEADLESS_JWT_ROTATE_REFRESH_TOKEN`,
a new refresh token is returned as well.

 * @summary Refresh the access token

 */
export const postAppTokensRefresh = (
  refreshTokenBody: BodyType<RefreshTokenBody>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<RefreshTokenResponse>(
    {
      url: `/api/_allauth/app/v1/tokens/refresh`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: refreshTokenBody,
      signal,
    },
    options,
  );
};

export const getPostAppTokensRefreshMutationOptions = <
  TError = ErrorType<ErrorResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postAppTokensRefresh>>,
    TError,
    { data: BodyType<RefreshTokenBody> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postAppTokensRefresh>>,
  TError,
  { data: BodyType<RefreshTokenBody> },
  TContext
> => {
  const mutationKey = ['postAppTokensRefresh'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postAppTokensRefresh>>,
    { data: BodyType<RefreshTokenBody> }
  > = props => {
    const { data } = props ?? {};

    return postAppTokensRefresh(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostAppTokensRefreshMutationResult = NonNullable<
  Awaited<ReturnType<typeof postAppTokensRefresh>>
>;
export type PostAppTokensRefreshMutationBody = BodyType<RefreshTokenBody>;
export type PostAppTokensRefreshMutationError = ErrorType<ErrorResponse>;

/**
 * @summary Refresh the access token

 */
export const usePostAppTokensRefresh = <TError = ErrorType<ErrorResponse>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postAppTokensRefresh>>,
      TError,
      { data: BodyType<RefreshTokenBody> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof postAppTokensRefresh>>,
  TError,
  { data: BodyType<RefreshTokenBody> },
  TContext
> => {
  const mutationOptions = getPostAppTokensRefreshMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * In order to change the password of an account, the current and new
password must be provider.  However, accounts that were created by
signing up using a third-party provider do not have a password set. In
that case, the current password is not required.

 * @summary Change password
 */
export const postAccountPasswordChange = (
  client: 'app' | 'browser',
  changePasswordBody: BodyType<ChangePasswordBody>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<unknown>(
    {
      url: `/api/_allauth/${client}/v1/account/password/change`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: changePasswordBody,
      signal,
    },
    options,
  );
};

export const getPostAccountPasswordChangeMutationOptions = <
  TError = ErrorType<ErrorResponse | AuthenticationResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postAccountPasswordChange>>,
    TError,
    { client: 'app' | 'browser'; data: BodyType<ChangePasswordBody> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postAccountPasswordChange>>,
  TError,
  { client: 'app' | 'browser'; data: BodyType<ChangePasswordBody> },
  TContext
> => {
  const mutationKey = ['postAccountPasswordChange'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postAccountPasswordChange>>,
    { client: 'app' | 'browser'; data: BodyType<ChangePasswordBody> }
  > = props => {
    const { client, data } = props ?? {};

    return postAccountPasswordChange(client, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostAccountPasswordChangeMutationResult = NonNullable<
  Awaited<ReturnType<typeof postAccountPasswordChange>>
>;
export type PostAccountPasswordChangeMutationBody = BodyType<ChangePasswordBody>;
export type PostAccountPasswordChangeMutationError = ErrorType<
  ErrorResponse | AuthenticationResponse
>;

/**
 * @summary Change password
 */
export const usePostAccountPasswordChange = <
  TError = ErrorType<ErrorResponse | AuthenticationResponse>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postAccountPasswordChange>>,
      TError,
      { client: 'app' | 'browser'; data: BodyType<ChangePasswordBody> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof postAccountPasswordChange>>,
  TError,
  { client: 'app' | 'browser'; data: BodyType<ChangePasswordBody> },
  TContext
> => {
  const mutationOptions = getPostAccountPasswordChangeMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary List sessions
 */
export const getAuthSessions = (
  client: 'app' | 'browser',
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<SessionsResponse>(
    { url: `/api/_allauth/${client}/v1/auth/sessions`, method: 'GET', signal },
    options,
  );
};

export const getGetAuthSessionsQueryKey = (client?: 'app' | 'browser') => {
  return [`/api/_allauth/${client}/v1/auth/sessions`] as const;
};

export const getGetAuthSessionsQueryOptions = <
  TData = Awaited<ReturnType<typeof getAuthSessions>>,
  TError = ErrorType<unknown>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAuthSessions>>, TError, TData>>;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAuthSessionsQueryKey(client);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAuthSessions>>> = ({ signal }) =>
    getAuthSessions(client, requestOptions, signal);

  return { queryKey, queryFn, enabled: !!client, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getAuthSessions>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetAuthSessionsQueryResult = NonNullable<Awaited<ReturnType<typeof getAuthSessions>>>;
export type GetAuthSessionsQueryError = ErrorType<unknown>;

export function useGetAuthSessions<
  TData = Awaited<ReturnType<typeof getAuthSessions>>,
  TError = ErrorType<unknown>,
>(
  client: 'app' | 'browser',
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAuthSessions>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAuthSessions>>,
          TError,
          Awaited<ReturnType<typeof getAuthSessions>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAuthSessions<
  TData = Awaited<ReturnType<typeof getAuthSessions>>,
  TError = ErrorType<unknown>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAuthSessions>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAuthSessions>>,
          TError,
          Awaited<ReturnType<typeof getAuthSessions>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAuthSessions<
  TData = Awaited<ReturnType<typeof getAuthSessions>>,
  TError = ErrorType<unknown>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAuthSessions>>, TError, TData>>;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary List sessions
 */

export function useGetAuthSessions<
  TData = Awaited<ReturnType<typeof getAuthSessions>>,
  TError = ErrorType<unknown>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAuthSessions>>, TError, TData>>;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetAuthSessionsQueryOptions(client, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary End one or more sessions
 */
export const deleteAuthSessions = (
  client: 'app' | 'browser',
  endSessionsBody: BodyType<EndSessionsBody>,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<SessionsResponse>(
    {
      url: `/api/_allauth/${client}/v1/auth/sessions`,
      method: 'DELETE',
      headers: { 'Content-Type': 'application/json' },
      data: endSessionsBody,
    },
    options,
  );
};

export const getDeleteAuthSessionsMutationOptions = <
  TError = ErrorType<AuthenticationResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteAuthSessions>>,
    TError,
    { client: 'app' | 'browser'; data: BodyType<EndSessionsBody> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteAuthSessions>>,
  TError,
  { client: 'app' | 'browser'; data: BodyType<EndSessionsBody> },
  TContext
> => {
  const mutationKey = ['deleteAuthSessions'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteAuthSessions>>,
    { client: 'app' | 'browser'; data: BodyType<EndSessionsBody> }
  > = props => {
    const { client, data } = props ?? {};

    return deleteAuthSessions(client, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteAuthSessionsMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteAuthSessions>>
>;
export type DeleteAuthSessionsMutationBody = BodyType<EndSessionsBody>;
export type DeleteAuthSessionsMutationError = ErrorType<AuthenticationResponse>;

/**
 * @summary End one or more sessions
 */
export const useDeleteAuthSessions = <
  TError = ErrorType<AuthenticationResponse>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteAuthSessions>>,
      TError,
      { client: 'app' | 'browser'; data: BodyType<EndSessionsBody> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof deleteAuthSessions>>,
  TError,
  { client: 'app' | 'browser'; data: BodyType<EndSessionsBody> },
  TContext
> => {
  const mutationOptions = getDeleteAuthSessionsMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
