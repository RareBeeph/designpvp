/**
 * Generated by orval v7.19.0 üç∫
 * Do not edit manually.
 * django-allauth: Headless API
 * $ref: "./description.md"

 * OpenAPI spec version: 1
 */
import { useMutation, useQuery } from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query';

import { customInstance } from './mutator/custom-instance';
import type { BodyType, ErrorType } from './mutator/custom-instance';

export interface Session {
  user_agent: string;
  ip: string;
  created_at: Timestamp;
  is_current: boolean;
  id: number;
  last_seen_at?: Timestamp;
}

export type AccountConfigurationLoginMethodsItem =
  (typeof AccountConfigurationLoginMethodsItem)[keyof typeof AccountConfigurationLoginMethodsItem];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AccountConfigurationLoginMethodsItem = {
  email: 'email',
  username: 'username',
} as const;

/**
 * Configuration of the Django `allauth.account` app.

 */
export interface AccountConfiguration {
  login_methods?: AccountConfigurationLoginMethodsItem[];
  is_open_for_signup: boolean;
  email_verification_by_code_enabled: boolean;
  login_by_code_enabled: boolean;
  password_reset_by_code_enabled?: boolean;
}

export type AuthenticationResponseStatus =
  (typeof AuthenticationResponseStatus)[keyof typeof AuthenticationResponseStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AuthenticationResponseStatus = {
  number401: 401,
} as const;

export type AuthenticationResponseData = {
  flows: Flow[];
};

/**
 * An authentication related response.

 */
export interface AuthenticationResponse {
  status: AuthenticationResponseStatus;
  data: AuthenticationResponseData;
  meta: AuthenticationMeta;
}

export type ForbiddenResponseStatus =
  (typeof ForbiddenResponseStatus)[keyof typeof ForbiddenResponseStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ForbiddenResponseStatus = {
  number403: 403,
} as const;

export interface ForbiddenResponse {
  status: ForbiddenResponseStatus;
}

export type ConflictResponseStatus =
  (typeof ConflictResponseStatus)[keyof typeof ConflictResponseStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ConflictResponseStatus = {
  number409: 409,
} as const;

export interface ConflictResponse {
  status: ConflictResponseStatus;
}

export interface EndSessions {
  /** The IDs of the sessions that are to be ended.
   */
  sessions: number[];
}

/**
 * A phone number.

 */
export interface PhoneNumber {
  phone: string;
  verified: boolean;
}

export interface PhoneNumbersResponse {
  status: StatusOK;
  data: PhoneNumber[];
}

export interface PhoneNumberChangeResponse {
  status: StatusAccepted;
  data: PhoneNumber[];
}

export type ReauthenticationResponseStatus =
  (typeof ReauthenticationResponseStatus)[keyof typeof ReauthenticationResponseStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ReauthenticationResponseStatus = {
  number401: 401,
} as const;

/**
 * A response indicating reauthentication is required.

 */
export interface ReauthenticationResponse {
  status: ReauthenticationResponseStatus;
  data: ReauthenticationRequired;
  meta: AuthenticatedMeta;
}

export type SessionGoneResponseStatus =
  (typeof SessionGoneResponseStatus)[keyof typeof SessionGoneResponseStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SessionGoneResponseStatus = {
  number410: 410,
} as const;

export type SessionGoneResponseData = { [key: string]: unknown };

/**
 * The session is expired or invalid.

 */
export interface SessionGoneResponse {
  status: SessionGoneResponseStatus;
  data: SessionGoneResponseData;
  meta: AuthenticationMeta;
}

export interface BaseAuthenticationMeta {
  /** The session token (`app` clients only).
   */
  session_token?: string;
  /** The access token (`app` clients only).
   */
  access_token?: string;
}

/**
 * Metadata available in an authentication related response.

 */
export type AuthenticationMetaAllOf = {
  is_authenticated: boolean;
};

export type AuthenticationMeta = BaseAuthenticationMeta & AuthenticationMetaAllOf;

/**
 * Metadata available in an re-authentication related response.

 */
export type AuthenticatedMetaAllOf = {
  is_authenticated: boolean;
};

export type AuthenticatedMeta = BaseAuthenticationMeta & AuthenticatedMetaAllOf;

export type FlowId = (typeof FlowId)[keyof typeof FlowId];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const FlowId = {
  login: 'login',
  loginByCode: 'login_by_code',
  mfaAuthenticate: 'mfa_authenticate',
  mfaReauthenticate: 'mfa_reauthenticate',
  providerRedirect: 'provider_redirect',
  providerSignup: 'provider_signup',
  providerToken: 'provider_token',
  reauthenticate: 'reauthenticate',
  signup: 'signup',
  verifyEmail: 'verify_email',
  verifyPhone: 'verify_phone',
} as const;

export interface Flow {
  id: FlowId;
  provider?: Provider;
  is_pending?: boolean;
  /** Matches `settings.MFA_SUPPORTED_TYPES`. */
  types?: AuthenticatorType[];
}

export interface Authenticated {
  user: User;
  /** A list of methods used to authenticate.
   */
  methods: AuthenticationMethod[];
}

export interface ReauthenticationRequired {
  flows: Flow[];
  user: User;
  /** A list of methods used to authenticate.
   */
  methods: AuthenticationMethod[];
}

export type AuthenticationMethodOneOfMethod =
  (typeof AuthenticationMethodOneOfMethod)[keyof typeof AuthenticationMethodOneOfMethod];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AuthenticationMethodOneOfMethod = {
  password: 'password',
} as const;

export type AuthenticationMethodOneOf = {
  method: AuthenticationMethodOneOfMethod;
  at: Timestamp;
  email?: Email;
  username?: Username;
};

export type AuthenticationMethodOneOfThreeMethod =
  (typeof AuthenticationMethodOneOfThreeMethod)[keyof typeof AuthenticationMethodOneOfThreeMethod];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AuthenticationMethodOneOfThreeMethod = {
  passwordReset: 'password_reset',
} as const;

export type AuthenticationMethodOneOfThree = {
  method: AuthenticationMethodOneOfThreeMethod;
  at: Timestamp;
  email: Email;
};

export type AuthenticationMethodOneOfFiveMethod =
  (typeof AuthenticationMethodOneOfFiveMethod)[keyof typeof AuthenticationMethodOneOfFiveMethod];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AuthenticationMethodOneOfFiveMethod = {
  code: 'code',
} as const;

export type AuthenticationMethodOneOfFive = {
  method: AuthenticationMethodOneOfFiveMethod;
  at: Timestamp;
  email: Email;
};

export type AuthenticationMethodOneOfSevenMethod =
  (typeof AuthenticationMethodOneOfSevenMethod)[keyof typeof AuthenticationMethodOneOfSevenMethod];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AuthenticationMethodOneOfSevenMethod = {
  code: 'code',
} as const;

export type AuthenticationMethodOneOfSeven = {
  method: AuthenticationMethodOneOfSevenMethod;
  at: Timestamp;
  phone: Phone;
};

export type AuthenticationMethodOneOfNineMethod =
  (typeof AuthenticationMethodOneOfNineMethod)[keyof typeof AuthenticationMethodOneOfNineMethod];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AuthenticationMethodOneOfNineMethod = {
  password: 'password',
} as const;

export type AuthenticationMethodOneOfNine = {
  method: AuthenticationMethodOneOfNineMethod;
  at: Timestamp;
  reauthenticated: boolean;
};

export type AuthenticationMethodOneOfOneoneMethod =
  (typeof AuthenticationMethodOneOfOneoneMethod)[keyof typeof AuthenticationMethodOneOfOneoneMethod];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AuthenticationMethodOneOfOneoneMethod = {
  socialaccount: 'socialaccount',
} as const;

export type AuthenticationMethodOneOfOneone = {
  method: AuthenticationMethodOneOfOneoneMethod;
  at: Timestamp;
  provider: ProviderID;
  uid: ProviderAccountID;
};

export type AuthenticationMethodOneOfOnethreeMethod =
  (typeof AuthenticationMethodOneOfOnethreeMethod)[keyof typeof AuthenticationMethodOneOfOnethreeMethod];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AuthenticationMethodOneOfOnethreeMethod = {
  mfa: 'mfa',
} as const;

export type AuthenticationMethodOneOfOnethree = {
  method: AuthenticationMethodOneOfOnethreeMethod;
  at: Timestamp;
  type: AuthenticatorType;
  reauthenticated?: boolean;
};

export type AuthenticationMethod =
  | AuthenticationMethodOneOf
  | AuthenticationMethodOneOfThree
  | AuthenticationMethodOneOfFive
  | AuthenticationMethodOneOfSeven
  | AuthenticationMethodOneOfNine
  | AuthenticationMethodOneOfOneone
  | AuthenticationMethodOneOfOnethree;

export interface AuthenticatedResponse {
  status: StatusOK;
  data: Authenticated;
  meta: AuthenticationMeta;
}

export interface MFAAuthenticate {
  code: AuthenticatorCode;
}

export interface MFATrust {
  trust: boolean;
}

export interface ConfirmLoginCode {
  code: Code;
}

/**
 * The client ID (in case of OAuth2 or OpenID Connect based providers)

 */
export type ClientID = string;

/**
 * The token.

 */
export type ProviderTokenToken = {
  client_id: ClientID;
  /** The ID token.
   */
  id_token?: string;
  /** The access token.
   */
  access_token?: string;
};

export interface ProviderToken {
  provider: ProviderID;
  process: Process;
  /** The token.
   */
  token: ProviderTokenToken;
}

export interface ProviderRedirect {
  provider: ProviderID;
  /** The URL to return to after the redirect flow is complete.

Note that this is not to be mistaken with the callback URL that you
configure over at the OAuth provider during the OAuth app/client
setup. The flow is as follows:

  1. Your frontend redirects to the headless provider redirect
     endpoint in a synchronous (non-XHR) manner, informing allauth
     (by means of `callback_url`) where to redirect to after the
     provider handshake is completed.

  2. Headless will redirect to the (OAuth) identity provider to
     initiate the handshake, passing along a different callback URL
     to the provider: one that points to an allauth backend URL.
     This is the URL that you need to have setup at your OAuth
     app/client configuration. Note that this must be a backend URL
     as providers can use POST requests to perform their callbacks,
     which is something a frontend would not be able to handle.

  3. After the authorization at the provider is completed, the
     provider redirects to the *backend* allauth callback URL, which
     will then redirect back to the *frontend* callback URL.

  4. Your frontend is now expected to fetch the current session to
     determine what the next course of action is. The user could be
     authenticated at this point, or another flow is pending
     (e.g. email verification, or, provider signup). In case of
     errors a `?error=` is passed to the frontend callback URL.
 */
  callback_url: string;
  process: Process;
}

export interface RequestPassword {
  email: Email;
}

export type RequestLoginCodeAnyOf = {
  phone: Phone;
};

export type RequestLoginCodeAnyOfTwo = {
  email: Email;
};

export type RequestLoginCode = RequestLoginCodeAnyOf | RequestLoginCodeAnyOfTwo;

export interface Reauthenticate {
  password: Password;
}

export type ProviderSignup = BaseSignup;

export type PasskeySignup = BaseSignup;

export interface BaseSignup {
  email?: Email;
  phone?: Phone;
  username?: Username;
}

export type SignupAllOf = {
  password: Password;
};

export type Signup = BaseSignup & SignupAllOf;

/**
 * The username.

 */
export type Username = string;

/**
 * The email address.

 */
export type Email = string;

/**
 * The phone number.

 */
export type Phone = string;

/**
 * The access token.

 */
export type AccessToken = string;

/**
 * The refresh token.

 */
export type RefreshToken = string;

export type LoginAllOf = {
  password: Password;
};

export type LoginAllOfTwoAnyOf = {
  username: Username;
};

export type LoginAllOfTwoAnyOfTwo = {
  email: Email;
};

export type LoginAllOfTwoAnyOfThree = {
  phone: Phone;
};

export type LoginAllOfTwo = LoginAllOfTwoAnyOf | LoginAllOfTwoAnyOfTwo | LoginAllOfTwoAnyOfThree;

export type Login = LoginAllOf & LoginAllOfTwo;

export type StatusOK = (typeof StatusOK)[keyof typeof StatusOK];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const StatusOK = {
  number200: 200,
} as const;

export type StatusAccepted = (typeof StatusAccepted)[keyof typeof StatusAccepted];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const StatusAccepted = {
  number202: 202,
} as const;

/**
 * Authenticator ID.

 */
export type AuthenticatorID = number;

/**
 * Configuration of the Django `allauth.socialaccount` app.

 */
export interface SocialAccountConfiguration {
  providers: ProviderList;
}

/**
 * Configuration of the Django `allauth.mfa` app.

 */
export interface MFAConfiguration {
  /** Matches `settings.MFA_SUPPORTED_TYPES`.
   */
  supported_types: AuthenticatorType[];
}

/**
 * Configuration of the Django `allauth.usersessions` app.

 */
export interface UserSessionsConfiguration {
  /** Matches `settings.USERSESSIONS_TRACK_ACTIVITY`.
   */
  track_activity: boolean;
}

export type ConfigurationResponseData = {
  account: AccountConfiguration;
  socialaccount?: SocialAccountConfiguration;
  mfa?: MFAConfiguration;
  usersessions?: UserSessionsConfiguration;
};

export interface ConfigurationResponse {
  data: ConfigurationResponseData;
  status: StatusOK;
}

export interface ResetPassword {
  /** The password reset key */
  key: string;
  password: Password;
}

export interface VerifyEmail {
  /** The email verification key */
  key: string;
}

export interface VerifyPhone {
  /** The phone verification code */
  code: string;
}

/**
 * @nullable
 */
export type OptionalTimestamp = Timestamp;

/**
 * An epoch based timestamp (trivial to parse using: `new Date(value)*1000`)

 */
export type Timestamp = number;

/**
 * An authenticator code.

 */
export type AuthenticatorCode = string;

/**
 * An one-time code.

 */
export type Code = string;

/**
 * The type of authenticator.

 */
export type AuthenticatorType = (typeof AuthenticatorType)[keyof typeof AuthenticatorType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AuthenticatorType = {
  recoveryCodes: 'recovery_codes',
  totp: 'totp',
  webauthn: 'webauthn',
} as const;

/**
 * The password.

 */
export type Password = string;

export type ErrorResponseStatus = (typeof ErrorResponseStatus)[keyof typeof ErrorResponseStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ErrorResponseStatus = {
  number400: 400,
} as const;

export type ErrorResponseErrorsItem = {
  /** An error code.
   */
  code: string;
  /** The name of the input parameter that was incorrect.
   */
  param?: string;
  /** A human readable error message.
   */
  message: string;
};

export interface ErrorResponse {
  status?: ErrorResponseStatus;
  errors?: ErrorResponseErrorsItem[];
}

/**
 * The process to be executed when the user successfully
authenticates. When set to `login`, the user will be logged into the
account to which the provider account is connected, or if no such
account exists, a signup will occur. If set to `connect`, the provider
account will be connected to the list of provider accounts for the
currently authenticated user.

 */
export type Process = (typeof Process)[keyof typeof Process];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const Process = {
  login: 'login',
  connect: 'connect',
} as const;

/**
 * The provider ID.

 */
export type ProviderID = string;

/**
 * The provider specific account ID.

 */
export type ProviderAccountID = string;

/**
 * The user ID.

 */
export type UserId = number | string;

export interface User {
  /** The user ID.
   */
  id?: UserId;
  /** The display name for the user.
   */
  display?: string;
  /** Whether or not the account has a password set.
   */
  has_usable_password?: boolean;
  email?: Email;
  username?: Username;
}

export interface EmailAddress {
  email: Email;
  primary: boolean;
  verified: boolean;
}

export interface BaseAuthenticator {
  last_used_at: Timestamp;
  created_at: Timestamp;
}

export type TOTPAuthenticatorAllOfType =
  (typeof TOTPAuthenticatorAllOfType)[keyof typeof TOTPAuthenticatorAllOfType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TOTPAuthenticatorAllOfType = {
  totp: 'totp',
} as const;

export type TOTPAuthenticatorAllOf = {
  type: TOTPAuthenticatorAllOfType;
};

export type TOTPAuthenticator = BaseAuthenticator & TOTPAuthenticatorAllOf;

export type WebAuthnAuthenticatorAllOfType =
  (typeof WebAuthnAuthenticatorAllOfType)[keyof typeof WebAuthnAuthenticatorAllOfType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const WebAuthnAuthenticatorAllOfType = {
  webauthn: 'webauthn',
} as const;

export type WebAuthnAuthenticatorAllOf = {
  type: WebAuthnAuthenticatorAllOfType;
  id: AuthenticatorID;
  name: string;
  /** Whether or not this authenticator represents a passkey. Absent if it is not specified.
   */
  is_passwordless?: boolean;
};

export type WebAuthnAuthenticator = BaseAuthenticator & WebAuthnAuthenticatorAllOf;

/**
 * The authenticator type.

 */
export type RecoveryCodesAuthenticatorAllOfType =
  (typeof RecoveryCodesAuthenticatorAllOfType)[keyof typeof RecoveryCodesAuthenticatorAllOfType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const RecoveryCodesAuthenticatorAllOfType = {
  recoveryCodes: 'recovery_codes',
} as const;

export type RecoveryCodesAuthenticatorAllOf = {
  /** The authenticator type.
   */
  type: RecoveryCodesAuthenticatorAllOfType;
  /** The total number of recovery codes that initially were available.
   */
  total_code_count: number;
  /** The number of recovery codes that are unused.
   */
  unused_code_count: number;
};

export type RecoveryCodesAuthenticator = BaseAuthenticator & RecoveryCodesAuthenticatorAllOf;

export type SensitiveRecoveryCodesAuthenticatorAllOf = {
  /** The list of unused codes.
   */
  unused_codes: AuthenticatorCode[];
};

export type SensitiveRecoveryCodesAuthenticator = RecoveryCodesAuthenticator &
  SensitiveRecoveryCodesAuthenticatorAllOf;

export type AuthenticatorListItem =
  | TOTPAuthenticator
  | RecoveryCodesAuthenticator
  | WebAuthnAuthenticator;

export type AuthenticatorList = AuthenticatorListItem[];

export type ProviderList = Provider[];

export type ProviderFlowsItem = (typeof ProviderFlowsItem)[keyof typeof ProviderFlowsItem];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ProviderFlowsItem = {
  providerRedirect: 'provider_redirect',
  providerToken: 'provider_token',
} as const;

export interface Provider {
  /** The provider ID.
   */
  id: string;
  /** The name of the provider.
   */
  name: string;
  /** The client ID (in case of OAuth2 or OpenID Connect based providers)
   */
  client_id?: string;
  /** The OIDC discovery or well-known URL (in case of OAuth2 or OpenID Connect based providers)
   */
  openid_configuration_url?: string;
  /** The authentication flows the provider integration supports.
   */
  flows: ProviderFlowsItem[];
}

export interface ProviderAccount {
  uid: ProviderAccountID;
  /** A name derived from the third-party provider account data.
   */
  display: string;
  provider: Provider;
}

export type EmailVerificationInfoData = {
  email: Email;
  user: User;
};

export type EmailVerificationInfoMeta = {
  is_authenticating: boolean;
};

export interface EmailVerificationInfo {
  status: StatusOK;
  data: EmailVerificationInfoData;
  meta: EmailVerificationInfoMeta;
}

export type WebAuthnCredentialRequestOptionsRequestOptions = { [key: string]: unknown };

export interface WebAuthnCredentialRequestOptions {
  request_options: WebAuthnCredentialRequestOptionsRequestOptions;
}

export type WebAuthnCredentialCreationOptionsCreationOptions = { [key: string]: unknown };

export interface WebAuthnCredentialCreationOptions {
  creation_options: WebAuthnCredentialCreationOptionsCreationOptions;
}

export interface WebAuthnCredential {
  [key: string]: unknown;
}

/**
 * The account prohibits adding an authenticator, e.g. because of an unverified email address.

 */
export type AddAuthenticatorConflictResponse = ConflictResponse;

export type AuthenticatorsResponse = {
  status: StatusOK;
  data: AuthenticatorList;
};

/**
 * Authenticated by password.

 */
export type AuthenticatedByPasswordResponse = AuthenticatedResponse;

/**
 * Authenticated by code.

 */
export type AuthenticatedByCodeResponse = AuthenticatedResponse;

/**
 * Authenticated by password and 2FA.

 */
export type AuthenticatedByPasswordAnd2FAResponse = AuthenticatedResponse;

export type AuthenticationOrReauthenticationResponse =
  | AuthenticationResponse
  | ReauthenticationResponse;

export type EmailAddressesResponse = {
  status: StatusOK;
  data: EmailAddress[];
};

/**
 * Email verification information.
 */
export type EmailVerificationInfoResponse = EmailVerificationInfo;

export type NotFoundResponseStatus =
  (typeof NotFoundResponseStatus)[keyof typeof NotFoundResponseStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const NotFoundResponseStatus = {
  number404: 404,
} as const;

export type NotFoundResponse = {
  status: NotFoundResponseStatus;
};

export type PasswordResetInfoResponseData = {
  user?: User;
};

export type PasswordResetInfoResponse = {
  status: StatusOK;
  data: PasswordResetInfoResponseData;
};

export type ProviderAccountsResponse = {
  status: StatusOK;
  data: ProviderAccount[];
};

export type ProviderSignupResponseData = {
  email: EmailAddress[];
  account: ProviderAccount;
  user: User;
};

export type ProviderSignupResponse = {
  status: StatusOK;
  data: ProviderSignupResponseData;
};

/**
 * The response indicates reauthentication is required.

 */
export type ReauthenticationRequiredResponse = ReauthenticationResponse;

export type RecoveryCodesResponse = {
  status: StatusOK;
  data: SensitiveRecoveryCodesAuthenticator;
};

export type RefreshTokenResponseData = {
  access_token: AccessToken;
  refresh_token?: RefreshToken;
};

export type RefreshTokenResponse = {
  status: StatusOK;
  data: RefreshTokenResponseData;
};

export type SessionsResponse = {
  status: StatusOK;
  data: Session[];
};

export type StatusOKResponse = {
  status: StatusOK;
};

export type TooManyRequestsResponseStatus =
  (typeof TooManyRequestsResponseStatus)[keyof typeof TooManyRequestsResponseStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TooManyRequestsResponseStatus = {
  number429: 429,
} as const;

export type TooManyRequestsResponse = {
  status: TooManyRequestsResponseStatus;
};

export type TOTPAuthenticatorResponseMeta = {
  /** Whether or not recovery codes where generated automatically. */
  recovery_codes_generated?: boolean;
};

export type TOTPAuthenticatorResponse = {
  status: StatusOK;
  meta?: TOTPAuthenticatorResponseMeta;
  data: TOTPAuthenticator;
};

export type TOTPAuthenticatorNotFoundResponseStatus =
  (typeof TOTPAuthenticatorNotFoundResponseStatus)[keyof typeof TOTPAuthenticatorNotFoundResponseStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TOTPAuthenticatorNotFoundResponseStatus = {
  number404: 404,
} as const;

export type TOTPAuthenticatorNotFoundResponseMeta = {
  /** A TOTP secret that can be used to setup a new authenticator.
   */
  secret: string;
  /** otpauth URI from which a QR code can be generated and scanned by OTP clients.
   */
  totp_url: string;
};

export type TOTPAuthenticatorNotFoundResponse = {
  status: TOTPAuthenticatorNotFoundResponseStatus;
  meta: TOTPAuthenticatorNotFoundResponseMeta;
};

/**
 * There is no authenticated session.

 */
export type UnauthenticatedResponse = AuthenticationResponse;

export type WebAuthnRequestOptionsResponseResponse = {
  status: StatusOK;
  data: WebAuthnCredentialRequestOptions;
};

export type WebAuthnCreationOptionsResponseResponse = {
  status: StatusOK;
  data: WebAuthnCredentialCreationOptions;
};

export type WebAuthnAuthenticatorResponse = {
  status: StatusOK;
  data: WebAuthnAuthenticator;
};

export type AddWebAuthnAuthenticatorResponseMeta = {
  /** Whether or not recovery codes where generated automatically.
   */
  recovery_codes_generated?: boolean;
};

export type AddWebAuthnAuthenticatorResponse = {
  status: StatusOK;
  data: WebAuthnAuthenticator;
  meta: AddWebAuthnAuthenticatorResponseMeta;
};

/**
 * Login.
 */
export type LoginBody = Login;

export type LoginWebAuthnBody = {
  credential: WebAuthnCredential;
};

export type ReauthenticateWebAuthnBody = {
  credential: WebAuthnCredential;
};

export type AuthenticateWebAuthnBody = {
  credential: WebAuthnCredential;
};

export type MFAAuthenticateBody = MFAAuthenticate;

export type MFATrustBody = MFATrust;

export type ConfirmLoginCodeBody = ConfirmLoginCode;

export type EndSessionsBody = EndSessions;

/**
 * Signup using a passkey
 */
export type PasskeySignupBody = PasskeySignup;

export type ProviderAccountBody = {
  provider: ProviderID;
  account: ProviderAccountID;
};

/**
 * Initiate the provider redirect flow.

 */
export type ProviderRedirectBody = ProviderRedirect;

/**
 * Provider signup.
 */
export type ProviderSignupBody = ProviderSignup;

export type ProviderTokenBody = ProviderToken;

/**
 * Reauthenticate.
 */
export type ReauthenticateBody = Reauthenticate;

export type RefreshTokenBody = {
  refresh_token: RefreshToken;
};

/**
 * Request password.
 */
export type RequestPasswordBody = RequestPassword;

/**
 * Request a login code.
 */
export type RequestLoginCodeBody = RequestLoginCode;

export type SetupTOTPBody = {
  code: AuthenticatorCode;
};

/**
 * Signup
 */
export type SignupBody = Signup;

export type ChangePasswordBody = {
  current_password?: Password;
  /** The current password.
   */
  new_password: string;
};

export type EmailBody = {
  email: Email;
};

export type MarkPrimaryEmailBody = {
  /** An email address.
   */
  email: string;
  /** Primary flag.
   */
  primary: boolean;
};

export type PhoneBody = {
  phone: string;
};

export type ResetPasswordBody = ResetPassword;

export type VerifyEmailBody = VerifyEmail;

export type VerifyPhoneBody = VerifyPhone;

export type UpdateWebAuthnBody = {
  id?: AuthenticatorID;
  name?: string;
};

export type AddWebAuthnAuthenticatorBody = {
  name?: string;
  credential: WebAuthnCredential;
};

export type DeleteWebAuthnBody = {
  /** The IDs of the authenticator that are to be deleted.
   */
  authenticators: AuthenticatorID[];
};

/**
 * The email verification key
 */
export type EmailVerificationKeyParameter = string;

/**
 * The password reset key
 */
export type PasswordResetKeyParameter = string;

/**
 * Session token. Only needed when `client` is equal to `app`.

 */
export type SessionTokenParameter = string;

/**
 * When present (regardless of its value), enables passwordless sign-in via a WebAuthn credential (Passkey),
but may enforce additional multi-factor authentication (MFA) requirements. Omit the parameter to disable.

 */
export type PasswordLessParameter = boolean;

export type GetAllauthClientV1AccountAuthenticatorsWebauthnParams = {
  /**
 * When present (regardless of its value), enables passwordless sign-in via a WebAuthn credential (Passkey),
but may enforce additional multi-factor authentication (MFA) requirements. Omit the parameter to disable.

 */
  passwordless?: PasswordLessParameter;
};

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

/**
 * There are many configuration options that alter the functionality
and behavior of django-allauth, some of which can also impact the
frontend. Therefore, relevant configuration options are exposed via
this endpoint. The data returned is not user/authentication
dependent. Hence, it suffices to only fetch this data once at boot
time of your application.

 * @summary Get configuration
 */
export const getAllauthClientV1Config = (
  client: 'app' | 'browser',
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<ConfigurationResponse>(
    { url: `/api/_allauth/${client}/v1/config`, method: 'GET', signal },
    options,
  );
};

export const getGetAllauthClientV1ConfigQueryKey = (client?: 'app' | 'browser') => {
  return [`/api/_allauth/${client}/v1/config`] as const;
};

export const getGetAllauthClientV1ConfigQueryOptions = <
  TData = Awaited<ReturnType<typeof getAllauthClientV1Config>>,
  TError = ErrorType<unknown>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1Config>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAllauthClientV1ConfigQueryKey(client);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllauthClientV1Config>>> = ({
    signal,
  }) => getAllauthClientV1Config(client, requestOptions, signal);

  return { queryKey, queryFn, enabled: !!client, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getAllauthClientV1Config>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetAllauthClientV1ConfigQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAllauthClientV1Config>>
>;
export type GetAllauthClientV1ConfigQueryError = ErrorType<unknown>;

export function useGetAllauthClientV1Config<
  TData = Awaited<ReturnType<typeof getAllauthClientV1Config>>,
  TError = ErrorType<unknown>,
>(
  client: 'app' | 'browser',
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1Config>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllauthClientV1Config>>,
          TError,
          Awaited<ReturnType<typeof getAllauthClientV1Config>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAllauthClientV1Config<
  TData = Awaited<ReturnType<typeof getAllauthClientV1Config>>,
  TError = ErrorType<unknown>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1Config>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllauthClientV1Config>>,
          TError,
          Awaited<ReturnType<typeof getAllauthClientV1Config>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAllauthClientV1Config<
  TData = Awaited<ReturnType<typeof getAllauthClientV1Config>>,
  TError = ErrorType<unknown>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1Config>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get configuration
 */

export function useGetAllauthClientV1Config<
  TData = Awaited<ReturnType<typeof getAllauthClientV1Config>>,
  TError = ErrorType<unknown>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1Config>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetAllauthClientV1ConfigQueryOptions(client, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Login using a username-password or email-password combination.

 * @summary Login
 */
export const postAllauthClientV1AuthLogin = (
  client: 'app' | 'browser',
  loginBody: BodyType<LoginBody>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<AuthenticatedByPasswordResponse>(
    {
      url: `/api/_allauth/${client}/v1/auth/login`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: loginBody,
      signal,
    },
    options,
  );
};

export const getPostAllauthClientV1AuthLoginMutationOptions = <
  TError = ErrorType<ErrorResponse | AuthenticationResponse | ConflictResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postAllauthClientV1AuthLogin>>,
    TError,
    { client: 'app' | 'browser'; data: BodyType<LoginBody> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postAllauthClientV1AuthLogin>>,
  TError,
  { client: 'app' | 'browser'; data: BodyType<LoginBody> },
  TContext
> => {
  const mutationKey = ['postAllauthClientV1AuthLogin'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postAllauthClientV1AuthLogin>>,
    { client: 'app' | 'browser'; data: BodyType<LoginBody> }
  > = props => {
    const { client, data } = props ?? {};

    return postAllauthClientV1AuthLogin(client, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostAllauthClientV1AuthLoginMutationResult = NonNullable<
  Awaited<ReturnType<typeof postAllauthClientV1AuthLogin>>
>;
export type PostAllauthClientV1AuthLoginMutationBody = BodyType<LoginBody>;
export type PostAllauthClientV1AuthLoginMutationError = ErrorType<
  ErrorResponse | AuthenticationResponse | ConflictResponse
>;

/**
 * @summary Login
 */
export const usePostAllauthClientV1AuthLogin = <
  TError = ErrorType<ErrorResponse | AuthenticationResponse | ConflictResponse>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postAllauthClientV1AuthLogin>>,
      TError,
      { client: 'app' | 'browser'; data: BodyType<LoginBody> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof postAllauthClientV1AuthLogin>>,
  TError,
  { client: 'app' | 'browser'; data: BodyType<LoginBody> },
  TContext
> => {
  const mutationOptions = getPostAllauthClientV1AuthLoginMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Whether or not `username`, `email`, `phone` or combination of those are
required depends on the configuration of django-allauth. Additionally,
if a custom signup form is used there may be other custom properties
required.

 * @summary Signup
 */
export const postAllauthClientV1AuthSignup = (
  client: 'app' | 'browser',
  signupBody: BodyType<SignupBody>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<AuthenticatedByPasswordResponse>(
    {
      url: `/api/_allauth/${client}/v1/auth/signup`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: signupBody,
      signal,
    },
    options,
  );
};

export const getPostAllauthClientV1AuthSignupMutationOptions = <
  TError = ErrorType<ErrorResponse | AuthenticationResponse | ForbiddenResponse | ConflictResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postAllauthClientV1AuthSignup>>,
    TError,
    { client: 'app' | 'browser'; data: BodyType<SignupBody> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postAllauthClientV1AuthSignup>>,
  TError,
  { client: 'app' | 'browser'; data: BodyType<SignupBody> },
  TContext
> => {
  const mutationKey = ['postAllauthClientV1AuthSignup'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postAllauthClientV1AuthSignup>>,
    { client: 'app' | 'browser'; data: BodyType<SignupBody> }
  > = props => {
    const { client, data } = props ?? {};

    return postAllauthClientV1AuthSignup(client, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostAllauthClientV1AuthSignupMutationResult = NonNullable<
  Awaited<ReturnType<typeof postAllauthClientV1AuthSignup>>
>;
export type PostAllauthClientV1AuthSignupMutationBody = BodyType<SignupBody>;
export type PostAllauthClientV1AuthSignupMutationError = ErrorType<
  ErrorResponse | AuthenticationResponse | ForbiddenResponse | ConflictResponse
>;

/**
 * @summary Signup
 */
export const usePostAllauthClientV1AuthSignup = <
  TError = ErrorType<ErrorResponse | AuthenticationResponse | ForbiddenResponse | ConflictResponse>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postAllauthClientV1AuthSignup>>,
      TError,
      { client: 'app' | 'browser'; data: BodyType<SignupBody> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof postAllauthClientV1AuthSignup>>,
  TError,
  { client: 'app' | 'browser'; data: BodyType<SignupBody> },
  TContext
> => {
  const mutationOptions = getPostAllauthClientV1AuthSignupMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Obtain email verification information, given the token that was sent to
the user by email.

 * @summary Get email verification information
 */
export const getAllauthClientV1AuthEmailVerify = (
  client: 'app' | 'browser',
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<EmailVerificationInfoResponse>(
    { url: `/api/_allauth/${client}/v1/auth/email/verify`, method: 'GET', signal },
    options,
  );
};

export const getGetAllauthClientV1AuthEmailVerifyQueryKey = (client?: 'app' | 'browser') => {
  return [`/api/_allauth/${client}/v1/auth/email/verify`] as const;
};

export const getGetAllauthClientV1AuthEmailVerifyQueryOptions = <
  TData = Awaited<ReturnType<typeof getAllauthClientV1AuthEmailVerify>>,
  TError = ErrorType<ErrorResponse | ConflictResponse>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1AuthEmailVerify>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAllauthClientV1AuthEmailVerifyQueryKey(client);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllauthClientV1AuthEmailVerify>>> = ({
    signal,
  }) => getAllauthClientV1AuthEmailVerify(client, requestOptions, signal);

  return { queryKey, queryFn, enabled: !!client, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getAllauthClientV1AuthEmailVerify>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetAllauthClientV1AuthEmailVerifyQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAllauthClientV1AuthEmailVerify>>
>;
export type GetAllauthClientV1AuthEmailVerifyQueryError = ErrorType<
  ErrorResponse | ConflictResponse
>;

export function useGetAllauthClientV1AuthEmailVerify<
  TData = Awaited<ReturnType<typeof getAllauthClientV1AuthEmailVerify>>,
  TError = ErrorType<ErrorResponse | ConflictResponse>,
>(
  client: 'app' | 'browser',
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1AuthEmailVerify>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllauthClientV1AuthEmailVerify>>,
          TError,
          Awaited<ReturnType<typeof getAllauthClientV1AuthEmailVerify>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAllauthClientV1AuthEmailVerify<
  TData = Awaited<ReturnType<typeof getAllauthClientV1AuthEmailVerify>>,
  TError = ErrorType<ErrorResponse | ConflictResponse>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1AuthEmailVerify>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllauthClientV1AuthEmailVerify>>,
          TError,
          Awaited<ReturnType<typeof getAllauthClientV1AuthEmailVerify>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAllauthClientV1AuthEmailVerify<
  TData = Awaited<ReturnType<typeof getAllauthClientV1AuthEmailVerify>>,
  TError = ErrorType<ErrorResponse | ConflictResponse>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1AuthEmailVerify>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get email verification information
 */

export function useGetAllauthClientV1AuthEmailVerify<
  TData = Awaited<ReturnType<typeof getAllauthClientV1AuthEmailVerify>>,
  TError = ErrorType<ErrorResponse | ConflictResponse>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1AuthEmailVerify>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetAllauthClientV1AuthEmailVerifyQueryOptions(client, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Complete the email verification process. Depending on the configuration,
email addresses are either verified by opening a link that is sent to
their email address, or, by inputting a code that is sent. On the API,
both cases are handled identically. Meaning, the required key is either
the one from the link, or, the code itself.

Note that a status code of 401 does not imply failure. It indicates that
the email verification was successful, yet, the user is still not signed
in. For example, in case `ACCOUNT_LOGIN_ON_EMAIL_CONFIRMATION` is set to
`False`, a 401 is returned when verifying as part of login/signup.

 * @summary Verify an email
 */
export const postAllauthClientV1AuthEmailVerify = (
  client: 'app' | 'browser',
  verifyEmailBody: BodyType<VerifyEmailBody>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<AuthenticatedResponse>(
    {
      url: `/api/_allauth/${client}/v1/auth/email/verify`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: verifyEmailBody,
      signal,
    },
    options,
  );
};

export const getPostAllauthClientV1AuthEmailVerifyMutationOptions = <
  TError = ErrorType<ErrorResponse | UnauthenticatedResponse | ConflictResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postAllauthClientV1AuthEmailVerify>>,
    TError,
    { client: 'app' | 'browser'; data: BodyType<VerifyEmailBody> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postAllauthClientV1AuthEmailVerify>>,
  TError,
  { client: 'app' | 'browser'; data: BodyType<VerifyEmailBody> },
  TContext
> => {
  const mutationKey = ['postAllauthClientV1AuthEmailVerify'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postAllauthClientV1AuthEmailVerify>>,
    { client: 'app' | 'browser'; data: BodyType<VerifyEmailBody> }
  > = props => {
    const { client, data } = props ?? {};

    return postAllauthClientV1AuthEmailVerify(client, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostAllauthClientV1AuthEmailVerifyMutationResult = NonNullable<
  Awaited<ReturnType<typeof postAllauthClientV1AuthEmailVerify>>
>;
export type PostAllauthClientV1AuthEmailVerifyMutationBody = BodyType<VerifyEmailBody>;
export type PostAllauthClientV1AuthEmailVerifyMutationError = ErrorType<
  ErrorResponse | UnauthenticatedResponse | ConflictResponse
>;

/**
 * @summary Verify an email
 */
export const usePostAllauthClientV1AuthEmailVerify = <
  TError = ErrorType<ErrorResponse | UnauthenticatedResponse | ConflictResponse>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postAllauthClientV1AuthEmailVerify>>,
      TError,
      { client: 'app' | 'browser'; data: BodyType<VerifyEmailBody> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof postAllauthClientV1AuthEmailVerify>>,
  TError,
  { client: 'app' | 'browser'; data: BodyType<VerifyEmailBody> },
  TContext
> => {
  const mutationOptions = getPostAllauthClientV1AuthEmailVerifyMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Requests a new email verification code.
Requires `ACCOUNT_EMAIL_VERIFICATION_SUPPORTS_RESEND = True`.

 * @summary Resend email verification code
 */
export const postAllauthClientV1AuthEmailVerifyResend = (
  client: 'app' | 'browser',
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<StatusOKResponse>(
    { url: `/api/_allauth/${client}/v1/auth/email/verify/resend`, method: 'POST', signal },
    options,
  );
};

export const getPostAllauthClientV1AuthEmailVerifyResendMutationOptions = <
  TError = ErrorType<ConflictResponse | TooManyRequestsResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postAllauthClientV1AuthEmailVerifyResend>>,
    TError,
    { client: 'app' | 'browser' },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postAllauthClientV1AuthEmailVerifyResend>>,
  TError,
  { client: 'app' | 'browser' },
  TContext
> => {
  const mutationKey = ['postAllauthClientV1AuthEmailVerifyResend'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postAllauthClientV1AuthEmailVerifyResend>>,
    { client: 'app' | 'browser' }
  > = props => {
    const { client } = props ?? {};

    return postAllauthClientV1AuthEmailVerifyResend(client, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostAllauthClientV1AuthEmailVerifyResendMutationResult = NonNullable<
  Awaited<ReturnType<typeof postAllauthClientV1AuthEmailVerifyResend>>
>;

export type PostAllauthClientV1AuthEmailVerifyResendMutationError = ErrorType<
  ConflictResponse | TooManyRequestsResponse
>;

/**
 * @summary Resend email verification code
 */
export const usePostAllauthClientV1AuthEmailVerifyResend = <
  TError = ErrorType<ConflictResponse | TooManyRequestsResponse>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postAllauthClientV1AuthEmailVerifyResend>>,
      TError,
      { client: 'app' | 'browser' },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof postAllauthClientV1AuthEmailVerifyResend>>,
  TError,
  { client: 'app' | 'browser' },
  TContext
> => {
  const mutationOptions = getPostAllauthClientV1AuthEmailVerifyResendMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Complete the phone number verification process. Note that a status code
of 401 does not imply failure. It merely indicates that the phone number
verification was successful, yet, the user is still not signed in.

 * @summary Verify a phone number
 */
export const postAllauthClientV1AuthPhoneVerify = (
  client: 'app' | 'browser',
  verifyPhoneBody: BodyType<VerifyPhoneBody>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<AuthenticatedResponse>(
    {
      url: `/api/_allauth/${client}/v1/auth/phone/verify`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: verifyPhoneBody,
      signal,
    },
    options,
  );
};

export const getPostAllauthClientV1AuthPhoneVerifyMutationOptions = <
  TError = ErrorType<ErrorResponse | UnauthenticatedResponse | ConflictResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postAllauthClientV1AuthPhoneVerify>>,
    TError,
    { client: 'app' | 'browser'; data: BodyType<VerifyPhoneBody> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postAllauthClientV1AuthPhoneVerify>>,
  TError,
  { client: 'app' | 'browser'; data: BodyType<VerifyPhoneBody> },
  TContext
> => {
  const mutationKey = ['postAllauthClientV1AuthPhoneVerify'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postAllauthClientV1AuthPhoneVerify>>,
    { client: 'app' | 'browser'; data: BodyType<VerifyPhoneBody> }
  > = props => {
    const { client, data } = props ?? {};

    return postAllauthClientV1AuthPhoneVerify(client, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostAllauthClientV1AuthPhoneVerifyMutationResult = NonNullable<
  Awaited<ReturnType<typeof postAllauthClientV1AuthPhoneVerify>>
>;
export type PostAllauthClientV1AuthPhoneVerifyMutationBody = BodyType<VerifyPhoneBody>;
export type PostAllauthClientV1AuthPhoneVerifyMutationError = ErrorType<
  ErrorResponse | UnauthenticatedResponse | ConflictResponse
>;

/**
 * @summary Verify a phone number
 */
export const usePostAllauthClientV1AuthPhoneVerify = <
  TError = ErrorType<ErrorResponse | UnauthenticatedResponse | ConflictResponse>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postAllauthClientV1AuthPhoneVerify>>,
      TError,
      { client: 'app' | 'browser'; data: BodyType<VerifyPhoneBody> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof postAllauthClientV1AuthPhoneVerify>>,
  TError,
  { client: 'app' | 'browser'; data: BodyType<VerifyPhoneBody> },
  TContext
> => {
  const mutationOptions = getPostAllauthClientV1AuthPhoneVerifyMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Requests a new phone number verification code.
Requires `ACCOUNT_PHONE_VERIFICATION_SUPPORTS_RESEND = True`.

 * @summary Resend phone number verification code
 */
export const postAllauthClientV1AuthPhoneVerifyResend = (
  client: 'app' | 'browser',
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<StatusOKResponse>(
    { url: `/api/_allauth/${client}/v1/auth/phone/verify/resend`, method: 'POST', signal },
    options,
  );
};

export const getPostAllauthClientV1AuthPhoneVerifyResendMutationOptions = <
  TError = ErrorType<ConflictResponse | TooManyRequestsResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postAllauthClientV1AuthPhoneVerifyResend>>,
    TError,
    { client: 'app' | 'browser' },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postAllauthClientV1AuthPhoneVerifyResend>>,
  TError,
  { client: 'app' | 'browser' },
  TContext
> => {
  const mutationKey = ['postAllauthClientV1AuthPhoneVerifyResend'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postAllauthClientV1AuthPhoneVerifyResend>>,
    { client: 'app' | 'browser' }
  > = props => {
    const { client } = props ?? {};

    return postAllauthClientV1AuthPhoneVerifyResend(client, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostAllauthClientV1AuthPhoneVerifyResendMutationResult = NonNullable<
  Awaited<ReturnType<typeof postAllauthClientV1AuthPhoneVerifyResend>>
>;

export type PostAllauthClientV1AuthPhoneVerifyResendMutationError = ErrorType<
  ConflictResponse | TooManyRequestsResponse
>;

/**
 * @summary Resend phone number verification code
 */
export const usePostAllauthClientV1AuthPhoneVerifyResend = <
  TError = ErrorType<ConflictResponse | TooManyRequestsResponse>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postAllauthClientV1AuthPhoneVerifyResend>>,
      TError,
      { client: 'app' | 'browser' },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof postAllauthClientV1AuthPhoneVerifyResend>>,
  TError,
  { client: 'app' | 'browser' },
  TContext
> => {
  const mutationOptions = getPostAllauthClientV1AuthPhoneVerifyResendMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * In order to safeguard the account, some actions require the user to be
recently authenticated.  If you try to perform such an action without
having been recently authenticated, a `401` status is returned, listing
flows that can be performed to reauthenticate. One such flow is the flow
with ID `reauthenticate`, which allows for the user to input the
password. This is the endpoint related towards that flow.

 * @summary Reauthenticate
 */
export const postAllauthClientV1AuthReauthenticate = (
  client: 'app' | 'browser',
  reauthenticateBody: BodyType<ReauthenticateBody>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<AuthenticatedByPasswordResponse>(
    {
      url: `/api/_allauth/${client}/v1/auth/reauthenticate`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: reauthenticateBody,
      signal,
    },
    options,
  );
};

export const getPostAllauthClientV1AuthReauthenticateMutationOptions = <
  TError = ErrorType<ErrorResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postAllauthClientV1AuthReauthenticate>>,
    TError,
    { client: 'app' | 'browser'; data: BodyType<ReauthenticateBody> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postAllauthClientV1AuthReauthenticate>>,
  TError,
  { client: 'app' | 'browser'; data: BodyType<ReauthenticateBody> },
  TContext
> => {
  const mutationKey = ['postAllauthClientV1AuthReauthenticate'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postAllauthClientV1AuthReauthenticate>>,
    { client: 'app' | 'browser'; data: BodyType<ReauthenticateBody> }
  > = props => {
    const { client, data } = props ?? {};

    return postAllauthClientV1AuthReauthenticate(client, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostAllauthClientV1AuthReauthenticateMutationResult = NonNullable<
  Awaited<ReturnType<typeof postAllauthClientV1AuthReauthenticate>>
>;
export type PostAllauthClientV1AuthReauthenticateMutationBody = BodyType<ReauthenticateBody>;
export type PostAllauthClientV1AuthReauthenticateMutationError = ErrorType<ErrorResponse>;

/**
 * @summary Reauthenticate
 */
export const usePostAllauthClientV1AuthReauthenticate = <
  TError = ErrorType<ErrorResponse>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postAllauthClientV1AuthReauthenticate>>,
      TError,
      { client: 'app' | 'browser'; data: BodyType<ReauthenticateBody> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof postAllauthClientV1AuthReauthenticate>>,
  TError,
  { client: 'app' | 'browser'; data: BodyType<ReauthenticateBody> },
  TContext
> => {
  const mutationOptions = getPostAllauthClientV1AuthReauthenticateMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Initiates the password reset procedure. Depending on whether or not
`ACCOUNT_PASSWORD_RESET_BY_CODE_ENABLED` is `True`, the procedure is
either stateless or stateful.

In case codes are used, it is stateful, and a new
`password_reset_by_code` flow is started. In this case, on a successful
password reset request, you will receive a 401 indicating the pending
status of this flow.

In case password reset is configured to use (stateless) links, you will
receive a 200 on a successful password reset request.

 * @summary Request password
 */
export const postAllauthClientV1AuthPasswordRequest = (
  client: 'app' | 'browser',
  requestPasswordBody: BodyType<RequestPasswordBody>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<StatusOKResponse>(
    {
      url: `/api/_allauth/${client}/v1/auth/password/request`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: requestPasswordBody,
      signal,
    },
    options,
  );
};

export const getPostAllauthClientV1AuthPasswordRequestMutationOptions = <
  TError = ErrorType<ErrorResponse | AuthenticationResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postAllauthClientV1AuthPasswordRequest>>,
    TError,
    { client: 'app' | 'browser'; data: BodyType<RequestPasswordBody> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postAllauthClientV1AuthPasswordRequest>>,
  TError,
  { client: 'app' | 'browser'; data: BodyType<RequestPasswordBody> },
  TContext
> => {
  const mutationKey = ['postAllauthClientV1AuthPasswordRequest'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postAllauthClientV1AuthPasswordRequest>>,
    { client: 'app' | 'browser'; data: BodyType<RequestPasswordBody> }
  > = props => {
    const { client, data } = props ?? {};

    return postAllauthClientV1AuthPasswordRequest(client, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostAllauthClientV1AuthPasswordRequestMutationResult = NonNullable<
  Awaited<ReturnType<typeof postAllauthClientV1AuthPasswordRequest>>
>;
export type PostAllauthClientV1AuthPasswordRequestMutationBody = BodyType<RequestPasswordBody>;
export type PostAllauthClientV1AuthPasswordRequestMutationError = ErrorType<
  ErrorResponse | AuthenticationResponse
>;

/**
 * @summary Request password
 */
export const usePostAllauthClientV1AuthPasswordRequest = <
  TError = ErrorType<ErrorResponse | AuthenticationResponse>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postAllauthClientV1AuthPasswordRequest>>,
      TError,
      { client: 'app' | 'browser'; data: BodyType<RequestPasswordBody> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof postAllauthClientV1AuthPasswordRequest>>,
  TError,
  { client: 'app' | 'browser'; data: BodyType<RequestPasswordBody> },
  TContext
> => {
  const mutationOptions = getPostAllauthClientV1AuthPasswordRequestMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Used to obtain information on and validate a password reset key.  The
key passed is either the key encoded in the password reset URL that the
user has received per email, or, the password reset code in case of
`ACCOUNT_PASSWORD_RESET_BY_CODE_ENABLED`. Note that in case of a code,
the number of requests you can make is limited (by
`ACCOUNT_PASSWORD_RESET_BY_CODE_MAX_ATTEMPTS`).

 * @summary Get password reset information
 */
export const getAllauthClientV1AuthPasswordReset = (
  client: 'app' | 'browser',
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<PasswordResetInfoResponse>(
    { url: `/api/_allauth/${client}/v1/auth/password/reset`, method: 'GET', signal },
    options,
  );
};

export const getGetAllauthClientV1AuthPasswordResetQueryKey = (client?: 'app' | 'browser') => {
  return [`/api/_allauth/${client}/v1/auth/password/reset`] as const;
};

export const getGetAllauthClientV1AuthPasswordResetQueryOptions = <
  TData = Awaited<ReturnType<typeof getAllauthClientV1AuthPasswordReset>>,
  TError = ErrorType<ErrorResponse | ConflictResponse>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAllauthClientV1AuthPasswordReset>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAllauthClientV1AuthPasswordResetQueryKey(client);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllauthClientV1AuthPasswordReset>>> = ({
    signal,
  }) => getAllauthClientV1AuthPasswordReset(client, requestOptions, signal);

  return { queryKey, queryFn, enabled: !!client, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getAllauthClientV1AuthPasswordReset>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetAllauthClientV1AuthPasswordResetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAllauthClientV1AuthPasswordReset>>
>;
export type GetAllauthClientV1AuthPasswordResetQueryError = ErrorType<
  ErrorResponse | ConflictResponse
>;

export function useGetAllauthClientV1AuthPasswordReset<
  TData = Awaited<ReturnType<typeof getAllauthClientV1AuthPasswordReset>>,
  TError = ErrorType<ErrorResponse | ConflictResponse>,
>(
  client: 'app' | 'browser',
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAllauthClientV1AuthPasswordReset>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllauthClientV1AuthPasswordReset>>,
          TError,
          Awaited<ReturnType<typeof getAllauthClientV1AuthPasswordReset>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAllauthClientV1AuthPasswordReset<
  TData = Awaited<ReturnType<typeof getAllauthClientV1AuthPasswordReset>>,
  TError = ErrorType<ErrorResponse | ConflictResponse>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAllauthClientV1AuthPasswordReset>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllauthClientV1AuthPasswordReset>>,
          TError,
          Awaited<ReturnType<typeof getAllauthClientV1AuthPasswordReset>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAllauthClientV1AuthPasswordReset<
  TData = Awaited<ReturnType<typeof getAllauthClientV1AuthPasswordReset>>,
  TError = ErrorType<ErrorResponse | ConflictResponse>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAllauthClientV1AuthPasswordReset>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get password reset information
 */

export function useGetAllauthClientV1AuthPasswordReset<
  TData = Awaited<ReturnType<typeof getAllauthClientV1AuthPasswordReset>>,
  TError = ErrorType<ErrorResponse | ConflictResponse>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAllauthClientV1AuthPasswordReset>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetAllauthClientV1AuthPasswordResetQueryOptions(client, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Perform the password reset, by handing over the password reset key and
the new password. After successfully completing the password reset, the
user is either logged in (in case `ACCOUNT_LOGIN_ON_PASSWORD_RESET` is
`True`), or, the user will need to proceed to the login page.  In case
of the former, a `200` status code is returned, in case of the latter a
401.

 * @summary Reset password
 */
export const postAllauthClientV1AuthPasswordReset = (
  client: 'app' | 'browser',
  resetPasswordBody: BodyType<ResetPasswordBody>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<AuthenticatedByPasswordResponse>(
    {
      url: `/api/_allauth/${client}/v1/auth/password/reset`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: resetPasswordBody,
      signal,
    },
    options,
  );
};

export const getPostAllauthClientV1AuthPasswordResetMutationOptions = <
  TError = ErrorType<ErrorResponse | AuthenticationResponse | ConflictResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postAllauthClientV1AuthPasswordReset>>,
    TError,
    { client: 'app' | 'browser'; data: BodyType<ResetPasswordBody> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postAllauthClientV1AuthPasswordReset>>,
  TError,
  { client: 'app' | 'browser'; data: BodyType<ResetPasswordBody> },
  TContext
> => {
  const mutationKey = ['postAllauthClientV1AuthPasswordReset'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postAllauthClientV1AuthPasswordReset>>,
    { client: 'app' | 'browser'; data: BodyType<ResetPasswordBody> }
  > = props => {
    const { client, data } = props ?? {};

    return postAllauthClientV1AuthPasswordReset(client, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostAllauthClientV1AuthPasswordResetMutationResult = NonNullable<
  Awaited<ReturnType<typeof postAllauthClientV1AuthPasswordReset>>
>;
export type PostAllauthClientV1AuthPasswordResetMutationBody = BodyType<ResetPasswordBody>;
export type PostAllauthClientV1AuthPasswordResetMutationError = ErrorType<
  ErrorResponse | AuthenticationResponse | ConflictResponse
>;

/**
 * @summary Reset password
 */
export const usePostAllauthClientV1AuthPasswordReset = <
  TError = ErrorType<ErrorResponse | AuthenticationResponse | ConflictResponse>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postAllauthClientV1AuthPasswordReset>>,
      TError,
      { client: 'app' | 'browser'; data: BodyType<ResetPasswordBody> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof postAllauthClientV1AuthPasswordReset>>,
  TError,
  { client: 'app' | 'browser'; data: BodyType<ResetPasswordBody> },
  TContext
> => {
  const mutationOptions = getPostAllauthClientV1AuthPasswordResetMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Initiates the third-party provider authentication redirect flow. As calling
this endpoint results in a user facing redirect (302), this call is only
available in a browser, and must be called in a synchronous (non-XHR)
manner.

 * @summary Provider redirect
 */
export const postAllauthBrowserV1AuthProviderRedirect = (
  providerRedirectBody: BodyType<ProviderRedirectBody>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  const formUrlEncoded = new URLSearchParams();
  formUrlEncoded.append(`provider`, providerRedirectBody.provider);
  formUrlEncoded.append(`callback_url`, providerRedirectBody.callback_url);
  formUrlEncoded.append(`process`, providerRedirectBody.process);

  return customInstance<unknown>(
    {
      url: `/api/_allauth/browser/v1/auth/provider/redirect`,
      method: 'POST',
      headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
      data: formUrlEncoded,
      signal,
    },
    options,
  );
};

export const getPostAllauthBrowserV1AuthProviderRedirectMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postAllauthBrowserV1AuthProviderRedirect>>,
    TError,
    { data: BodyType<ProviderRedirectBody> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postAllauthBrowserV1AuthProviderRedirect>>,
  TError,
  { data: BodyType<ProviderRedirectBody> },
  TContext
> => {
  const mutationKey = ['postAllauthBrowserV1AuthProviderRedirect'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postAllauthBrowserV1AuthProviderRedirect>>,
    { data: BodyType<ProviderRedirectBody> }
  > = props => {
    const { data } = props ?? {};

    return postAllauthBrowserV1AuthProviderRedirect(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostAllauthBrowserV1AuthProviderRedirectMutationResult = NonNullable<
  Awaited<ReturnType<typeof postAllauthBrowserV1AuthProviderRedirect>>
>;
export type PostAllauthBrowserV1AuthProviderRedirectMutationBody = BodyType<ProviderRedirectBody>;
export type PostAllauthBrowserV1AuthProviderRedirectMutationError = ErrorType<void>;

/**
 * @summary Provider redirect
 */
export const usePostAllauthBrowserV1AuthProviderRedirect = <
  TError = ErrorType<void>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postAllauthBrowserV1AuthProviderRedirect>>,
      TError,
      { data: BodyType<ProviderRedirectBody> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof postAllauthBrowserV1AuthProviderRedirect>>,
  TError,
  { data: BodyType<ProviderRedirectBody> },
  TContext
> => {
  const mutationOptions = getPostAllauthBrowserV1AuthProviderRedirectMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Authenticates with a third-party provider using provider tokens received
by other means. For example, in case of a mobile app, the authentication
flow runs completely on the device itself, without any interaction with
the API. Then, when the (device) authentication completes and the mobile
app receives an access and/or ID token, it can hand over these tokens
via this endpoint to authenticate on the server.

 * @summary Provider token
 */
export const postAllauthClientV1AuthProviderToken = (
  client: 'app' | 'browser',
  providerTokenBody: BodyType<ProviderTokenBody>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<AuthenticatedResponse>(
    {
      url: `/api/_allauth/${client}/v1/auth/provider/token`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: providerTokenBody,
      signal,
    },
    options,
  );
};

export const getPostAllauthClientV1AuthProviderTokenMutationOptions = <
  TError = ErrorType<ErrorResponse | AuthenticationResponse | ForbiddenResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postAllauthClientV1AuthProviderToken>>,
    TError,
    { client: 'app' | 'browser'; data: BodyType<ProviderTokenBody> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postAllauthClientV1AuthProviderToken>>,
  TError,
  { client: 'app' | 'browser'; data: BodyType<ProviderTokenBody> },
  TContext
> => {
  const mutationKey = ['postAllauthClientV1AuthProviderToken'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postAllauthClientV1AuthProviderToken>>,
    { client: 'app' | 'browser'; data: BodyType<ProviderTokenBody> }
  > = props => {
    const { client, data } = props ?? {};

    return postAllauthClientV1AuthProviderToken(client, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostAllauthClientV1AuthProviderTokenMutationResult = NonNullable<
  Awaited<ReturnType<typeof postAllauthClientV1AuthProviderToken>>
>;
export type PostAllauthClientV1AuthProviderTokenMutationBody = BodyType<ProviderTokenBody>;
export type PostAllauthClientV1AuthProviderTokenMutationError = ErrorType<
  ErrorResponse | AuthenticationResponse | ForbiddenResponse
>;

/**
 * @summary Provider token
 */
export const usePostAllauthClientV1AuthProviderToken = <
  TError = ErrorType<ErrorResponse | AuthenticationResponse | ForbiddenResponse>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postAllauthClientV1AuthProviderToken>>,
      TError,
      { client: 'app' | 'browser'; data: BodyType<ProviderTokenBody> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof postAllauthClientV1AuthProviderToken>>,
  TError,
  { client: 'app' | 'browser'; data: BodyType<ProviderTokenBody> },
  TContext
> => {
  const mutationOptions = getPostAllauthClientV1AuthProviderTokenMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * If, while signing up using a third-party provider account, there is
insufficient information received from the provider to automatically
complete the signup process, an additional step is needed to complete
the missing data before the user is fully signed up and authenticated.
The information available so far, such as the pending provider account,
can be retrieved via this endpoint.

 * @summary Provider signup information
 */
export const getAllauthClientV1AuthProviderSignup = (
  client: 'app' | 'browser',
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<ProviderSignupResponse>(
    { url: `/api/_allauth/${client}/v1/auth/provider/signup`, method: 'GET', signal },
    options,
  );
};

export const getGetAllauthClientV1AuthProviderSignupQueryKey = (client?: 'app' | 'browser') => {
  return [`/api/_allauth/${client}/v1/auth/provider/signup`] as const;
};

export const getGetAllauthClientV1AuthProviderSignupQueryOptions = <
  TData = Awaited<ReturnType<typeof getAllauthClientV1AuthProviderSignup>>,
  TError = ErrorType<ConflictResponse>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAllauthClientV1AuthProviderSignup>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetAllauthClientV1AuthProviderSignupQueryKey(client);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getAllauthClientV1AuthProviderSignup>>
  > = ({ signal }) => getAllauthClientV1AuthProviderSignup(client, requestOptions, signal);

  return { queryKey, queryFn, enabled: !!client, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getAllauthClientV1AuthProviderSignup>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetAllauthClientV1AuthProviderSignupQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAllauthClientV1AuthProviderSignup>>
>;
export type GetAllauthClientV1AuthProviderSignupQueryError = ErrorType<ConflictResponse>;

export function useGetAllauthClientV1AuthProviderSignup<
  TData = Awaited<ReturnType<typeof getAllauthClientV1AuthProviderSignup>>,
  TError = ErrorType<ConflictResponse>,
>(
  client: 'app' | 'browser',
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAllauthClientV1AuthProviderSignup>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllauthClientV1AuthProviderSignup>>,
          TError,
          Awaited<ReturnType<typeof getAllauthClientV1AuthProviderSignup>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAllauthClientV1AuthProviderSignup<
  TData = Awaited<ReturnType<typeof getAllauthClientV1AuthProviderSignup>>,
  TError = ErrorType<ConflictResponse>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAllauthClientV1AuthProviderSignup>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllauthClientV1AuthProviderSignup>>,
          TError,
          Awaited<ReturnType<typeof getAllauthClientV1AuthProviderSignup>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAllauthClientV1AuthProviderSignup<
  TData = Awaited<ReturnType<typeof getAllauthClientV1AuthProviderSignup>>,
  TError = ErrorType<ConflictResponse>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAllauthClientV1AuthProviderSignup>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Provider signup information
 */

export function useGetAllauthClientV1AuthProviderSignup<
  TData = Awaited<ReturnType<typeof getAllauthClientV1AuthProviderSignup>>,
  TError = ErrorType<ConflictResponse>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAllauthClientV1AuthProviderSignup>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetAllauthClientV1AuthProviderSignupQueryOptions(client, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * If, while signing up using a third-party provider account, there is
insufficient information received from the provider to automatically
complete the signup process, an additional step is needed to complete
the missing data before the user is fully signed up and authenticated.

 * @summary Provider signup
 */
export const postAllauthClientV1AuthProviderSignup = (
  client: 'app' | 'browser',
  providerSignupBody: BodyType<ProviderSignupBody>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<AuthenticatedResponse>(
    {
      url: `/api/_allauth/${client}/v1/auth/provider/signup`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: providerSignupBody,
      signal,
    },
    options,
  );
};

export const getPostAllauthClientV1AuthProviderSignupMutationOptions = <
  TError = ErrorType<ErrorResponse | AuthenticationResponse | ForbiddenResponse | ConflictResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postAllauthClientV1AuthProviderSignup>>,
    TError,
    { client: 'app' | 'browser'; data: BodyType<ProviderSignupBody> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postAllauthClientV1AuthProviderSignup>>,
  TError,
  { client: 'app' | 'browser'; data: BodyType<ProviderSignupBody> },
  TContext
> => {
  const mutationKey = ['postAllauthClientV1AuthProviderSignup'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postAllauthClientV1AuthProviderSignup>>,
    { client: 'app' | 'browser'; data: BodyType<ProviderSignupBody> }
  > = props => {
    const { client, data } = props ?? {};

    return postAllauthClientV1AuthProviderSignup(client, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostAllauthClientV1AuthProviderSignupMutationResult = NonNullable<
  Awaited<ReturnType<typeof postAllauthClientV1AuthProviderSignup>>
>;
export type PostAllauthClientV1AuthProviderSignupMutationBody = BodyType<ProviderSignupBody>;
export type PostAllauthClientV1AuthProviderSignupMutationError = ErrorType<
  ErrorResponse | AuthenticationResponse | ForbiddenResponse | ConflictResponse
>;

/**
 * @summary Provider signup
 */
export const usePostAllauthClientV1AuthProviderSignup = <
  TError = ErrorType<ErrorResponse | AuthenticationResponse | ForbiddenResponse | ConflictResponse>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postAllauthClientV1AuthProviderSignup>>,
      TError,
      { client: 'app' | 'browser'; data: BodyType<ProviderSignupBody> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof postAllauthClientV1AuthProviderSignup>>,
  TError,
  { client: 'app' | 'browser'; data: BodyType<ProviderSignupBody> },
  TContext
> => {
  const mutationOptions = getPostAllauthClientV1AuthProviderSignupMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * If, during authentication,  a response with status 401 is encountered where one of the pending
flows has ID `mfa_authenticate`, that indicates that the Two-Factor Authentication stage needs to
be completed.

 * @summary Two-factor authentication
 */
export const postAllauthClientV1Auth2faAuthenticate = (
  client: 'app' | 'browser',
  mFAAuthenticateBody: BodyType<MFAAuthenticateBody>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<AuthenticatedByPasswordAnd2FAResponse>(
    {
      url: `/api/_allauth/${client}/v1/auth/2fa/authenticate`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: mFAAuthenticateBody,
      signal,
    },
    options,
  );
};

export const getPostAllauthClientV1Auth2faAuthenticateMutationOptions = <
  TError = ErrorType<ErrorResponse | AuthenticationResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postAllauthClientV1Auth2faAuthenticate>>,
    TError,
    { client: 'app' | 'browser'; data: BodyType<MFAAuthenticateBody> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postAllauthClientV1Auth2faAuthenticate>>,
  TError,
  { client: 'app' | 'browser'; data: BodyType<MFAAuthenticateBody> },
  TContext
> => {
  const mutationKey = ['postAllauthClientV1Auth2faAuthenticate'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postAllauthClientV1Auth2faAuthenticate>>,
    { client: 'app' | 'browser'; data: BodyType<MFAAuthenticateBody> }
  > = props => {
    const { client, data } = props ?? {};

    return postAllauthClientV1Auth2faAuthenticate(client, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostAllauthClientV1Auth2faAuthenticateMutationResult = NonNullable<
  Awaited<ReturnType<typeof postAllauthClientV1Auth2faAuthenticate>>
>;
export type PostAllauthClientV1Auth2faAuthenticateMutationBody = BodyType<MFAAuthenticateBody>;
export type PostAllauthClientV1Auth2faAuthenticateMutationError = ErrorType<
  ErrorResponse | AuthenticationResponse
>;

/**
 * @summary Two-factor authentication
 */
export const usePostAllauthClientV1Auth2faAuthenticate = <
  TError = ErrorType<ErrorResponse | AuthenticationResponse>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postAllauthClientV1Auth2faAuthenticate>>,
      TError,
      { client: 'app' | 'browser'; data: BodyType<MFAAuthenticateBody> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof postAllauthClientV1Auth2faAuthenticate>>,
  TError,
  { client: 'app' | 'browser'; data: BodyType<MFAAuthenticateBody> },
  TContext
> => {
  const mutationOptions = getPostAllauthClientV1Auth2faAuthenticateMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * In order to safeguard the account, some actions require the user to be
recently authenticated.  If you try to perform such an action without
having been recently authenticated, a `401` status is returned, listing
flows that can be performed to reauthenticate. One such flow is the flow
with ID `mfa_reauthenticate`, which allows for the user to input an
authenticator code (e.g. TOTP or recovery code). This is the endpoint
related towards that flow.

 * @summary Reauthenticate using 2FA
 */
export const postAllauthClientV1Auth2faReauthenticate = (
  client: 'app' | 'browser',
  mFAAuthenticateBody: BodyType<MFAAuthenticateBody>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<AuthenticatedByPasswordAnd2FAResponse>(
    {
      url: `/api/_allauth/${client}/v1/auth/2fa/reauthenticate`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: mFAAuthenticateBody,
      signal,
    },
    options,
  );
};

export const getPostAllauthClientV1Auth2faReauthenticateMutationOptions = <
  TError = ErrorType<ErrorResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postAllauthClientV1Auth2faReauthenticate>>,
    TError,
    { client: 'app' | 'browser'; data: BodyType<MFAAuthenticateBody> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postAllauthClientV1Auth2faReauthenticate>>,
  TError,
  { client: 'app' | 'browser'; data: BodyType<MFAAuthenticateBody> },
  TContext
> => {
  const mutationKey = ['postAllauthClientV1Auth2faReauthenticate'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postAllauthClientV1Auth2faReauthenticate>>,
    { client: 'app' | 'browser'; data: BodyType<MFAAuthenticateBody> }
  > = props => {
    const { client, data } = props ?? {};

    return postAllauthClientV1Auth2faReauthenticate(client, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostAllauthClientV1Auth2faReauthenticateMutationResult = NonNullable<
  Awaited<ReturnType<typeof postAllauthClientV1Auth2faReauthenticate>>
>;
export type PostAllauthClientV1Auth2faReauthenticateMutationBody = BodyType<MFAAuthenticateBody>;
export type PostAllauthClientV1Auth2faReauthenticateMutationError = ErrorType<ErrorResponse>;

/**
 * @summary Reauthenticate using 2FA
 */
export const usePostAllauthClientV1Auth2faReauthenticate = <
  TError = ErrorType<ErrorResponse>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postAllauthClientV1Auth2faReauthenticate>>,
      TError,
      { client: 'app' | 'browser'; data: BodyType<MFAAuthenticateBody> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof postAllauthClientV1Auth2faReauthenticate>>,
  TError,
  { client: 'app' | 'browser'; data: BodyType<MFAAuthenticateBody> },
  TContext
> => {
  const mutationOptions = getPostAllauthClientV1Auth2faReauthenticateMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * If "Trust this browser?" is enabled (`MFA_TRUST_ENABLED`), the
`mfa_trust` flow activates after the user completes the MFA
authentication flow, offering to skip MFA for this particular
browser. This endpoint is used to complete the `mfa_trust` flow.

 * @summary Trust this browser
 */
export const postAllauthBrowserV1Auth2faTrust = (
  mFATrustBody: BodyType<MFATrustBody>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<AuthenticatedByPasswordAnd2FAResponse>(
    {
      url: `/api/_allauth/browser/v1/auth/2fa/trust`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: mFATrustBody,
      signal,
    },
    options,
  );
};

export const getPostAllauthBrowserV1Auth2faTrustMutationOptions = <
  TError = ErrorType<ErrorResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postAllauthBrowserV1Auth2faTrust>>,
    TError,
    { data: BodyType<MFATrustBody> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postAllauthBrowserV1Auth2faTrust>>,
  TError,
  { data: BodyType<MFATrustBody> },
  TContext
> => {
  const mutationKey = ['postAllauthBrowserV1Auth2faTrust'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postAllauthBrowserV1Auth2faTrust>>,
    { data: BodyType<MFATrustBody> }
  > = props => {
    const { data } = props ?? {};

    return postAllauthBrowserV1Auth2faTrust(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostAllauthBrowserV1Auth2faTrustMutationResult = NonNullable<
  Awaited<ReturnType<typeof postAllauthBrowserV1Auth2faTrust>>
>;
export type PostAllauthBrowserV1Auth2faTrustMutationBody = BodyType<MFATrustBody>;
export type PostAllauthBrowserV1Auth2faTrustMutationError = ErrorType<ErrorResponse>;

/**
 * @summary Trust this browser
 */
export const usePostAllauthBrowserV1Auth2faTrust = <
  TError = ErrorType<ErrorResponse>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postAllauthBrowserV1Auth2faTrust>>,
      TError,
      { data: BodyType<MFATrustBody> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof postAllauthBrowserV1Auth2faTrust>>,
  TError,
  { data: BodyType<MFATrustBody> },
  TContext
> => {
  const mutationOptions = getPostAllauthBrowserV1Auth2faTrustMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Returns the WebAuthn credential request options, that can be
processed using `parseRequestOptionsFromJSON()` on the frontend.

 * @summary Get WebAuthn credential request options for 2FA
 */
export const getAllauthClientV1AuthWebauthnAuthenticate = (
  client: 'app' | 'browser',
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<WebAuthnRequestOptionsResponseResponse>(
    { url: `/api/_allauth/${client}/v1/auth/webauthn/authenticate`, method: 'GET', signal },
    options,
  );
};

export const getGetAllauthClientV1AuthWebauthnAuthenticateQueryKey = (
  client?: 'app' | 'browser',
) => {
  return [`/api/_allauth/${client}/v1/auth/webauthn/authenticate`] as const;
};

export const getGetAllauthClientV1AuthWebauthnAuthenticateQueryOptions = <
  TData = Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnAuthenticate>>,
  TError = ErrorType<unknown>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnAuthenticate>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetAllauthClientV1AuthWebauthnAuthenticateQueryKey(client);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnAuthenticate>>
  > = ({ signal }) => getAllauthClientV1AuthWebauthnAuthenticate(client, requestOptions, signal);

  return { queryKey, queryFn, enabled: !!client, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnAuthenticate>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetAllauthClientV1AuthWebauthnAuthenticateQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnAuthenticate>>
>;
export type GetAllauthClientV1AuthWebauthnAuthenticateQueryError = ErrorType<unknown>;

export function useGetAllauthClientV1AuthWebauthnAuthenticate<
  TData = Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnAuthenticate>>,
  TError = ErrorType<unknown>,
>(
  client: 'app' | 'browser',
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnAuthenticate>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnAuthenticate>>,
          TError,
          Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnAuthenticate>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAllauthClientV1AuthWebauthnAuthenticate<
  TData = Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnAuthenticate>>,
  TError = ErrorType<unknown>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnAuthenticate>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnAuthenticate>>,
          TError,
          Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnAuthenticate>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAllauthClientV1AuthWebauthnAuthenticate<
  TData = Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnAuthenticate>>,
  TError = ErrorType<unknown>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnAuthenticate>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get WebAuthn credential request options for 2FA
 */

export function useGetAllauthClientV1AuthWebauthnAuthenticate<
  TData = Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnAuthenticate>>,
  TError = ErrorType<unknown>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnAuthenticate>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetAllauthClientV1AuthWebauthnAuthenticateQueryOptions(client, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Perform Two-Factor Authentication using a WebAuthn credential.

 * @summary Perform 2FA using WebAuthn
 */
export const postAllauthClientV1AuthWebauthnAuthenticate = (
  client: 'app' | 'browser',
  authenticateWebAuthnBody: BodyType<AuthenticateWebAuthnBody>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<AuthenticatedResponse>(
    {
      url: `/api/_allauth/${client}/v1/auth/webauthn/authenticate`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: authenticateWebAuthnBody,
      signal,
    },
    options,
  );
};

export const getPostAllauthClientV1AuthWebauthnAuthenticateMutationOptions = <
  TError = ErrorType<ErrorResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postAllauthClientV1AuthWebauthnAuthenticate>>,
    TError,
    { client: 'app' | 'browser'; data: BodyType<AuthenticateWebAuthnBody> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postAllauthClientV1AuthWebauthnAuthenticate>>,
  TError,
  { client: 'app' | 'browser'; data: BodyType<AuthenticateWebAuthnBody> },
  TContext
> => {
  const mutationKey = ['postAllauthClientV1AuthWebauthnAuthenticate'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postAllauthClientV1AuthWebauthnAuthenticate>>,
    { client: 'app' | 'browser'; data: BodyType<AuthenticateWebAuthnBody> }
  > = props => {
    const { client, data } = props ?? {};

    return postAllauthClientV1AuthWebauthnAuthenticate(client, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostAllauthClientV1AuthWebauthnAuthenticateMutationResult = NonNullable<
  Awaited<ReturnType<typeof postAllauthClientV1AuthWebauthnAuthenticate>>
>;
export type PostAllauthClientV1AuthWebauthnAuthenticateMutationBody =
  BodyType<AuthenticateWebAuthnBody>;
export type PostAllauthClientV1AuthWebauthnAuthenticateMutationError = ErrorType<ErrorResponse>;

/**
 * @summary Perform 2FA using WebAuthn
 */
export const usePostAllauthClientV1AuthWebauthnAuthenticate = <
  TError = ErrorType<ErrorResponse>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postAllauthClientV1AuthWebauthnAuthenticate>>,
      TError,
      { client: 'app' | 'browser'; data: BodyType<AuthenticateWebAuthnBody> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof postAllauthClientV1AuthWebauthnAuthenticate>>,
  TError,
  { client: 'app' | 'browser'; data: BodyType<AuthenticateWebAuthnBody> },
  TContext
> => {
  const mutationOptions = getPostAllauthClientV1AuthWebauthnAuthenticateMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Returns the WebAuthn credential request options, that can be
processed using `parseRequestOptionsFromJSON()` on the frontend.

 * @summary Get WebAuthn credential request options for reauthentication
 */
export const getAllauthClientV1AuthWebauthnReauthenticate = (
  client: 'app' | 'browser',
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<WebAuthnRequestOptionsResponseResponse>(
    { url: `/api/_allauth/${client}/v1/auth/webauthn/reauthenticate`, method: 'GET', signal },
    options,
  );
};

export const getGetAllauthClientV1AuthWebauthnReauthenticateQueryKey = (
  client?: 'app' | 'browser',
) => {
  return [`/api/_allauth/${client}/v1/auth/webauthn/reauthenticate`] as const;
};

export const getGetAllauthClientV1AuthWebauthnReauthenticateQueryOptions = <
  TData = Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnReauthenticate>>,
  TError = ErrorType<unknown>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnReauthenticate>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetAllauthClientV1AuthWebauthnReauthenticateQueryKey(client);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnReauthenticate>>
  > = ({ signal }) => getAllauthClientV1AuthWebauthnReauthenticate(client, requestOptions, signal);

  return { queryKey, queryFn, enabled: !!client, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnReauthenticate>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetAllauthClientV1AuthWebauthnReauthenticateQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnReauthenticate>>
>;
export type GetAllauthClientV1AuthWebauthnReauthenticateQueryError = ErrorType<unknown>;

export function useGetAllauthClientV1AuthWebauthnReauthenticate<
  TData = Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnReauthenticate>>,
  TError = ErrorType<unknown>,
>(
  client: 'app' | 'browser',
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnReauthenticate>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnReauthenticate>>,
          TError,
          Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnReauthenticate>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAllauthClientV1AuthWebauthnReauthenticate<
  TData = Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnReauthenticate>>,
  TError = ErrorType<unknown>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnReauthenticate>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnReauthenticate>>,
          TError,
          Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnReauthenticate>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAllauthClientV1AuthWebauthnReauthenticate<
  TData = Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnReauthenticate>>,
  TError = ErrorType<unknown>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnReauthenticate>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get WebAuthn credential request options for reauthentication
 */

export function useGetAllauthClientV1AuthWebauthnReauthenticate<
  TData = Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnReauthenticate>>,
  TError = ErrorType<unknown>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnReauthenticate>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetAllauthClientV1AuthWebauthnReauthenticateQueryOptions(client, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Reauthenticate the user using a WebAuthn credential.

 * @summary Reauthenticate using WebAuthn
 */
export const postAllauthClientV1AuthWebauthnReauthenticate = (
  client: 'app' | 'browser',
  reauthenticateWebAuthnBody: BodyType<ReauthenticateWebAuthnBody>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<AuthenticatedResponse>(
    {
      url: `/api/_allauth/${client}/v1/auth/webauthn/reauthenticate`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: reauthenticateWebAuthnBody,
      signal,
    },
    options,
  );
};

export const getPostAllauthClientV1AuthWebauthnReauthenticateMutationOptions = <
  TError = ErrorType<ErrorResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postAllauthClientV1AuthWebauthnReauthenticate>>,
    TError,
    { client: 'app' | 'browser'; data: BodyType<ReauthenticateWebAuthnBody> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postAllauthClientV1AuthWebauthnReauthenticate>>,
  TError,
  { client: 'app' | 'browser'; data: BodyType<ReauthenticateWebAuthnBody> },
  TContext
> => {
  const mutationKey = ['postAllauthClientV1AuthWebauthnReauthenticate'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postAllauthClientV1AuthWebauthnReauthenticate>>,
    { client: 'app' | 'browser'; data: BodyType<ReauthenticateWebAuthnBody> }
  > = props => {
    const { client, data } = props ?? {};

    return postAllauthClientV1AuthWebauthnReauthenticate(client, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostAllauthClientV1AuthWebauthnReauthenticateMutationResult = NonNullable<
  Awaited<ReturnType<typeof postAllauthClientV1AuthWebauthnReauthenticate>>
>;
export type PostAllauthClientV1AuthWebauthnReauthenticateMutationBody =
  BodyType<ReauthenticateWebAuthnBody>;
export type PostAllauthClientV1AuthWebauthnReauthenticateMutationError = ErrorType<ErrorResponse>;

/**
 * @summary Reauthenticate using WebAuthn
 */
export const usePostAllauthClientV1AuthWebauthnReauthenticate = <
  TError = ErrorType<ErrorResponse>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postAllauthClientV1AuthWebauthnReauthenticate>>,
      TError,
      { client: 'app' | 'browser'; data: BodyType<ReauthenticateWebAuthnBody> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof postAllauthClientV1AuthWebauthnReauthenticate>>,
  TError,
  { client: 'app' | 'browser'; data: BodyType<ReauthenticateWebAuthnBody> },
  TContext
> => {
  const mutationOptions = getPostAllauthClientV1AuthWebauthnReauthenticateMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Returns the WebAuthn credential request options, that can be
processed using `parseRequestOptionsFromJSON()` on the frontend.

 * @summary Get WebAuthn credential request options for login
 */
export const getAllauthClientV1AuthWebauthnLogin = (
  client: 'app' | 'browser',
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<WebAuthnRequestOptionsResponseResponse>(
    { url: `/api/_allauth/${client}/v1/auth/webauthn/login`, method: 'GET', signal },
    options,
  );
};

export const getGetAllauthClientV1AuthWebauthnLoginQueryKey = (client?: 'app' | 'browser') => {
  return [`/api/_allauth/${client}/v1/auth/webauthn/login`] as const;
};

export const getGetAllauthClientV1AuthWebauthnLoginQueryOptions = <
  TData = Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnLogin>>,
  TError = ErrorType<unknown>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnLogin>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAllauthClientV1AuthWebauthnLoginQueryKey(client);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnLogin>>> = ({
    signal,
  }) => getAllauthClientV1AuthWebauthnLogin(client, requestOptions, signal);

  return { queryKey, queryFn, enabled: !!client, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnLogin>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetAllauthClientV1AuthWebauthnLoginQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnLogin>>
>;
export type GetAllauthClientV1AuthWebauthnLoginQueryError = ErrorType<unknown>;

export function useGetAllauthClientV1AuthWebauthnLogin<
  TData = Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnLogin>>,
  TError = ErrorType<unknown>,
>(
  client: 'app' | 'browser',
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnLogin>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnLogin>>,
          TError,
          Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnLogin>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAllauthClientV1AuthWebauthnLogin<
  TData = Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnLogin>>,
  TError = ErrorType<unknown>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnLogin>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnLogin>>,
          TError,
          Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnLogin>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAllauthClientV1AuthWebauthnLogin<
  TData = Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnLogin>>,
  TError = ErrorType<unknown>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnLogin>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get WebAuthn credential request options for login
 */

export function useGetAllauthClientV1AuthWebauthnLogin<
  TData = Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnLogin>>,
  TError = ErrorType<unknown>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnLogin>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetAllauthClientV1AuthWebauthnLoginQueryOptions(client, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Login using a WebAuthn credential (Passkey). Both 200 and 401 can be
expected after a successful request.  The 401 can, for example, occur
when the credential passed was valid, but the email attached to the
account still requires verification.

 * @summary Login using WebAuthn
 */
export const postAllauthClientV1AuthWebauthnLogin = (
  client: 'app' | 'browser',
  loginWebAuthnBody: BodyType<LoginWebAuthnBody>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<AuthenticatedResponse>(
    {
      url: `/api/_allauth/${client}/v1/auth/webauthn/login`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: loginWebAuthnBody,
      signal,
    },
    options,
  );
};

export const getPostAllauthClientV1AuthWebauthnLoginMutationOptions = <
  TError = ErrorType<ErrorResponse | AuthenticationResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postAllauthClientV1AuthWebauthnLogin>>,
    TError,
    { client: 'app' | 'browser'; data: BodyType<LoginWebAuthnBody> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postAllauthClientV1AuthWebauthnLogin>>,
  TError,
  { client: 'app' | 'browser'; data: BodyType<LoginWebAuthnBody> },
  TContext
> => {
  const mutationKey = ['postAllauthClientV1AuthWebauthnLogin'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postAllauthClientV1AuthWebauthnLogin>>,
    { client: 'app' | 'browser'; data: BodyType<LoginWebAuthnBody> }
  > = props => {
    const { client, data } = props ?? {};

    return postAllauthClientV1AuthWebauthnLogin(client, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostAllauthClientV1AuthWebauthnLoginMutationResult = NonNullable<
  Awaited<ReturnType<typeof postAllauthClientV1AuthWebauthnLogin>>
>;
export type PostAllauthClientV1AuthWebauthnLoginMutationBody = BodyType<LoginWebAuthnBody>;
export type PostAllauthClientV1AuthWebauthnLoginMutationError = ErrorType<
  ErrorResponse | AuthenticationResponse
>;

/**
 * @summary Login using WebAuthn
 */
export const usePostAllauthClientV1AuthWebauthnLogin = <
  TError = ErrorType<ErrorResponse | AuthenticationResponse>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postAllauthClientV1AuthWebauthnLogin>>,
      TError,
      { client: 'app' | 'browser'; data: BodyType<LoginWebAuthnBody> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof postAllauthClientV1AuthWebauthnLogin>>,
  TError,
  { client: 'app' | 'browser'; data: BodyType<LoginWebAuthnBody> },
  TContext
> => {
  const mutationOptions = getPostAllauthClientV1AuthWebauthnLoginMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * You initiate the passkey signup flow by inputting (`POST`) the required properties (e.g. email)
similar to the regular account signup, except that the `password` is to be left out.
The user will then be required to verify the email address, after which WebAuthn credential
creation options can be retrieved (`GET`) and used to actually complete (`PUT`) the flow.

 * @summary Initiate the passkey signup flow
 */
export const postAllauthClientV1AuthWebauthnSignup = (
  client: 'app' | 'browser',
  passkeySignupBody: BodyType<PasskeySignupBody>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<unknown>(
    {
      url: `/api/_allauth/${client}/v1/auth/webauthn/signup`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: passkeySignupBody,
      signal,
    },
    options,
  );
};

export const getPostAllauthClientV1AuthWebauthnSignupMutationOptions = <
  TError = ErrorType<ErrorResponse | AuthenticationResponse | ForbiddenResponse | ConflictResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postAllauthClientV1AuthWebauthnSignup>>,
    TError,
    { client: 'app' | 'browser'; data: BodyType<PasskeySignupBody> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postAllauthClientV1AuthWebauthnSignup>>,
  TError,
  { client: 'app' | 'browser'; data: BodyType<PasskeySignupBody> },
  TContext
> => {
  const mutationKey = ['postAllauthClientV1AuthWebauthnSignup'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postAllauthClientV1AuthWebauthnSignup>>,
    { client: 'app' | 'browser'; data: BodyType<PasskeySignupBody> }
  > = props => {
    const { client, data } = props ?? {};

    return postAllauthClientV1AuthWebauthnSignup(client, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostAllauthClientV1AuthWebauthnSignupMutationResult = NonNullable<
  Awaited<ReturnType<typeof postAllauthClientV1AuthWebauthnSignup>>
>;
export type PostAllauthClientV1AuthWebauthnSignupMutationBody = BodyType<PasskeySignupBody>;
export type PostAllauthClientV1AuthWebauthnSignupMutationError = ErrorType<
  ErrorResponse | AuthenticationResponse | ForbiddenResponse | ConflictResponse
>;

/**
 * @summary Initiate the passkey signup flow
 */
export const usePostAllauthClientV1AuthWebauthnSignup = <
  TError = ErrorType<ErrorResponse | AuthenticationResponse | ForbiddenResponse | ConflictResponse>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postAllauthClientV1AuthWebauthnSignup>>,
      TError,
      { client: 'app' | 'browser'; data: BodyType<PasskeySignupBody> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof postAllauthClientV1AuthWebauthnSignup>>,
  TError,
  { client: 'app' | 'browser'; data: BodyType<PasskeySignupBody> },
  TContext
> => {
  const mutationOptions = getPostAllauthClientV1AuthWebauthnSignupMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Returns the WebAuthn credential request options, that can be
processed using `parseRequestOptionsFromJSON()` on the frontend.

 * @summary Get passkey credential request options
 */
export const getAllauthClientV1AuthWebauthnSignup = (
  client: 'app' | 'browser',
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<WebAuthnRequestOptionsResponseResponse>(
    { url: `/api/_allauth/${client}/v1/auth/webauthn/signup`, method: 'GET', signal },
    options,
  );
};

export const getGetAllauthClientV1AuthWebauthnSignupQueryKey = (client?: 'app' | 'browser') => {
  return [`/api/_allauth/${client}/v1/auth/webauthn/signup`] as const;
};

export const getGetAllauthClientV1AuthWebauthnSignupQueryOptions = <
  TData = Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnSignup>>,
  TError = ErrorType<ConflictResponse>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnSignup>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetAllauthClientV1AuthWebauthnSignupQueryKey(client);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnSignup>>
  > = ({ signal }) => getAllauthClientV1AuthWebauthnSignup(client, requestOptions, signal);

  return { queryKey, queryFn, enabled: !!client, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnSignup>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetAllauthClientV1AuthWebauthnSignupQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnSignup>>
>;
export type GetAllauthClientV1AuthWebauthnSignupQueryError = ErrorType<ConflictResponse>;

export function useGetAllauthClientV1AuthWebauthnSignup<
  TData = Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnSignup>>,
  TError = ErrorType<ConflictResponse>,
>(
  client: 'app' | 'browser',
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnSignup>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnSignup>>,
          TError,
          Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnSignup>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAllauthClientV1AuthWebauthnSignup<
  TData = Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnSignup>>,
  TError = ErrorType<ConflictResponse>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnSignup>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnSignup>>,
          TError,
          Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnSignup>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAllauthClientV1AuthWebauthnSignup<
  TData = Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnSignup>>,
  TError = ErrorType<ConflictResponse>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnSignup>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get passkey credential request options
 */

export function useGetAllauthClientV1AuthWebauthnSignup<
  TData = Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnSignup>>,
  TError = ErrorType<ConflictResponse>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAllauthClientV1AuthWebauthnSignup>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetAllauthClientV1AuthWebauthnSignupQueryOptions(client, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Complete the passkey signup flow by handing over the WebAuthn credential.

 * @summary Complete the passkey signup flow
 */
export const putAllauthClientV1AuthWebauthnSignup = (
  client: 'app' | 'browser',
  addWebAuthnAuthenticatorBody: BodyType<AddWebAuthnAuthenticatorBody>,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<AuthenticatedResponse>(
    {
      url: `/api/_allauth/${client}/v1/auth/webauthn/signup`,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      data: addWebAuthnAuthenticatorBody,
    },
    options,
  );
};

export const getPutAllauthClientV1AuthWebauthnSignupMutationOptions = <
  TError = ErrorType<ErrorResponse | AuthenticationResponse | ConflictResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof putAllauthClientV1AuthWebauthnSignup>>,
    TError,
    { client: 'app' | 'browser'; data: BodyType<AddWebAuthnAuthenticatorBody> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof putAllauthClientV1AuthWebauthnSignup>>,
  TError,
  { client: 'app' | 'browser'; data: BodyType<AddWebAuthnAuthenticatorBody> },
  TContext
> => {
  const mutationKey = ['putAllauthClientV1AuthWebauthnSignup'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof putAllauthClientV1AuthWebauthnSignup>>,
    { client: 'app' | 'browser'; data: BodyType<AddWebAuthnAuthenticatorBody> }
  > = props => {
    const { client, data } = props ?? {};

    return putAllauthClientV1AuthWebauthnSignup(client, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PutAllauthClientV1AuthWebauthnSignupMutationResult = NonNullable<
  Awaited<ReturnType<typeof putAllauthClientV1AuthWebauthnSignup>>
>;
export type PutAllauthClientV1AuthWebauthnSignupMutationBody =
  BodyType<AddWebAuthnAuthenticatorBody>;
export type PutAllauthClientV1AuthWebauthnSignupMutationError = ErrorType<
  ErrorResponse | AuthenticationResponse | ConflictResponse
>;

/**
 * @summary Complete the passkey signup flow
 */
export const usePutAllauthClientV1AuthWebauthnSignup = <
  TError = ErrorType<ErrorResponse | AuthenticationResponse | ConflictResponse>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof putAllauthClientV1AuthWebauthnSignup>>,
      TError,
      { client: 'app' | 'browser'; data: BodyType<AddWebAuthnAuthenticatorBody> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof putAllauthClientV1AuthWebauthnSignup>>,
  TError,
  { client: 'app' | 'browser'; data: BodyType<AddWebAuthnAuthenticatorBody> },
  TContext
> => {
  const mutationOptions = getPutAllauthClientV1AuthWebauthnSignupMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Request a "special" login code that is sent to the user by email.

 * @summary Request login code
 */
export const postAllauthClientV1AuthCodeRequest = (
  client: 'app' | 'browser',
  requestLoginCodeBody: BodyType<RequestLoginCodeBody>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<unknown>(
    {
      url: `/api/_allauth/${client}/v1/auth/code/request`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: requestLoginCodeBody,
      signal,
    },
    options,
  );
};

export const getPostAllauthClientV1AuthCodeRequestMutationOptions = <
  TError = ErrorType<ErrorResponse | AuthenticationResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postAllauthClientV1AuthCodeRequest>>,
    TError,
    { client: 'app' | 'browser'; data: BodyType<RequestLoginCodeBody> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postAllauthClientV1AuthCodeRequest>>,
  TError,
  { client: 'app' | 'browser'; data: BodyType<RequestLoginCodeBody> },
  TContext
> => {
  const mutationKey = ['postAllauthClientV1AuthCodeRequest'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postAllauthClientV1AuthCodeRequest>>,
    { client: 'app' | 'browser'; data: BodyType<RequestLoginCodeBody> }
  > = props => {
    const { client, data } = props ?? {};

    return postAllauthClientV1AuthCodeRequest(client, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostAllauthClientV1AuthCodeRequestMutationResult = NonNullable<
  Awaited<ReturnType<typeof postAllauthClientV1AuthCodeRequest>>
>;
export type PostAllauthClientV1AuthCodeRequestMutationBody = BodyType<RequestLoginCodeBody>;
export type PostAllauthClientV1AuthCodeRequestMutationError = ErrorType<
  ErrorResponse | AuthenticationResponse
>;

/**
 * @summary Request login code
 */
export const usePostAllauthClientV1AuthCodeRequest = <
  TError = ErrorType<ErrorResponse | AuthenticationResponse>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postAllauthClientV1AuthCodeRequest>>,
      TError,
      { client: 'app' | 'browser'; data: BodyType<RequestLoginCodeBody> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof postAllauthClientV1AuthCodeRequest>>,
  TError,
  { client: 'app' | 'browser'; data: BodyType<RequestLoginCodeBody> },
  TContext
> => {
  const mutationOptions = getPostAllauthClientV1AuthCodeRequestMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Use this endpoint to pass along the received "special" login code.

 * @summary Confirm login code
 */
export const postAllauthClientV1AuthCodeConfirm = (
  client: 'app' | 'browser',
  confirmLoginCodeBody: BodyType<ConfirmLoginCodeBody>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<AuthenticatedByCodeResponse>(
    {
      url: `/api/_allauth/${client}/v1/auth/code/confirm`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: confirmLoginCodeBody,
      signal,
    },
    options,
  );
};

export const getPostAllauthClientV1AuthCodeConfirmMutationOptions = <
  TError = ErrorType<ErrorResponse | AuthenticationResponse | ConflictResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postAllauthClientV1AuthCodeConfirm>>,
    TError,
    { client: 'app' | 'browser'; data: BodyType<ConfirmLoginCodeBody> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postAllauthClientV1AuthCodeConfirm>>,
  TError,
  { client: 'app' | 'browser'; data: BodyType<ConfirmLoginCodeBody> },
  TContext
> => {
  const mutationKey = ['postAllauthClientV1AuthCodeConfirm'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postAllauthClientV1AuthCodeConfirm>>,
    { client: 'app' | 'browser'; data: BodyType<ConfirmLoginCodeBody> }
  > = props => {
    const { client, data } = props ?? {};

    return postAllauthClientV1AuthCodeConfirm(client, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostAllauthClientV1AuthCodeConfirmMutationResult = NonNullable<
  Awaited<ReturnType<typeof postAllauthClientV1AuthCodeConfirm>>
>;
export type PostAllauthClientV1AuthCodeConfirmMutationBody = BodyType<ConfirmLoginCodeBody>;
export type PostAllauthClientV1AuthCodeConfirmMutationError = ErrorType<
  ErrorResponse | AuthenticationResponse | ConflictResponse
>;

/**
 * @summary Confirm login code
 */
export const usePostAllauthClientV1AuthCodeConfirm = <
  TError = ErrorType<ErrorResponse | AuthenticationResponse | ConflictResponse>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postAllauthClientV1AuthCodeConfirm>>,
      TError,
      { client: 'app' | 'browser'; data: BodyType<ConfirmLoginCodeBody> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof postAllauthClientV1AuthCodeConfirm>>,
  TError,
  { client: 'app' | 'browser'; data: BodyType<ConfirmLoginCodeBody> },
  TContext
> => {
  const mutationOptions = getPostAllauthClientV1AuthCodeConfirmMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary List the connected third-party provider accounts
 */
export const getAllauthClientV1AccountProviders = (
  client: 'app' | 'browser',
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<ProviderAccountsResponse>(
    { url: `/api/_allauth/${client}/v1/account/providers`, method: 'GET', signal },
    options,
  );
};

export const getGetAllauthClientV1AccountProvidersQueryKey = (client?: 'app' | 'browser') => {
  return [`/api/_allauth/${client}/v1/account/providers`] as const;
};

export const getGetAllauthClientV1AccountProvidersQueryOptions = <
  TData = Awaited<ReturnType<typeof getAllauthClientV1AccountProviders>>,
  TError = ErrorType<unknown>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1AccountProviders>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAllauthClientV1AccountProvidersQueryKey(client);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllauthClientV1AccountProviders>>> = ({
    signal,
  }) => getAllauthClientV1AccountProviders(client, requestOptions, signal);

  return { queryKey, queryFn, enabled: !!client, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getAllauthClientV1AccountProviders>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetAllauthClientV1AccountProvidersQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAllauthClientV1AccountProviders>>
>;
export type GetAllauthClientV1AccountProvidersQueryError = ErrorType<unknown>;

export function useGetAllauthClientV1AccountProviders<
  TData = Awaited<ReturnType<typeof getAllauthClientV1AccountProviders>>,
  TError = ErrorType<unknown>,
>(
  client: 'app' | 'browser',
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1AccountProviders>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllauthClientV1AccountProviders>>,
          TError,
          Awaited<ReturnType<typeof getAllauthClientV1AccountProviders>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAllauthClientV1AccountProviders<
  TData = Awaited<ReturnType<typeof getAllauthClientV1AccountProviders>>,
  TError = ErrorType<unknown>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1AccountProviders>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllauthClientV1AccountProviders>>,
          TError,
          Awaited<ReturnType<typeof getAllauthClientV1AccountProviders>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAllauthClientV1AccountProviders<
  TData = Awaited<ReturnType<typeof getAllauthClientV1AccountProviders>>,
  TError = ErrorType<unknown>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1AccountProviders>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary List the connected third-party provider accounts
 */

export function useGetAllauthClientV1AccountProviders<
  TData = Awaited<ReturnType<typeof getAllauthClientV1AccountProviders>>,
  TError = ErrorType<unknown>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1AccountProviders>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetAllauthClientV1AccountProvidersQueryOptions(client, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Disconnect a third-party provider account, returning the remaining
accounts that are still connected. The disconnect is not allowed if it
would leave the account unusable. For example, if no password was
set up yet.

 * @summary Disconnect a third-party provider account

 */
export const deleteAllauthClientV1AccountProviders = (
  client: 'app' | 'browser',
  providerAccountBody: BodyType<ProviderAccountBody>,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<ProviderAccountsResponse>(
    {
      url: `/api/_allauth/${client}/v1/account/providers`,
      method: 'DELETE',
      headers: { 'Content-Type': 'application/json' },
      data: providerAccountBody,
    },
    options,
  );
};

export const getDeleteAllauthClientV1AccountProvidersMutationOptions = <
  TError = ErrorType<ErrorResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteAllauthClientV1AccountProviders>>,
    TError,
    { client: 'app' | 'browser'; data: BodyType<ProviderAccountBody> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteAllauthClientV1AccountProviders>>,
  TError,
  { client: 'app' | 'browser'; data: BodyType<ProviderAccountBody> },
  TContext
> => {
  const mutationKey = ['deleteAllauthClientV1AccountProviders'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteAllauthClientV1AccountProviders>>,
    { client: 'app' | 'browser'; data: BodyType<ProviderAccountBody> }
  > = props => {
    const { client, data } = props ?? {};

    return deleteAllauthClientV1AccountProviders(client, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteAllauthClientV1AccountProvidersMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteAllauthClientV1AccountProviders>>
>;
export type DeleteAllauthClientV1AccountProvidersMutationBody = BodyType<ProviderAccountBody>;
export type DeleteAllauthClientV1AccountProvidersMutationError = ErrorType<ErrorResponse>;

/**
 * @summary Disconnect a third-party provider account

 */
export const useDeleteAllauthClientV1AccountProviders = <
  TError = ErrorType<ErrorResponse>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteAllauthClientV1AccountProviders>>,
      TError,
      { client: 'app' | 'browser'; data: BodyType<ProviderAccountBody> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof deleteAllauthClientV1AccountProviders>>,
  TError,
  { client: 'app' | 'browser'; data: BodyType<ProviderAccountBody> },
  TContext
> => {
  const mutationOptions = getDeleteAllauthClientV1AccountProvidersMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Retrieves the list of email addresses of the account.

 * @summary List email addresses
 */
export const getAllauthClientV1AccountEmail = (
  client: 'app' | 'browser',
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<EmailAddressesResponse>(
    { url: `/api/_allauth/${client}/v1/account/email`, method: 'GET', signal },
    options,
  );
};

export const getGetAllauthClientV1AccountEmailQueryKey = (client?: 'app' | 'browser') => {
  return [`/api/_allauth/${client}/v1/account/email`] as const;
};

export const getGetAllauthClientV1AccountEmailQueryOptions = <
  TData = Awaited<ReturnType<typeof getAllauthClientV1AccountEmail>>,
  TError = ErrorType<AuthenticationResponse>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1AccountEmail>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAllauthClientV1AccountEmailQueryKey(client);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllauthClientV1AccountEmail>>> = ({
    signal,
  }) => getAllauthClientV1AccountEmail(client, requestOptions, signal);

  return { queryKey, queryFn, enabled: !!client, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getAllauthClientV1AccountEmail>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetAllauthClientV1AccountEmailQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAllauthClientV1AccountEmail>>
>;
export type GetAllauthClientV1AccountEmailQueryError = ErrorType<AuthenticationResponse>;

export function useGetAllauthClientV1AccountEmail<
  TData = Awaited<ReturnType<typeof getAllauthClientV1AccountEmail>>,
  TError = ErrorType<AuthenticationResponse>,
>(
  client: 'app' | 'browser',
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1AccountEmail>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllauthClientV1AccountEmail>>,
          TError,
          Awaited<ReturnType<typeof getAllauthClientV1AccountEmail>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAllauthClientV1AccountEmail<
  TData = Awaited<ReturnType<typeof getAllauthClientV1AccountEmail>>,
  TError = ErrorType<AuthenticationResponse>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1AccountEmail>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllauthClientV1AccountEmail>>,
          TError,
          Awaited<ReturnType<typeof getAllauthClientV1AccountEmail>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAllauthClientV1AccountEmail<
  TData = Awaited<ReturnType<typeof getAllauthClientV1AccountEmail>>,
  TError = ErrorType<AuthenticationResponse>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1AccountEmail>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary List email addresses
 */

export function useGetAllauthClientV1AccountEmail<
  TData = Awaited<ReturnType<typeof getAllauthClientV1AccountEmail>>,
  TError = ErrorType<AuthenticationResponse>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1AccountEmail>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetAllauthClientV1AccountEmailQueryOptions(client, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * The following functionality is available:

  - Adding a new email address for an already signed in user (`ACCOUNT_CHANGE_EMAIL = False`).
  - Change to a new email address for an already signed in user   (`ACCOUNT_CHANGE_EMAIL = True`).
  - Change to a new email address during the email verification process at signup (`ACCOUNT_EMAIL_VERIFICATION_SUPPORTS_CHANGE = True`).

In all cases, an email verification mail will be sent containing a link or code that needs to be verified.

 * @summary Add/Change email address

 */
export const postAllauthClientV1AccountEmail = (
  client: 'app' | 'browser',
  emailBody: BodyType<EmailBody>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<EmailAddressesResponse>(
    {
      url: `/api/_allauth/${client}/v1/account/email`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: emailBody,
      signal,
    },
    options,
  );
};

export const getPostAllauthClientV1AccountEmailMutationOptions = <
  TError = ErrorType<ErrorResponse | AuthenticationOrReauthenticationResponse | ConflictResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postAllauthClientV1AccountEmail>>,
    TError,
    { client: 'app' | 'browser'; data: BodyType<EmailBody> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postAllauthClientV1AccountEmail>>,
  TError,
  { client: 'app' | 'browser'; data: BodyType<EmailBody> },
  TContext
> => {
  const mutationKey = ['postAllauthClientV1AccountEmail'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postAllauthClientV1AccountEmail>>,
    { client: 'app' | 'browser'; data: BodyType<EmailBody> }
  > = props => {
    const { client, data } = props ?? {};

    return postAllauthClientV1AccountEmail(client, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostAllauthClientV1AccountEmailMutationResult = NonNullable<
  Awaited<ReturnType<typeof postAllauthClientV1AccountEmail>>
>;
export type PostAllauthClientV1AccountEmailMutationBody = BodyType<EmailBody>;
export type PostAllauthClientV1AccountEmailMutationError = ErrorType<
  ErrorResponse | AuthenticationOrReauthenticationResponse | ConflictResponse
>;

/**
 * @summary Add/Change email address

 */
export const usePostAllauthClientV1AccountEmail = <
  TError = ErrorType<ErrorResponse | AuthenticationOrReauthenticationResponse | ConflictResponse>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postAllauthClientV1AccountEmail>>,
      TError,
      { client: 'app' | 'browser'; data: BodyType<EmailBody> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof postAllauthClientV1AccountEmail>>,
  TError,
  { client: 'app' | 'browser'; data: BodyType<EmailBody> },
  TContext
> => {
  const mutationOptions = getPostAllauthClientV1AccountEmailMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Requests for (another) email verification email to be sent. Note that
sending emails is rate limited, so when you send too many requests the
email will not be sent.

 * @summary Request email verification
 */
export const putAllauthClientV1AccountEmail = (
  client: 'app' | 'browser',
  emailBody: BodyType<EmailBody>,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<StatusOKResponse>(
    {
      url: `/api/_allauth/${client}/v1/account/email`,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      data: emailBody,
    },
    options,
  );
};

export const getPutAllauthClientV1AccountEmailMutationOptions = <
  TError = ErrorType<ErrorResponse | ForbiddenResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof putAllauthClientV1AccountEmail>>,
    TError,
    { client: 'app' | 'browser'; data: BodyType<EmailBody> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof putAllauthClientV1AccountEmail>>,
  TError,
  { client: 'app' | 'browser'; data: BodyType<EmailBody> },
  TContext
> => {
  const mutationKey = ['putAllauthClientV1AccountEmail'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof putAllauthClientV1AccountEmail>>,
    { client: 'app' | 'browser'; data: BodyType<EmailBody> }
  > = props => {
    const { client, data } = props ?? {};

    return putAllauthClientV1AccountEmail(client, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PutAllauthClientV1AccountEmailMutationResult = NonNullable<
  Awaited<ReturnType<typeof putAllauthClientV1AccountEmail>>
>;
export type PutAllauthClientV1AccountEmailMutationBody = BodyType<EmailBody>;
export type PutAllauthClientV1AccountEmailMutationError = ErrorType<
  ErrorResponse | ForbiddenResponse
>;

/**
 * @summary Request email verification
 */
export const usePutAllauthClientV1AccountEmail = <
  TError = ErrorType<ErrorResponse | ForbiddenResponse>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof putAllauthClientV1AccountEmail>>,
      TError,
      { client: 'app' | 'browser'; data: BodyType<EmailBody> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof putAllauthClientV1AccountEmail>>,
  TError,
  { client: 'app' | 'browser'; data: BodyType<EmailBody> },
  TContext
> => {
  const mutationOptions = getPutAllauthClientV1AccountEmailMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Used to change primary email address to a different one. Note that only verified email addresses
can be marked as primary.

 * @summary Change primary email address
 */
export const patchAllauthClientV1AccountEmail = (
  client: 'app' | 'browser',
  markPrimaryEmailBody: BodyType<MarkPrimaryEmailBody>,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<EmailAddressesResponse>(
    {
      url: `/api/_allauth/${client}/v1/account/email`,
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      data: markPrimaryEmailBody,
    },
    options,
  );
};

export const getPatchAllauthClientV1AccountEmailMutationOptions = <
  TError = ErrorType<ErrorResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof patchAllauthClientV1AccountEmail>>,
    TError,
    { client: 'app' | 'browser'; data: BodyType<MarkPrimaryEmailBody> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof patchAllauthClientV1AccountEmail>>,
  TError,
  { client: 'app' | 'browser'; data: BodyType<MarkPrimaryEmailBody> },
  TContext
> => {
  const mutationKey = ['patchAllauthClientV1AccountEmail'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof patchAllauthClientV1AccountEmail>>,
    { client: 'app' | 'browser'; data: BodyType<MarkPrimaryEmailBody> }
  > = props => {
    const { client, data } = props ?? {};

    return patchAllauthClientV1AccountEmail(client, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PatchAllauthClientV1AccountEmailMutationResult = NonNullable<
  Awaited<ReturnType<typeof patchAllauthClientV1AccountEmail>>
>;
export type PatchAllauthClientV1AccountEmailMutationBody = BodyType<MarkPrimaryEmailBody>;
export type PatchAllauthClientV1AccountEmailMutationError = ErrorType<ErrorResponse>;

/**
 * @summary Change primary email address
 */
export const usePatchAllauthClientV1AccountEmail = <
  TError = ErrorType<ErrorResponse>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof patchAllauthClientV1AccountEmail>>,
      TError,
      { client: 'app' | 'browser'; data: BodyType<MarkPrimaryEmailBody> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof patchAllauthClientV1AccountEmail>>,
  TError,
  { client: 'app' | 'browser'; data: BodyType<MarkPrimaryEmailBody> },
  TContext
> => {
  const mutationOptions = getPatchAllauthClientV1AccountEmailMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Used to remove an email address.

 * @summary Remove an email address
 */
export const deleteAllauthClientV1AccountEmail = (
  client: 'app' | 'browser',
  emailBody: BodyType<EmailBody>,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<EmailAddressesResponse>(
    {
      url: `/api/_allauth/${client}/v1/account/email`,
      method: 'DELETE',
      headers: { 'Content-Type': 'application/json' },
      data: emailBody,
    },
    options,
  );
};

export const getDeleteAllauthClientV1AccountEmailMutationOptions = <
  TError = ErrorType<ErrorResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteAllauthClientV1AccountEmail>>,
    TError,
    { client: 'app' | 'browser'; data: BodyType<EmailBody> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteAllauthClientV1AccountEmail>>,
  TError,
  { client: 'app' | 'browser'; data: BodyType<EmailBody> },
  TContext
> => {
  const mutationKey = ['deleteAllauthClientV1AccountEmail'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteAllauthClientV1AccountEmail>>,
    { client: 'app' | 'browser'; data: BodyType<EmailBody> }
  > = props => {
    const { client, data } = props ?? {};

    return deleteAllauthClientV1AccountEmail(client, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteAllauthClientV1AccountEmailMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteAllauthClientV1AccountEmail>>
>;
export type DeleteAllauthClientV1AccountEmailMutationBody = BodyType<EmailBody>;
export type DeleteAllauthClientV1AccountEmailMutationError = ErrorType<ErrorResponse>;

/**
 * @summary Remove an email address
 */
export const useDeleteAllauthClientV1AccountEmail = <
  TError = ErrorType<ErrorResponse>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteAllauthClientV1AccountEmail>>,
      TError,
      { client: 'app' | 'browser'; data: BodyType<EmailBody> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof deleteAllauthClientV1AccountEmail>>,
  TError,
  { client: 'app' | 'browser'; data: BodyType<EmailBody> },
  TContext
> => {
  const mutationOptions = getDeleteAllauthClientV1AccountEmailMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Retrieves the phone number of the account, if any. Note that while the
endpoint returns a list of phone numbers, at most one entry is returned.

 * @summary Get the phone number
 */
export const getAllauthClientV1AccountPhone = (
  client: 'app' | 'browser',
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<PhoneNumbersResponse>(
    { url: `/api/_allauth/${client}/v1/account/phone`, method: 'GET', signal },
    options,
  );
};

export const getGetAllauthClientV1AccountPhoneQueryKey = (client?: 'app' | 'browser') => {
  return [`/api/_allauth/${client}/v1/account/phone`] as const;
};

export const getGetAllauthClientV1AccountPhoneQueryOptions = <
  TData = Awaited<ReturnType<typeof getAllauthClientV1AccountPhone>>,
  TError = ErrorType<AuthenticationResponse>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1AccountPhone>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAllauthClientV1AccountPhoneQueryKey(client);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllauthClientV1AccountPhone>>> = ({
    signal,
  }) => getAllauthClientV1AccountPhone(client, requestOptions, signal);

  return { queryKey, queryFn, enabled: !!client, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getAllauthClientV1AccountPhone>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetAllauthClientV1AccountPhoneQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAllauthClientV1AccountPhone>>
>;
export type GetAllauthClientV1AccountPhoneQueryError = ErrorType<AuthenticationResponse>;

export function useGetAllauthClientV1AccountPhone<
  TData = Awaited<ReturnType<typeof getAllauthClientV1AccountPhone>>,
  TError = ErrorType<AuthenticationResponse>,
>(
  client: 'app' | 'browser',
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1AccountPhone>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllauthClientV1AccountPhone>>,
          TError,
          Awaited<ReturnType<typeof getAllauthClientV1AccountPhone>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAllauthClientV1AccountPhone<
  TData = Awaited<ReturnType<typeof getAllauthClientV1AccountPhone>>,
  TError = ErrorType<AuthenticationResponse>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1AccountPhone>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllauthClientV1AccountPhone>>,
          TError,
          Awaited<ReturnType<typeof getAllauthClientV1AccountPhone>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAllauthClientV1AccountPhone<
  TData = Awaited<ReturnType<typeof getAllauthClientV1AccountPhone>>,
  TError = ErrorType<AuthenticationResponse>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1AccountPhone>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get the phone number
 */

export function useGetAllauthClientV1AccountPhone<
  TData = Awaited<ReturnType<typeof getAllauthClientV1AccountPhone>>,
  TError = ErrorType<AuthenticationResponse>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1AccountPhone>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetAllauthClientV1AccountPhoneQueryOptions(client, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * The following functionality is available:

- Initiate the phone number change process for signed in users.
- Change to a new phone number during the phone number verification
  process at signup for unauthenticated users. Note that this requires:
  `ACCOUNT_PHONE_VERIFICATION_SUPPORTS_CHANGE = True`.

In both cases, after posting a new phone number, proceed with the phone
verification endpoint to confirm the change of the phone number by
posting the verification code.

 * @summary Change the phone number

 */
export const postAllauthClientV1AccountPhone = (
  client: 'app' | 'browser',
  phoneBody: BodyType<PhoneBody>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<PhoneNumberChangeResponse>(
    {
      url: `/api/_allauth/${client}/v1/account/phone`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: phoneBody,
      signal,
    },
    options,
  );
};

export const getPostAllauthClientV1AccountPhoneMutationOptions = <
  TError = ErrorType<ErrorResponse | AuthenticationOrReauthenticationResponse | ConflictResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postAllauthClientV1AccountPhone>>,
    TError,
    { client: 'app' | 'browser'; data: BodyType<PhoneBody> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postAllauthClientV1AccountPhone>>,
  TError,
  { client: 'app' | 'browser'; data: BodyType<PhoneBody> },
  TContext
> => {
  const mutationKey = ['postAllauthClientV1AccountPhone'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postAllauthClientV1AccountPhone>>,
    { client: 'app' | 'browser'; data: BodyType<PhoneBody> }
  > = props => {
    const { client, data } = props ?? {};

    return postAllauthClientV1AccountPhone(client, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostAllauthClientV1AccountPhoneMutationResult = NonNullable<
  Awaited<ReturnType<typeof postAllauthClientV1AccountPhone>>
>;
export type PostAllauthClientV1AccountPhoneMutationBody = BodyType<PhoneBody>;
export type PostAllauthClientV1AccountPhoneMutationError = ErrorType<
  ErrorResponse | AuthenticationOrReauthenticationResponse | ConflictResponse
>;

/**
 * @summary Change the phone number

 */
export const usePostAllauthClientV1AccountPhone = <
  TError = ErrorType<ErrorResponse | AuthenticationOrReauthenticationResponse | ConflictResponse>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postAllauthClientV1AccountPhone>>,
      TError,
      { client: 'app' | 'browser'; data: BodyType<PhoneBody> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof postAllauthClientV1AccountPhone>>,
  TError,
  { client: 'app' | 'browser'; data: BodyType<PhoneBody> },
  TContext
> => {
  const mutationOptions = getPostAllauthClientV1AccountPhoneMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary List authenticators
 */
export const getAllauthClientV1AccountAuthenticators = (
  client: 'app' | 'browser',
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<AuthenticatorsResponse>(
    { url: `/api/_allauth/${client}/v1/account/authenticators`, method: 'GET', signal },
    options,
  );
};

export const getGetAllauthClientV1AccountAuthenticatorsQueryKey = (client?: 'app' | 'browser') => {
  return [`/api/_allauth/${client}/v1/account/authenticators`] as const;
};

export const getGetAllauthClientV1AccountAuthenticatorsQueryOptions = <
  TData = Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticators>>,
  TError = ErrorType<AuthenticationResponse | SessionGoneResponse>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticators>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetAllauthClientV1AccountAuthenticatorsQueryKey(client);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticators>>
  > = ({ signal }) => getAllauthClientV1AccountAuthenticators(client, requestOptions, signal);

  return { queryKey, queryFn, enabled: !!client, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticators>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetAllauthClientV1AccountAuthenticatorsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticators>>
>;
export type GetAllauthClientV1AccountAuthenticatorsQueryError = ErrorType<
  AuthenticationResponse | SessionGoneResponse
>;

export function useGetAllauthClientV1AccountAuthenticators<
  TData = Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticators>>,
  TError = ErrorType<AuthenticationResponse | SessionGoneResponse>,
>(
  client: 'app' | 'browser',
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticators>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticators>>,
          TError,
          Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticators>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAllauthClientV1AccountAuthenticators<
  TData = Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticators>>,
  TError = ErrorType<AuthenticationResponse | SessionGoneResponse>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticators>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticators>>,
          TError,
          Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticators>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAllauthClientV1AccountAuthenticators<
  TData = Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticators>>,
  TError = ErrorType<AuthenticationResponse | SessionGoneResponse>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticators>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary List authenticators
 */

export function useGetAllauthClientV1AccountAuthenticators<
  TData = Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticators>>,
  TError = ErrorType<AuthenticationResponse | SessionGoneResponse>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticators>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetAllauthClientV1AccountAuthenticatorsQueryOptions(client, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Retrieve the information about the current TOTP authenticator, if any.

 * @summary TOTP authenticator status
 */
export const getAllauthClientV1AccountAuthenticatorsTotp = (
  client: 'app' | 'browser',
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<TOTPAuthenticatorResponse>(
    { url: `/api/_allauth/${client}/v1/account/authenticators/totp`, method: 'GET', signal },
    options,
  );
};

export const getGetAllauthClientV1AccountAuthenticatorsTotpQueryKey = (
  client?: 'app' | 'browser',
) => {
  return [`/api/_allauth/${client}/v1/account/authenticators/totp`] as const;
};

export const getGetAllauthClientV1AccountAuthenticatorsTotpQueryOptions = <
  TData = Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticatorsTotp>>,
  TError = ErrorType<TOTPAuthenticatorNotFoundResponse | AddAuthenticatorConflictResponse>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticatorsTotp>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetAllauthClientV1AccountAuthenticatorsTotpQueryKey(client);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticatorsTotp>>
  > = ({ signal }) => getAllauthClientV1AccountAuthenticatorsTotp(client, requestOptions, signal);

  return { queryKey, queryFn, enabled: !!client, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticatorsTotp>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetAllauthClientV1AccountAuthenticatorsTotpQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticatorsTotp>>
>;
export type GetAllauthClientV1AccountAuthenticatorsTotpQueryError = ErrorType<
  TOTPAuthenticatorNotFoundResponse | AddAuthenticatorConflictResponse
>;

export function useGetAllauthClientV1AccountAuthenticatorsTotp<
  TData = Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticatorsTotp>>,
  TError = ErrorType<TOTPAuthenticatorNotFoundResponse | AddAuthenticatorConflictResponse>,
>(
  client: 'app' | 'browser',
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticatorsTotp>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticatorsTotp>>,
          TError,
          Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticatorsTotp>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAllauthClientV1AccountAuthenticatorsTotp<
  TData = Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticatorsTotp>>,
  TError = ErrorType<TOTPAuthenticatorNotFoundResponse | AddAuthenticatorConflictResponse>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticatorsTotp>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticatorsTotp>>,
          TError,
          Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticatorsTotp>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAllauthClientV1AccountAuthenticatorsTotp<
  TData = Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticatorsTotp>>,
  TError = ErrorType<TOTPAuthenticatorNotFoundResponse | AddAuthenticatorConflictResponse>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticatorsTotp>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary TOTP authenticator status
 */

export function useGetAllauthClientV1AccountAuthenticatorsTotp<
  TData = Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticatorsTotp>>,
  TError = ErrorType<TOTPAuthenticatorNotFoundResponse | AddAuthenticatorConflictResponse>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticatorsTotp>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetAllauthClientV1AccountAuthenticatorsTotpQueryOptions(client, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * The code should be provided from the consuming TOTP authenticator
application which was generated using the TOTP authenticator secret
retrieved from the TOTP authenticator status endpoint.

 * @summary Activate TOTP
 */
export const postAllauthClientV1AccountAuthenticatorsTotp = (
  client: 'app' | 'browser',
  setupTOTPBody: BodyType<SetupTOTPBody>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<TOTPAuthenticatorResponse>(
    {
      url: `/api/_allauth/${client}/v1/account/authenticators/totp`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: setupTOTPBody,
      signal,
    },
    options,
  );
};

export const getPostAllauthClientV1AccountAuthenticatorsTotpMutationOptions = <
  TError = ErrorType<
    ErrorResponse | ReauthenticationRequiredResponse | AddAuthenticatorConflictResponse
  >,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postAllauthClientV1AccountAuthenticatorsTotp>>,
    TError,
    { client: 'app' | 'browser'; data: BodyType<SetupTOTPBody> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postAllauthClientV1AccountAuthenticatorsTotp>>,
  TError,
  { client: 'app' | 'browser'; data: BodyType<SetupTOTPBody> },
  TContext
> => {
  const mutationKey = ['postAllauthClientV1AccountAuthenticatorsTotp'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postAllauthClientV1AccountAuthenticatorsTotp>>,
    { client: 'app' | 'browser'; data: BodyType<SetupTOTPBody> }
  > = props => {
    const { client, data } = props ?? {};

    return postAllauthClientV1AccountAuthenticatorsTotp(client, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostAllauthClientV1AccountAuthenticatorsTotpMutationResult = NonNullable<
  Awaited<ReturnType<typeof postAllauthClientV1AccountAuthenticatorsTotp>>
>;
export type PostAllauthClientV1AccountAuthenticatorsTotpMutationBody = BodyType<SetupTOTPBody>;
export type PostAllauthClientV1AccountAuthenticatorsTotpMutationError = ErrorType<
  ErrorResponse | ReauthenticationRequiredResponse | AddAuthenticatorConflictResponse
>;

/**
 * @summary Activate TOTP
 */
export const usePostAllauthClientV1AccountAuthenticatorsTotp = <
  TError = ErrorType<
    ErrorResponse | ReauthenticationRequiredResponse | AddAuthenticatorConflictResponse
  >,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postAllauthClientV1AccountAuthenticatorsTotp>>,
      TError,
      { client: 'app' | 'browser'; data: BodyType<SetupTOTPBody> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof postAllauthClientV1AccountAuthenticatorsTotp>>,
  TError,
  { client: 'app' | 'browser'; data: BodyType<SetupTOTPBody> },
  TContext
> => {
  const mutationOptions = getPostAllauthClientV1AccountAuthenticatorsTotpMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Deactivates TOTP authentication. If the user authentication is not
sufficiently recent, a reauthentication flow (`401`) will is presented.

 * @summary Deactivate TOTP
 */
export const deleteAllauthClientV1AccountAuthenticatorsTotp = (
  client: 'app' | 'browser',
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<StatusOKResponse>(
    { url: `/api/_allauth/${client}/v1/account/authenticators/totp`, method: 'DELETE' },
    options,
  );
};

export const getDeleteAllauthClientV1AccountAuthenticatorsTotpMutationOptions = <
  TError = ErrorType<ReauthenticationRequiredResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteAllauthClientV1AccountAuthenticatorsTotp>>,
    TError,
    { client: 'app' | 'browser' },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteAllauthClientV1AccountAuthenticatorsTotp>>,
  TError,
  { client: 'app' | 'browser' },
  TContext
> => {
  const mutationKey = ['deleteAllauthClientV1AccountAuthenticatorsTotp'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteAllauthClientV1AccountAuthenticatorsTotp>>,
    { client: 'app' | 'browser' }
  > = props => {
    const { client } = props ?? {};

    return deleteAllauthClientV1AccountAuthenticatorsTotp(client, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteAllauthClientV1AccountAuthenticatorsTotpMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteAllauthClientV1AccountAuthenticatorsTotp>>
>;

export type DeleteAllauthClientV1AccountAuthenticatorsTotpMutationError =
  ErrorType<ReauthenticationRequiredResponse>;

/**
 * @summary Deactivate TOTP
 */
export const useDeleteAllauthClientV1AccountAuthenticatorsTotp = <
  TError = ErrorType<ReauthenticationRequiredResponse>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteAllauthClientV1AccountAuthenticatorsTotp>>,
      TError,
      { client: 'app' | 'browser' },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof deleteAllauthClientV1AccountAuthenticatorsTotp>>,
  TError,
  { client: 'app' | 'browser' },
  TContext
> => {
  const mutationOptions = getDeleteAllauthClientV1AccountAuthenticatorsTotpMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * List recovery codes.

 * @summary List recovery codes
 */
export const getAllauthClientV1AccountAuthenticatorsRecoveryCodes = (
  client: 'app' | 'browser',
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<RecoveryCodesResponse>(
    {
      url: `/api/_allauth/${client}/v1/account/authenticators/recovery-codes`,
      method: 'GET',
      signal,
    },
    options,
  );
};

export const getGetAllauthClientV1AccountAuthenticatorsRecoveryCodesQueryKey = (
  client?: 'app' | 'browser',
) => {
  return [`/api/_allauth/${client}/v1/account/authenticators/recovery-codes`] as const;
};

export const getGetAllauthClientV1AccountAuthenticatorsRecoveryCodesQueryOptions = <
  TData = Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticatorsRecoveryCodes>>,
  TError = ErrorType<ReauthenticationRequiredResponse | NotFoundResponse>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticatorsRecoveryCodes>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetAllauthClientV1AccountAuthenticatorsRecoveryCodesQueryKey(client);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticatorsRecoveryCodes>>
  > = ({ signal }) =>
    getAllauthClientV1AccountAuthenticatorsRecoveryCodes(client, requestOptions, signal);

  return { queryKey, queryFn, enabled: !!client, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticatorsRecoveryCodes>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetAllauthClientV1AccountAuthenticatorsRecoveryCodesQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticatorsRecoveryCodes>>
>;
export type GetAllauthClientV1AccountAuthenticatorsRecoveryCodesQueryError = ErrorType<
  ReauthenticationRequiredResponse | NotFoundResponse
>;

export function useGetAllauthClientV1AccountAuthenticatorsRecoveryCodes<
  TData = Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticatorsRecoveryCodes>>,
  TError = ErrorType<ReauthenticationRequiredResponse | NotFoundResponse>,
>(
  client: 'app' | 'browser',
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticatorsRecoveryCodes>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticatorsRecoveryCodes>>,
          TError,
          Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticatorsRecoveryCodes>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAllauthClientV1AccountAuthenticatorsRecoveryCodes<
  TData = Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticatorsRecoveryCodes>>,
  TError = ErrorType<ReauthenticationRequiredResponse | NotFoundResponse>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticatorsRecoveryCodes>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticatorsRecoveryCodes>>,
          TError,
          Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticatorsRecoveryCodes>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAllauthClientV1AccountAuthenticatorsRecoveryCodes<
  TData = Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticatorsRecoveryCodes>>,
  TError = ErrorType<ReauthenticationRequiredResponse | NotFoundResponse>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticatorsRecoveryCodes>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary List recovery codes
 */

export function useGetAllauthClientV1AccountAuthenticatorsRecoveryCodes<
  TData = Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticatorsRecoveryCodes>>,
  TError = ErrorType<ReauthenticationRequiredResponse | NotFoundResponse>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticatorsRecoveryCodes>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetAllauthClientV1AccountAuthenticatorsRecoveryCodesQueryOptions(
    client,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Regenerate recovery codes
 */
export const postAllauthClientV1AccountAuthenticatorsRecoveryCodes = (
  client: 'app' | 'browser',
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<unknown>(
    {
      url: `/api/_allauth/${client}/v1/account/authenticators/recovery-codes`,
      method: 'POST',
      signal,
    },
    options,
  );
};

export const getPostAllauthClientV1AccountAuthenticatorsRecoveryCodesMutationOptions = <
  TError = ErrorType<ErrorResponse | ReauthenticationRequiredResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postAllauthClientV1AccountAuthenticatorsRecoveryCodes>>,
    TError,
    { client: 'app' | 'browser' },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postAllauthClientV1AccountAuthenticatorsRecoveryCodes>>,
  TError,
  { client: 'app' | 'browser' },
  TContext
> => {
  const mutationKey = ['postAllauthClientV1AccountAuthenticatorsRecoveryCodes'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postAllauthClientV1AccountAuthenticatorsRecoveryCodes>>,
    { client: 'app' | 'browser' }
  > = props => {
    const { client } = props ?? {};

    return postAllauthClientV1AccountAuthenticatorsRecoveryCodes(client, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostAllauthClientV1AccountAuthenticatorsRecoveryCodesMutationResult = NonNullable<
  Awaited<ReturnType<typeof postAllauthClientV1AccountAuthenticatorsRecoveryCodes>>
>;

export type PostAllauthClientV1AccountAuthenticatorsRecoveryCodesMutationError = ErrorType<
  ErrorResponse | ReauthenticationRequiredResponse
>;

/**
 * @summary Regenerate recovery codes
 */
export const usePostAllauthClientV1AccountAuthenticatorsRecoveryCodes = <
  TError = ErrorType<ErrorResponse | ReauthenticationRequiredResponse>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postAllauthClientV1AccountAuthenticatorsRecoveryCodes>>,
      TError,
      { client: 'app' | 'browser' },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof postAllauthClientV1AccountAuthenticatorsRecoveryCodes>>,
  TError,
  { client: 'app' | 'browser' },
  TContext
> => {
  const mutationOptions =
    getPostAllauthClientV1AccountAuthenticatorsRecoveryCodesMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Returns the WebAuthn credential creation options, that can be
processed using `parseCreationOptionsFromJSON()` on the frontend.

 * @summary Get WebAuthn credential creation options

 */
export const getAllauthClientV1AccountAuthenticatorsWebauthn = (
  client: 'app' | 'browser',
  params?: GetAllauthClientV1AccountAuthenticatorsWebauthnParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<WebAuthnCreationOptionsResponseResponse>(
    {
      url: `/api/_allauth/${client}/v1/account/authenticators/webauthn`,
      method: 'GET',
      params,
      signal,
    },
    options,
  );
};

export const getGetAllauthClientV1AccountAuthenticatorsWebauthnQueryKey = (
  client?: 'app' | 'browser',
  params?: GetAllauthClientV1AccountAuthenticatorsWebauthnParams,
) => {
  return [
    `/api/_allauth/${client}/v1/account/authenticators/webauthn`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetAllauthClientV1AccountAuthenticatorsWebauthnQueryOptions = <
  TData = Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticatorsWebauthn>>,
  TError = ErrorType<ReauthenticationRequiredResponse | AddAuthenticatorConflictResponse>,
>(
  client: 'app' | 'browser',
  params?: GetAllauthClientV1AccountAuthenticatorsWebauthnParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticatorsWebauthn>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetAllauthClientV1AccountAuthenticatorsWebauthnQueryKey(client, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticatorsWebauthn>>
  > = ({ signal }) =>
    getAllauthClientV1AccountAuthenticatorsWebauthn(client, params, requestOptions, signal);

  return { queryKey, queryFn, enabled: !!client, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticatorsWebauthn>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetAllauthClientV1AccountAuthenticatorsWebauthnQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticatorsWebauthn>>
>;
export type GetAllauthClientV1AccountAuthenticatorsWebauthnQueryError = ErrorType<
  ReauthenticationRequiredResponse | AddAuthenticatorConflictResponse
>;

export function useGetAllauthClientV1AccountAuthenticatorsWebauthn<
  TData = Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticatorsWebauthn>>,
  TError = ErrorType<ReauthenticationRequiredResponse | AddAuthenticatorConflictResponse>,
>(
  client: 'app' | 'browser',
  params: undefined | GetAllauthClientV1AccountAuthenticatorsWebauthnParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticatorsWebauthn>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticatorsWebauthn>>,
          TError,
          Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticatorsWebauthn>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAllauthClientV1AccountAuthenticatorsWebauthn<
  TData = Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticatorsWebauthn>>,
  TError = ErrorType<ReauthenticationRequiredResponse | AddAuthenticatorConflictResponse>,
>(
  client: 'app' | 'browser',
  params?: GetAllauthClientV1AccountAuthenticatorsWebauthnParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticatorsWebauthn>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticatorsWebauthn>>,
          TError,
          Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticatorsWebauthn>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAllauthClientV1AccountAuthenticatorsWebauthn<
  TData = Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticatorsWebauthn>>,
  TError = ErrorType<ReauthenticationRequiredResponse | AddAuthenticatorConflictResponse>,
>(
  client: 'app' | 'browser',
  params?: GetAllauthClientV1AccountAuthenticatorsWebauthnParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticatorsWebauthn>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get WebAuthn credential creation options

 */

export function useGetAllauthClientV1AccountAuthenticatorsWebauthn<
  TData = Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticatorsWebauthn>>,
  TError = ErrorType<ReauthenticationRequiredResponse | AddAuthenticatorConflictResponse>,
>(
  client: 'app' | 'browser',
  params?: GetAllauthClientV1AccountAuthenticatorsWebauthnParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAllauthClientV1AccountAuthenticatorsWebauthn>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetAllauthClientV1AccountAuthenticatorsWebauthnQueryOptions(
    client,
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * You can alter the name of a WebAuthn credential by PUT'ting the ID and
name of the authenticator representing that credential. You can obtain
the credentials via the "List authenticators" endpoint.

 * @summary Rename a WebAuthn credential

 */
export const putAllauthClientV1AccountAuthenticatorsWebauthn = (
  client: 'app' | 'browser',
  updateWebAuthnBody: BodyType<UpdateWebAuthnBody>,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<WebAuthnAuthenticatorResponse>(
    {
      url: `/api/_allauth/${client}/v1/account/authenticators/webauthn`,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      data: updateWebAuthnBody,
    },
    options,
  );
};

export const getPutAllauthClientV1AccountAuthenticatorsWebauthnMutationOptions = <
  TError = ErrorType<ReauthenticationRequiredResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof putAllauthClientV1AccountAuthenticatorsWebauthn>>,
    TError,
    { client: 'app' | 'browser'; data: BodyType<UpdateWebAuthnBody> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof putAllauthClientV1AccountAuthenticatorsWebauthn>>,
  TError,
  { client: 'app' | 'browser'; data: BodyType<UpdateWebAuthnBody> },
  TContext
> => {
  const mutationKey = ['putAllauthClientV1AccountAuthenticatorsWebauthn'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof putAllauthClientV1AccountAuthenticatorsWebauthn>>,
    { client: 'app' | 'browser'; data: BodyType<UpdateWebAuthnBody> }
  > = props => {
    const { client, data } = props ?? {};

    return putAllauthClientV1AccountAuthenticatorsWebauthn(client, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PutAllauthClientV1AccountAuthenticatorsWebauthnMutationResult = NonNullable<
  Awaited<ReturnType<typeof putAllauthClientV1AccountAuthenticatorsWebauthn>>
>;
export type PutAllauthClientV1AccountAuthenticatorsWebauthnMutationBody =
  BodyType<UpdateWebAuthnBody>;
export type PutAllauthClientV1AccountAuthenticatorsWebauthnMutationError =
  ErrorType<ReauthenticationRequiredResponse>;

/**
 * @summary Rename a WebAuthn credential

 */
export const usePutAllauthClientV1AccountAuthenticatorsWebauthn = <
  TError = ErrorType<ReauthenticationRequiredResponse>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof putAllauthClientV1AccountAuthenticatorsWebauthn>>,
      TError,
      { client: 'app' | 'browser'; data: BodyType<UpdateWebAuthnBody> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof putAllauthClientV1AccountAuthenticatorsWebauthn>>,
  TError,
  { client: 'app' | 'browser'; data: BodyType<UpdateWebAuthnBody> },
  TContext
> => {
  const mutationOptions =
    getPutAllauthClientV1AccountAuthenticatorsWebauthnMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Delete a WebAuthn credential

 */
export const deleteAllauthClientV1AccountAuthenticatorsWebauthn = (
  client: 'app' | 'browser',
  deleteWebAuthnBody: BodyType<DeleteWebAuthnBody>,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<StatusOKResponse>(
    {
      url: `/api/_allauth/${client}/v1/account/authenticators/webauthn`,
      method: 'DELETE',
      headers: { 'Content-Type': 'application/json' },
      data: deleteWebAuthnBody,
    },
    options,
  );
};

export const getDeleteAllauthClientV1AccountAuthenticatorsWebauthnMutationOptions = <
  TError = ErrorType<ReauthenticationRequiredResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteAllauthClientV1AccountAuthenticatorsWebauthn>>,
    TError,
    { client: 'app' | 'browser'; data: BodyType<DeleteWebAuthnBody> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteAllauthClientV1AccountAuthenticatorsWebauthn>>,
  TError,
  { client: 'app' | 'browser'; data: BodyType<DeleteWebAuthnBody> },
  TContext
> => {
  const mutationKey = ['deleteAllauthClientV1AccountAuthenticatorsWebauthn'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteAllauthClientV1AccountAuthenticatorsWebauthn>>,
    { client: 'app' | 'browser'; data: BodyType<DeleteWebAuthnBody> }
  > = props => {
    const { client, data } = props ?? {};

    return deleteAllauthClientV1AccountAuthenticatorsWebauthn(client, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteAllauthClientV1AccountAuthenticatorsWebauthnMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteAllauthClientV1AccountAuthenticatorsWebauthn>>
>;
export type DeleteAllauthClientV1AccountAuthenticatorsWebauthnMutationBody =
  BodyType<DeleteWebAuthnBody>;
export type DeleteAllauthClientV1AccountAuthenticatorsWebauthnMutationError =
  ErrorType<ReauthenticationRequiredResponse>;

/**
 * @summary Delete a WebAuthn credential

 */
export const useDeleteAllauthClientV1AccountAuthenticatorsWebauthn = <
  TError = ErrorType<ReauthenticationRequiredResponse>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteAllauthClientV1AccountAuthenticatorsWebauthn>>,
      TError,
      { client: 'app' | 'browser'; data: BodyType<DeleteWebAuthnBody> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof deleteAllauthClientV1AccountAuthenticatorsWebauthn>>,
  TError,
  { client: 'app' | 'browser'; data: BodyType<DeleteWebAuthnBody> },
  TContext
> => {
  const mutationOptions =
    getDeleteAllauthClientV1AccountAuthenticatorsWebauthnMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Add a WebAuthn credential

 */
export const postAllauthClientV1AccountAuthenticatorsWebauthn = (
  client: 'app' | 'browser',
  addWebAuthnAuthenticatorBody: BodyType<AddWebAuthnAuthenticatorBody>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<AddWebAuthnAuthenticatorResponse>(
    {
      url: `/api/_allauth/${client}/v1/account/authenticators/webauthn`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: addWebAuthnAuthenticatorBody,
      signal,
    },
    options,
  );
};

export const getPostAllauthClientV1AccountAuthenticatorsWebauthnMutationOptions = <
  TError = ErrorType<ReauthenticationRequiredResponse | AddAuthenticatorConflictResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postAllauthClientV1AccountAuthenticatorsWebauthn>>,
    TError,
    { client: 'app' | 'browser'; data: BodyType<AddWebAuthnAuthenticatorBody> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postAllauthClientV1AccountAuthenticatorsWebauthn>>,
  TError,
  { client: 'app' | 'browser'; data: BodyType<AddWebAuthnAuthenticatorBody> },
  TContext
> => {
  const mutationKey = ['postAllauthClientV1AccountAuthenticatorsWebauthn'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postAllauthClientV1AccountAuthenticatorsWebauthn>>,
    { client: 'app' | 'browser'; data: BodyType<AddWebAuthnAuthenticatorBody> }
  > = props => {
    const { client, data } = props ?? {};

    return postAllauthClientV1AccountAuthenticatorsWebauthn(client, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostAllauthClientV1AccountAuthenticatorsWebauthnMutationResult = NonNullable<
  Awaited<ReturnType<typeof postAllauthClientV1AccountAuthenticatorsWebauthn>>
>;
export type PostAllauthClientV1AccountAuthenticatorsWebauthnMutationBody =
  BodyType<AddWebAuthnAuthenticatorBody>;
export type PostAllauthClientV1AccountAuthenticatorsWebauthnMutationError = ErrorType<
  ReauthenticationRequiredResponse | AddAuthenticatorConflictResponse
>;

/**
 * @summary Add a WebAuthn credential

 */
export const usePostAllauthClientV1AccountAuthenticatorsWebauthn = <
  TError = ErrorType<ReauthenticationRequiredResponse | AddAuthenticatorConflictResponse>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postAllauthClientV1AccountAuthenticatorsWebauthn>>,
      TError,
      { client: 'app' | 'browser'; data: BodyType<AddWebAuthnAuthenticatorBody> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof postAllauthClientV1AccountAuthenticatorsWebauthn>>,
  TError,
  { client: 'app' | 'browser'; data: BodyType<AddWebAuthnAuthenticatorBody> },
  TContext
> => {
  const mutationOptions =
    getPostAllauthClientV1AccountAuthenticatorsWebauthnMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Retrieve information about the authentication status for the current
session.

 * @summary Get authentication status

 */
export const getAllauthClientV1AuthSession = (
  client: 'app' | 'browser',
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<AuthenticatedResponse>(
    { url: `/api/_allauth/${client}/v1/auth/session`, method: 'GET', signal },
    options,
  );
};

export const getGetAllauthClientV1AuthSessionQueryKey = (client?: 'app' | 'browser') => {
  return [`/api/_allauth/${client}/v1/auth/session`] as const;
};

export const getGetAllauthClientV1AuthSessionQueryOptions = <
  TData = Awaited<ReturnType<typeof getAllauthClientV1AuthSession>>,
  TError = ErrorType<AuthenticationResponse | SessionGoneResponse>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1AuthSession>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAllauthClientV1AuthSessionQueryKey(client);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllauthClientV1AuthSession>>> = ({
    signal,
  }) => getAllauthClientV1AuthSession(client, requestOptions, signal);

  return { queryKey, queryFn, enabled: !!client, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getAllauthClientV1AuthSession>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetAllauthClientV1AuthSessionQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAllauthClientV1AuthSession>>
>;
export type GetAllauthClientV1AuthSessionQueryError = ErrorType<
  AuthenticationResponse | SessionGoneResponse
>;

export function useGetAllauthClientV1AuthSession<
  TData = Awaited<ReturnType<typeof getAllauthClientV1AuthSession>>,
  TError = ErrorType<AuthenticationResponse | SessionGoneResponse>,
>(
  client: 'app' | 'browser',
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1AuthSession>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllauthClientV1AuthSession>>,
          TError,
          Awaited<ReturnType<typeof getAllauthClientV1AuthSession>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAllauthClientV1AuthSession<
  TData = Awaited<ReturnType<typeof getAllauthClientV1AuthSession>>,
  TError = ErrorType<AuthenticationResponse | SessionGoneResponse>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1AuthSession>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllauthClientV1AuthSession>>,
          TError,
          Awaited<ReturnType<typeof getAllauthClientV1AuthSession>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAllauthClientV1AuthSession<
  TData = Awaited<ReturnType<typeof getAllauthClientV1AuthSession>>,
  TError = ErrorType<AuthenticationResponse | SessionGoneResponse>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1AuthSession>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get authentication status

 */

export function useGetAllauthClientV1AuthSession<
  TData = Awaited<ReturnType<typeof getAllauthClientV1AuthSession>>,
  TError = ErrorType<AuthenticationResponse | SessionGoneResponse>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1AuthSession>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetAllauthClientV1AuthSessionQueryOptions(client, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Logs out the user from the current session.

 * @summary Logout
 */
export const deleteAllauthClientV1AuthSession = (
  client: 'app' | 'browser',
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<unknown>(
    { url: `/api/_allauth/${client}/v1/auth/session`, method: 'DELETE' },
    options,
  );
};

export const getDeleteAllauthClientV1AuthSessionMutationOptions = <
  TError = ErrorType<UnauthenticatedResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteAllauthClientV1AuthSession>>,
    TError,
    { client: 'app' | 'browser' },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteAllauthClientV1AuthSession>>,
  TError,
  { client: 'app' | 'browser' },
  TContext
> => {
  const mutationKey = ['deleteAllauthClientV1AuthSession'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteAllauthClientV1AuthSession>>,
    { client: 'app' | 'browser' }
  > = props => {
    const { client } = props ?? {};

    return deleteAllauthClientV1AuthSession(client, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteAllauthClientV1AuthSessionMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteAllauthClientV1AuthSession>>
>;

export type DeleteAllauthClientV1AuthSessionMutationError = ErrorType<UnauthenticatedResponse>;

/**
 * @summary Logout
 */
export const useDeleteAllauthClientV1AuthSession = <
  TError = ErrorType<UnauthenticatedResponse>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteAllauthClientV1AuthSession>>,
      TError,
      { client: 'app' | 'browser' },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof deleteAllauthClientV1AuthSession>>,
  TError,
  { client: 'app' | 'browser' },
  TContext
> => {
  const mutationOptions = getDeleteAllauthClientV1AuthSessionMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Used to retrieve a new access token. Depending on `settings.HEADLESS_JWT_ROTATE_REFRESH_TOKEN`,
a new refresh token is returned as well.

 * @summary Refresh the access token

 */
export const postAllauthAppV1TokensRefresh = (
  refreshTokenBody: BodyType<RefreshTokenBody>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<RefreshTokenResponse>(
    {
      url: `/api/_allauth/app/v1/tokens/refresh`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: refreshTokenBody,
      signal,
    },
    options,
  );
};

export const getPostAllauthAppV1TokensRefreshMutationOptions = <
  TError = ErrorType<ErrorResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postAllauthAppV1TokensRefresh>>,
    TError,
    { data: BodyType<RefreshTokenBody> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postAllauthAppV1TokensRefresh>>,
  TError,
  { data: BodyType<RefreshTokenBody> },
  TContext
> => {
  const mutationKey = ['postAllauthAppV1TokensRefresh'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postAllauthAppV1TokensRefresh>>,
    { data: BodyType<RefreshTokenBody> }
  > = props => {
    const { data } = props ?? {};

    return postAllauthAppV1TokensRefresh(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostAllauthAppV1TokensRefreshMutationResult = NonNullable<
  Awaited<ReturnType<typeof postAllauthAppV1TokensRefresh>>
>;
export type PostAllauthAppV1TokensRefreshMutationBody = BodyType<RefreshTokenBody>;
export type PostAllauthAppV1TokensRefreshMutationError = ErrorType<ErrorResponse>;

/**
 * @summary Refresh the access token

 */
export const usePostAllauthAppV1TokensRefresh = <
  TError = ErrorType<ErrorResponse>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postAllauthAppV1TokensRefresh>>,
      TError,
      { data: BodyType<RefreshTokenBody> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof postAllauthAppV1TokensRefresh>>,
  TError,
  { data: BodyType<RefreshTokenBody> },
  TContext
> => {
  const mutationOptions = getPostAllauthAppV1TokensRefreshMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * In order to change the password of an account, the current and new
password must be provider.  However, accounts that were created by
signing up using a third-party provider do not have a password set. In
that case, the current password is not required.

 * @summary Change password
 */
export const postAllauthClientV1AccountPasswordChange = (
  client: 'app' | 'browser',
  changePasswordBody: BodyType<ChangePasswordBody>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<unknown>(
    {
      url: `/api/_allauth/${client}/v1/account/password/change`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: changePasswordBody,
      signal,
    },
    options,
  );
};

export const getPostAllauthClientV1AccountPasswordChangeMutationOptions = <
  TError = ErrorType<ErrorResponse | AuthenticationResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postAllauthClientV1AccountPasswordChange>>,
    TError,
    { client: 'app' | 'browser'; data: BodyType<ChangePasswordBody> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postAllauthClientV1AccountPasswordChange>>,
  TError,
  { client: 'app' | 'browser'; data: BodyType<ChangePasswordBody> },
  TContext
> => {
  const mutationKey = ['postAllauthClientV1AccountPasswordChange'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postAllauthClientV1AccountPasswordChange>>,
    { client: 'app' | 'browser'; data: BodyType<ChangePasswordBody> }
  > = props => {
    const { client, data } = props ?? {};

    return postAllauthClientV1AccountPasswordChange(client, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostAllauthClientV1AccountPasswordChangeMutationResult = NonNullable<
  Awaited<ReturnType<typeof postAllauthClientV1AccountPasswordChange>>
>;
export type PostAllauthClientV1AccountPasswordChangeMutationBody = BodyType<ChangePasswordBody>;
export type PostAllauthClientV1AccountPasswordChangeMutationError = ErrorType<
  ErrorResponse | AuthenticationResponse
>;

/**
 * @summary Change password
 */
export const usePostAllauthClientV1AccountPasswordChange = <
  TError = ErrorType<ErrorResponse | AuthenticationResponse>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postAllauthClientV1AccountPasswordChange>>,
      TError,
      { client: 'app' | 'browser'; data: BodyType<ChangePasswordBody> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof postAllauthClientV1AccountPasswordChange>>,
  TError,
  { client: 'app' | 'browser'; data: BodyType<ChangePasswordBody> },
  TContext
> => {
  const mutationOptions = getPostAllauthClientV1AccountPasswordChangeMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary List sessions
 */
export const getAllauthClientV1AuthSessions = (
  client: 'app' | 'browser',
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<SessionsResponse>(
    { url: `/api/_allauth/${client}/v1/auth/sessions`, method: 'GET', signal },
    options,
  );
};

export const getGetAllauthClientV1AuthSessionsQueryKey = (client?: 'app' | 'browser') => {
  return [`/api/_allauth/${client}/v1/auth/sessions`] as const;
};

export const getGetAllauthClientV1AuthSessionsQueryOptions = <
  TData = Awaited<ReturnType<typeof getAllauthClientV1AuthSessions>>,
  TError = ErrorType<unknown>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1AuthSessions>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAllauthClientV1AuthSessionsQueryKey(client);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllauthClientV1AuthSessions>>> = ({
    signal,
  }) => getAllauthClientV1AuthSessions(client, requestOptions, signal);

  return { queryKey, queryFn, enabled: !!client, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getAllauthClientV1AuthSessions>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetAllauthClientV1AuthSessionsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAllauthClientV1AuthSessions>>
>;
export type GetAllauthClientV1AuthSessionsQueryError = ErrorType<unknown>;

export function useGetAllauthClientV1AuthSessions<
  TData = Awaited<ReturnType<typeof getAllauthClientV1AuthSessions>>,
  TError = ErrorType<unknown>,
>(
  client: 'app' | 'browser',
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1AuthSessions>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllauthClientV1AuthSessions>>,
          TError,
          Awaited<ReturnType<typeof getAllauthClientV1AuthSessions>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAllauthClientV1AuthSessions<
  TData = Awaited<ReturnType<typeof getAllauthClientV1AuthSessions>>,
  TError = ErrorType<unknown>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1AuthSessions>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllauthClientV1AuthSessions>>,
          TError,
          Awaited<ReturnType<typeof getAllauthClientV1AuthSessions>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAllauthClientV1AuthSessions<
  TData = Awaited<ReturnType<typeof getAllauthClientV1AuthSessions>>,
  TError = ErrorType<unknown>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1AuthSessions>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary List sessions
 */

export function useGetAllauthClientV1AuthSessions<
  TData = Awaited<ReturnType<typeof getAllauthClientV1AuthSessions>>,
  TError = ErrorType<unknown>,
>(
  client: 'app' | 'browser',
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAllauthClientV1AuthSessions>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetAllauthClientV1AuthSessionsQueryOptions(client, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary End one or more sessions
 */
export const deleteAllauthClientV1AuthSessions = (
  client: 'app' | 'browser',
  endSessionsBody: BodyType<EndSessionsBody>,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<SessionsResponse>(
    {
      url: `/api/_allauth/${client}/v1/auth/sessions`,
      method: 'DELETE',
      headers: { 'Content-Type': 'application/json' },
      data: endSessionsBody,
    },
    options,
  );
};

export const getDeleteAllauthClientV1AuthSessionsMutationOptions = <
  TError = ErrorType<AuthenticationResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteAllauthClientV1AuthSessions>>,
    TError,
    { client: 'app' | 'browser'; data: BodyType<EndSessionsBody> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteAllauthClientV1AuthSessions>>,
  TError,
  { client: 'app' | 'browser'; data: BodyType<EndSessionsBody> },
  TContext
> => {
  const mutationKey = ['deleteAllauthClientV1AuthSessions'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteAllauthClientV1AuthSessions>>,
    { client: 'app' | 'browser'; data: BodyType<EndSessionsBody> }
  > = props => {
    const { client, data } = props ?? {};

    return deleteAllauthClientV1AuthSessions(client, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteAllauthClientV1AuthSessionsMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteAllauthClientV1AuthSessions>>
>;
export type DeleteAllauthClientV1AuthSessionsMutationBody = BodyType<EndSessionsBody>;
export type DeleteAllauthClientV1AuthSessionsMutationError = ErrorType<AuthenticationResponse>;

/**
 * @summary End one or more sessions
 */
export const useDeleteAllauthClientV1AuthSessions = <
  TError = ErrorType<AuthenticationResponse>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteAllauthClientV1AuthSessions>>,
      TError,
      { client: 'app' | 'browser'; data: BodyType<EndSessionsBody> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof deleteAllauthClientV1AuthSessions>>,
  TError,
  { client: 'app' | 'browser'; data: BodyType<EndSessionsBody> },
  TContext
> => {
  const mutationOptions = getDeleteAllauthClientV1AuthSessionsMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
