/**
 * Generated by orval v7.19.0 üç∫
 * Do not edit manually.
 * django-allauth: Headless API
 * # Introduction

Welcome to the django-allauth API specification. This API is intended to be
consumed by two different kind of clients:

- Web applications running in a **browser** context. For example, a
  single-page React application, to which the end user can navigate using a web
  browser.

- Applications, **apps** for short, executing in non-browser contexts. For example,
  a mobile Android or iOS application.

The security considerations for these two usage types are different. In a
browser context, cookies play a role.  Without taking special precautions, your
web application may be vulnerable to Cross-Site Request Forgery attacks.  For
mobile applications, this does not apply.

The API can be used for both use cases. Differences in handling of security is
automatically adjusted for, based on the request path used to make the API call.
For example, signing up can either be done using the
`/_allauth/browser/v1/auth/signup` or the `/_allauth/app/v1/auth/signup`
endpoint. For the **browser** usage, session cookies and CSRF protection
applies. For the **app** usage, cookies play no role, instead, a session token
is used.  The paths of all endpoints are documented in the form of
`/_allauth/{client}/v1/auth/signup`. Depending on the client type (`{client}`),
there may be slight differences in request/response handling.  This is
documented where applicable.


# Scope

The following functionality is all in scope and handled as part of this API:

- Regular accounts:
  - Login
  - Signup
  - Password forgotten
  - Manage email (add, remove, verify, select a different primary)
  - Change password.
  - Verification of email addresses.
- Two-Factor Authentication:
  - Authentication using an authenticator code
  - (De)activate TOTP
  - (Re)generate recovery codes
  - "Trust this browser"
- Third-party providers:
  - Authenticate by performing a browser-level redirect (synchronous request).
  - Authenticate by means of a provider token.
  - Connect additional provider accounts.
  - Disconnect existing provider accounts.
  - Setting a password in case no password was set, yet.
  - Querying additional information before signing up.
- Session management:
  - Listing all sessions for a user.
  - Signing out of any of those sessions.


# Browser Usage

For web applications running in a browser, routing needs to be setup correctly
such that the sessions initiated at the backend are accessible in the frontend.

## Routing

When using the API in a browser context, regular Django sessions are used, along
with the usual session cookies. There are several options for setting up the
routing of your application.


###  Single Domain Routing

With single domain, path-based routing, both your frontend and backend are
served from the same domain, for example `https://app.org`. You will have to
make sure that some paths are served by the frontend, and others by the backend.


### Sub-domain Routing

With sub-domain based routing, the frontend and backend are served from
different domains.  However, as session cookies are used, these different
domains must share common main domain.

For example, you may use `app.project.org` for the frontend, which
interfaces with the backend over at `backend.project.org`.  In this
setup, Django will need to be configured with:

```
SESSION_COOKIE_DOMAIN = "project.org"
CSRF_COOKIE_DOMAIN = "project.org"
```

If your organization hosts unrelated applications, for example, a CMS for
marketing purposes, on the top level domain (`project.org`), it is not advisable
to set the session cookie domain to `project.org`, as those other applications
could get access to the session cookie. In that case, it is advised to use
`backend.app.project.org` for the backend, and set the session cookie domain to
`app.project.org`.


# App Usage

For app based usage, cookies play no role, yet, sessions are still used. When a
user walks through the authentication flow, a session is created.  Having an
authenticated session is proof that the user is allowed to further interact with
the backend. Unauthenticated sessions are also needed to remember state while
the user proceeds to go over the required steps necessary to authenticate.


## Session Tokens

Given that there is no cookie to point to the session, the header
`X-Session-Token` is used instead. The way of working is as follows:

- If you do not have a session token yet, do not send the `X-Session-Token` header.

- When making requests, session tokens can appear in the metadata
  (`meta.session_token`) of authentication related responses. If a session
  token appears, store it (overwriting any previous session token), and ensure
  to add the token to the `X-Session-Token` header of all subsequent requests.

- When receiving an authentication related response with status code 410
  (`Gone`), that is meant to indicate that the session is no longer valid.
  Remove the session token and start clean.


## Access Tokens

While session tokens are required to handle the authentication process,
depending on your requirements, a different type of token may be needed once
authenticated.

For example, your app likely needs access to other APIs as well. These APIs may
 even be implemented using different technologies, in which case having a
 stateless token, possibly a JWT encoding the user ID, might be a good fit.

In this API and its implementation no assumptions, and no (limiting) design
decisions are made in this regard. The token strategy of django-allauth is
pluggable, such that you can expose your own access token when the user
authenticates. As for as the API specification is concerned, the access token
will appear in the response of metadata (`meta.access_token`) of a successful
authentication request. How you can customize the token strategy can be found
over at the documentation of the `allauth.headless` Django application.


# Responses

Unless documented otherwise, responses are objects with the following
properties:
- The `status`, matching the HTTP status code.
- Data, if any, is returned as part of the `data` key.
- Metadata, if any, is returned as part of the `meta` key.
- Errors, if any, are listed in the `errors` key.


# Authentication Flows

In order to become authenticated, the user must complete a flow, potentially
consisting of several steps. For example:
- A login, after which the user is authenticated.
- A Login, followed by two-factor authentication, after which the user is
  authenticated.
- A signup, followed by mandatory email verification, after which the user is
  authenticated.

The API signals to the client that (re)authentication is required by means of a
`401` or `410` status code:
- Not authenticated: status `401`.
- Re-authentication required: status `401`, with `meta.is_authenticated = true`.
- Invalid session: status `410`. This only occurs for clients of type `app`.

All authentication related responses have status `401` or `410`, and,
`meta.is_authenticated` indicating whether authentication, or re-authentication
is required.

The flows the client can perform to initiate or complete the authentication are
communicates as part of authentication related responses. The authentication can
be initiated by means of these flows:
- Login using a local account (`login`).
- Signup for a local account (`signup`).
- Login or signup using the third-party provider redirect flow (`provider_redirect`).
- Login or signup by handing over a third-party provider retrieved elsewhere (`provider_token`).
- Login using a special code (`login_by_code`).
- Login using a passkey (`mfa_login_webauthn`).
- Signup using a passkey (`mfa_signup_webauthn`).

Depending on the state of the account, and the configuration of django-allauth, the flows above
can either lead to becoming directly authenticated, or, to followup flows:
- Provider signup (`provider_signup`).
- Email verification (`verify_email`).
- Phone verification (`phone_email`).
- Two-factor authentication required (TOTP, recovery codes, or WebAuthn) (`mfa_authenticate`).
- Trust this browser (`mfa_trust`).

While authenticated, re-authentication may be required to safeguard the account when sensitive actions
are performed. The re-authentication flows are the following:
- Re-authenticate using password (`reauthenticate`).
- Re-authenticate using a 2FA authenticator (TOTP, recovery codes, or WebAuthn) (`mfa_reauthenticate`).


# Security Considerations

## Input Sanitization

The Django framework, by design, does *not* perform input sanitization. For
example, there is nothing preventing end users from signing up using `<script>`
or `Robert'); DROP TABLE students` as a first name. Django relies on its
template language for proper escaping of such values and mitigate any XSS
attacks.

As a result, any `allauth.headless` client **must** have proper XSS protection
in place as well. Be prepared that, for example, the WebAuthn endpoints could
return authenticator names as follows:

    {
      "name": "<script>alert(1)</script>",
      "credential": {
        "type": "public-key",
        ...
      }
    }
 * OpenAPI spec version: 1
 */
import { useMutation, useQuery } from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query';

import { customInstance } from './mutator/custom-instance';
import type { BodyType, ErrorType } from './mutator/custom-instance';

/**
 * The access token.

 */
export type AccessToken = string;

export type AccountConfigurationLoginMethodsItem =
  (typeof AccountConfigurationLoginMethodsItem)[keyof typeof AccountConfigurationLoginMethodsItem];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AccountConfigurationLoginMethodsItem = {
  email: 'email',
  username: 'username',
} as const;

/**
 * Configuration of the Django `allauth.account` app.

 */
export interface AccountConfiguration {
  email_verification_by_code_enabled: boolean;
  is_open_for_signup: boolean;
  login_by_code_enabled: boolean;
  login_methods?: AccountConfigurationLoginMethodsItem[];
  password_reset_by_code_enabled?: boolean;
}

export interface Authenticated {
  /** A list of methods used to authenticate.
   */
  methods: AuthenticationMethod[];
  user: User;
}

/**
 * Metadata available in an re-authentication related response.

 */
export type AuthenticatedMetaAllOf = {
  is_authenticated: boolean;
};

export type AuthenticatedMeta = BaseAuthenticationMeta & AuthenticatedMetaAllOf;

export interface AuthenticatedResponse {
  data: Authenticated;
  meta: AuthenticationMeta;
  status: StatusOK;
}

/**
 * Metadata available in an authentication related response.

 */
export type AuthenticationMetaAllOf = {
  is_authenticated: boolean;
};

export type AuthenticationMeta = BaseAuthenticationMeta & AuthenticationMetaAllOf;

export type AuthenticationMethodOneOfMethod =
  (typeof AuthenticationMethodOneOfMethod)[keyof typeof AuthenticationMethodOneOfMethod];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AuthenticationMethodOneOfMethod = {
  password: 'password',
} as const;

export type AuthenticationMethodOneOf = {
  at: Timestamp;
  email?: Email;
  method: AuthenticationMethodOneOfMethod;
  username?: Username;
};

export type AuthenticationMethodOneOfThreeMethod =
  (typeof AuthenticationMethodOneOfThreeMethod)[keyof typeof AuthenticationMethodOneOfThreeMethod];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AuthenticationMethodOneOfThreeMethod = {
  passwordReset: 'password_reset',
} as const;

export type AuthenticationMethodOneOfThree = {
  at: Timestamp;
  email: Email;
  method: AuthenticationMethodOneOfThreeMethod;
};

export type AuthenticationMethodOneOfFiveMethod =
  (typeof AuthenticationMethodOneOfFiveMethod)[keyof typeof AuthenticationMethodOneOfFiveMethod];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AuthenticationMethodOneOfFiveMethod = {
  code: 'code',
} as const;

export type AuthenticationMethodOneOfFive = {
  at: Timestamp;
  email: Email;
  method: AuthenticationMethodOneOfFiveMethod;
};

export type AuthenticationMethodOneOfSevenMethod =
  (typeof AuthenticationMethodOneOfSevenMethod)[keyof typeof AuthenticationMethodOneOfSevenMethod];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AuthenticationMethodOneOfSevenMethod = {
  code: 'code',
} as const;

export type AuthenticationMethodOneOfSeven = {
  at: Timestamp;
  method: AuthenticationMethodOneOfSevenMethod;
  phone: Phone;
};

export type AuthenticationMethodOneOfNineMethod =
  (typeof AuthenticationMethodOneOfNineMethod)[keyof typeof AuthenticationMethodOneOfNineMethod];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AuthenticationMethodOneOfNineMethod = {
  password: 'password',
} as const;

export type AuthenticationMethodOneOfNine = {
  at: Timestamp;
  method: AuthenticationMethodOneOfNineMethod;
  reauthenticated: boolean;
};

export type AuthenticationMethodOneOfOneoneMethod =
  (typeof AuthenticationMethodOneOfOneoneMethod)[keyof typeof AuthenticationMethodOneOfOneoneMethod];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AuthenticationMethodOneOfOneoneMethod = {
  socialaccount: 'socialaccount',
} as const;

export type AuthenticationMethodOneOfOneone = {
  at: Timestamp;
  method: AuthenticationMethodOneOfOneoneMethod;
  provider: ProviderID;
  uid: ProviderAccountID;
};

export type AuthenticationMethodOneOfOnethreeMethod =
  (typeof AuthenticationMethodOneOfOnethreeMethod)[keyof typeof AuthenticationMethodOneOfOnethreeMethod];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AuthenticationMethodOneOfOnethreeMethod = {
  mfa: 'mfa',
} as const;

export type AuthenticationMethodOneOfOnethree = {
  at: Timestamp;
  method: AuthenticationMethodOneOfOnethreeMethod;
  reauthenticated?: boolean;
  type: AuthenticatorType;
};

export type AuthenticationMethod =
  | AuthenticationMethodOneOf
  | AuthenticationMethodOneOfThree
  | AuthenticationMethodOneOfFive
  | AuthenticationMethodOneOfSeven
  | AuthenticationMethodOneOfNine
  | AuthenticationMethodOneOfOneone
  | AuthenticationMethodOneOfOnethree;

export type AuthenticationResponseData = {
  flows: Flow[];
};

export type AuthenticationResponseStatus =
  (typeof AuthenticationResponseStatus)[keyof typeof AuthenticationResponseStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AuthenticationResponseStatus = {
  number401: 401,
} as const;

/**
 * An authentication related response.

 */
export interface AuthenticationResponse {
  data: AuthenticationResponseData;
  meta: AuthenticationMeta;
  status: AuthenticationResponseStatus;
}

/**
 * An authenticator code.

 */
export type AuthenticatorCode = string;

/**
 * Authenticator ID.

 */
export type AuthenticatorID = number;

export type AuthenticatorListItem =
  | TOTPAuthenticator
  | RecoveryCodesAuthenticator
  | WebAuthnAuthenticator;

export type AuthenticatorList = AuthenticatorListItem[];

/**
 * The type of authenticator.

 */
export type AuthenticatorType = (typeof AuthenticatorType)[keyof typeof AuthenticatorType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AuthenticatorType = {
  recoveryCodes: 'recovery_codes',
  totp: 'totp',
  webauthn: 'webauthn',
} as const;

export interface BaseAuthenticationMeta {
  /** The access token (`app` clients only).
   */
  access_token?: string;
  /** The session token (`app` clients only).
   */
  session_token?: string;
}

export interface BaseAuthenticator {
  created_at: Timestamp;
  last_used_at: Timestamp;
}

export interface BaseSignup {
  email?: Email;
  username: Username;
}

/**
 * The client ID (in case of OAuth2 or OpenID Connect based providers)

 */
export type ClientID = string;

/**
 * An one-time code.

 */
export type Code = string;

export type ConfigurationResponseData = {
  account: AccountConfiguration;
  mfa?: MFAConfiguration;
  socialaccount?: SocialAccountConfiguration;
  usersessions?: UserSessionsConfiguration;
};

export interface ConfigurationResponse {
  data: ConfigurationResponseData;
  status: StatusOK;
}

export interface ConfirmLoginCode {
  code: Code;
}

export type ConflictResponseStatus =
  (typeof ConflictResponseStatus)[keyof typeof ConflictResponseStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ConflictResponseStatus = {
  number409: 409,
} as const;

export interface ConflictResponse {
  status: ConflictResponseStatus;
}

/**
 * The email address.

 */
export type Email = string;

export interface EmailAddress {
  email: Email;
  primary: boolean;
  verified: boolean;
}

export type EmailVerificationInfoData = {
  email: Email;
  user: User;
};

export type EmailVerificationInfoMeta = {
  is_authenticating: boolean;
};

export interface EmailVerificationInfo {
  data: EmailVerificationInfoData;
  meta: EmailVerificationInfoMeta;
  status: StatusOK;
}

export interface EndSessions {
  /** The IDs of the sessions that are to be ended.
   */
  sessions: number[];
}

export type ErrorResponseErrorsItem = {
  /** An error code.
   */
  code: string;
  /** A human readable error message.
   */
  message: string;
  /** The name of the input parameter that was incorrect.
   */
  param?: string;
};

export type ErrorResponseStatus = (typeof ErrorResponseStatus)[keyof typeof ErrorResponseStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ErrorResponseStatus = {
  number400: 400,
} as const;

export interface ErrorResponse {
  errors?: ErrorResponseErrorsItem[];
  status?: ErrorResponseStatus;
}

export type FlowId = (typeof FlowId)[keyof typeof FlowId];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const FlowId = {
  login: 'login',
  loginByCode: 'login_by_code',
  mfaAuthenticate: 'mfa_authenticate',
  mfaReauthenticate: 'mfa_reauthenticate',
  providerRedirect: 'provider_redirect',
  providerSignup: 'provider_signup',
  providerToken: 'provider_token',
  reauthenticate: 'reauthenticate',
  signup: 'signup',
  verifyEmail: 'verify_email',
  verifyPhone: 'verify_phone',
} as const;

export interface Flow {
  id: FlowId;
  is_pending?: boolean;
  provider?: Provider;
  /** Matches `settings.MFA_SUPPORTED_TYPES`. */
  types?: AuthenticatorType[];
}

export type ForbiddenResponseStatus =
  (typeof ForbiddenResponseStatus)[keyof typeof ForbiddenResponseStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ForbiddenResponseStatus = {
  number403: 403,
} as const;

export interface ForbiddenResponse {
  status: ForbiddenResponseStatus;
}

export type LoginAllOf = {
  password: Password;
};

export type LoginAllOfTwoAnyOf = {
  username: Username;
};

export type LoginAllOfTwoAnyOfTwo = {
  email: Email;
};

export type LoginAllOfTwoAnyOfThree = {
  phone: Phone;
};

export type LoginAllOfTwo = LoginAllOfTwoAnyOf | LoginAllOfTwoAnyOfTwo | LoginAllOfTwoAnyOfThree;

export type Login = LoginAllOf & LoginAllOfTwo;

export interface MFAAuthenticate {
  code: AuthenticatorCode;
}

/**
 * Configuration of the Django `allauth.mfa` app.

 */
export interface MFAConfiguration {
  /** Matches `settings.MFA_SUPPORTED_TYPES`.
   */
  supported_types: AuthenticatorType[];
}

export interface MFATrust {
  trust: boolean;
}

/**
 * @nullable
 */
export type OptionalTimestamp = Timestamp;

export type PasskeySignup = BaseSignup;

/**
 * The password.

 */
export type Password = string;

/**
 * The phone number.

 */
export type Phone = string;

/**
 * A phone number.

 */
export interface PhoneNumber {
  phone: string;
  verified: boolean;
}

export interface PhoneNumberChangeResponse {
  data: PhoneNumber[];
  status: StatusAccepted;
}

export interface PhoneNumbersResponse {
  data: PhoneNumber[];
  status: StatusOK;
}

/**
 * The process to be executed when the user successfully
authenticates. When set to `login`, the user will be logged into the
account to which the provider account is connected, or if no such
account exists, a signup will occur. If set to `connect`, the provider
account will be connected to the list of provider accounts for the
currently authenticated user.

 */
export type Process = (typeof Process)[keyof typeof Process];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const Process = {
  login: 'login',
  connect: 'connect',
} as const;

export type ProviderFlowsItem = (typeof ProviderFlowsItem)[keyof typeof ProviderFlowsItem];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ProviderFlowsItem = {
  providerRedirect: 'provider_redirect',
  providerToken: 'provider_token',
} as const;

export interface Provider {
  /** The client ID (in case of OAuth2 or OpenID Connect based providers)
   */
  client_id?: string;
  /** The authentication flows the provider integration supports.
   */
  flows: ProviderFlowsItem[];
  /** The provider ID.
   */
  id: string;
  /** The name of the provider.
   */
  name: string;
  /** The OIDC discovery or well-known URL (in case of OAuth2 or OpenID Connect based providers)
   */
  openid_configuration_url?: string;
}

export interface ProviderAccount {
  /** A name derived from the third-party provider account data.
   */
  display: string;
  provider: Provider;
  uid: ProviderAccountID;
}

/**
 * The provider specific account ID.

 */
export type ProviderAccountID = string;

/**
 * The provider ID.

 */
export type ProviderID = string;

export type ProviderList = Provider[];

export interface ProviderRedirect {
  /** The URL to return to after the redirect flow is complete.

Note that this is not to be mistaken with the callback URL that you
configure over at the OAuth provider during the OAuth app/client
setup. The flow is as follows:

  1. Your frontend redirects to the headless provider redirect
     endpoint in a synchronous (non-XHR) manner, informing allauth
     (by means of `callback_url`) where to redirect to after the
     provider handshake is completed.

  2. Headless will redirect to the (OAuth) identity provider to
     initiate the handshake, passing along a different callback URL
     to the provider: one that points to an allauth backend URL.
     This is the URL that you need to have setup at your OAuth
     app/client configuration. Note that this must be a backend URL
     as providers can use POST requests to perform their callbacks,
     which is something a frontend would not be able to handle.

  3. After the authorization at the provider is completed, the
     provider redirects to the *backend* allauth callback URL, which
     will then redirect back to the *frontend* callback URL.

  4. Your frontend is now expected to fetch the current session to
     determine what the next course of action is. The user could be
     authenticated at this point, or another flow is pending
     (e.g. email verification, or, provider signup). In case of
     errors a `?error=` is passed to the frontend callback URL.
 */
  callback_url: string;
  process: Process;
  provider: ProviderID;
}

export type ProviderSignup = BaseSignup;

/**
 * The token.

 */
export type ProviderTokenToken = {
  /** The access token.
   */
  access_token?: string;
  client_id: ClientID;
  /** The ID token.
   */
  id_token?: string;
};

export interface ProviderToken {
  process: Process;
  provider: ProviderID;
  /** The token.
   */
  token: ProviderTokenToken;
}

export interface Reauthenticate {
  password: Password;
}

export interface ReauthenticationRequired {
  flows: Flow[];
  /** A list of methods used to authenticate.
   */
  methods: AuthenticationMethod[];
  user: User;
}

export type ReauthenticationResponseStatus =
  (typeof ReauthenticationResponseStatus)[keyof typeof ReauthenticationResponseStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ReauthenticationResponseStatus = {
  number401: 401,
} as const;

/**
 * A response indicating reauthentication is required.

 */
export interface ReauthenticationResponse {
  data: ReauthenticationRequired;
  meta: AuthenticatedMeta;
  status: ReauthenticationResponseStatus;
}

/**
 * The authenticator type.

 */
export type RecoveryCodesAuthenticatorAllOfType =
  (typeof RecoveryCodesAuthenticatorAllOfType)[keyof typeof RecoveryCodesAuthenticatorAllOfType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const RecoveryCodesAuthenticatorAllOfType = {
  recoveryCodes: 'recovery_codes',
} as const;

export type RecoveryCodesAuthenticatorAllOf = {
  /** The total number of recovery codes that initially were available.
   */
  total_code_count: number;
  /** The authenticator type.
   */
  type: RecoveryCodesAuthenticatorAllOfType;
  /** The number of recovery codes that are unused.
   */
  unused_code_count: number;
};

export type RecoveryCodesAuthenticator = BaseAuthenticator & RecoveryCodesAuthenticatorAllOf;

/**
 * The refresh token.

 */
export type RefreshToken = string;

export type RequestLoginCodeAnyOf = {
  phone: Phone;
};

export type RequestLoginCodeAnyOfTwo = {
  email: Email;
};

export type RequestLoginCode = RequestLoginCodeAnyOf | RequestLoginCodeAnyOfTwo;

export interface RequestPassword {
  email: Email;
}

export interface ResetPassword {
  /** The password reset key */
  key: string;
  password: Password;
}

export type SensitiveRecoveryCodesAuthenticatorAllOf = {
  /** The list of unused codes.
   */
  unused_codes: AuthenticatorCode[];
};

export type SensitiveRecoveryCodesAuthenticator = RecoveryCodesAuthenticator &
  SensitiveRecoveryCodesAuthenticatorAllOf;

export interface Session {
  created_at: Timestamp;
  id: number;
  ip: string;
  is_current: boolean;
  last_seen_at?: Timestamp;
  user_agent: string;
}

export type SessionGoneResponseData = { [key: string]: unknown };

export type SessionGoneResponseStatus =
  (typeof SessionGoneResponseStatus)[keyof typeof SessionGoneResponseStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SessionGoneResponseStatus = {
  number410: 410,
} as const;

/**
 * The session is expired or invalid.

 */
export interface SessionGoneResponse {
  data: SessionGoneResponseData;
  meta: AuthenticationMeta;
  status: SessionGoneResponseStatus;
}

export type SignupAllOf = {
  password: Password;
};

export type Signup = BaseSignup & SignupAllOf;

/**
 * Configuration of the Django `allauth.socialaccount` app.

 */
export interface SocialAccountConfiguration {
  providers: ProviderList;
}

export type StatusAccepted = (typeof StatusAccepted)[keyof typeof StatusAccepted];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const StatusAccepted = {
  number202: 202,
} as const;

export type StatusOK = (typeof StatusOK)[keyof typeof StatusOK];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const StatusOK = {
  number200: 200,
} as const;

export type TOTPAuthenticatorAllOfType =
  (typeof TOTPAuthenticatorAllOfType)[keyof typeof TOTPAuthenticatorAllOfType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TOTPAuthenticatorAllOfType = {
  totp: 'totp',
} as const;

export type TOTPAuthenticatorAllOf = {
  type: TOTPAuthenticatorAllOfType;
};

export type TOTPAuthenticator = BaseAuthenticator & TOTPAuthenticatorAllOf;

/**
 * An epoch based timestamp (trivial to parse using: `new Date(value)*1000`)

 */
export type Timestamp = number;

export interface User {
  /** The display name for the user. */
  display: string;
  /** The email address. */
  email?: string;
  /** Whether or not the account has a password set. */
  has_usable_password: boolean;
  /** The user ID. */
  id?: number;
  /** Whether or not the account can view the admin site. */
  is_staff: boolean;
  /** The username. */
  username: string;
}

/**
 * Configuration of the Django `allauth.usersessions` app.

 */
export interface UserSessionsConfiguration {
  /** Matches `settings.USERSESSIONS_TRACK_ACTIVITY`.
   */
  track_activity: boolean;
}

/**
 * The username.

 */
export type Username = string;

export interface VerifyEmail {
  /** The email verification key */
  key: string;
}

export interface VerifyPhone {
  /** The phone verification code */
  code: string;
}

export type WebAuthnAuthenticatorAllOfType =
  (typeof WebAuthnAuthenticatorAllOfType)[keyof typeof WebAuthnAuthenticatorAllOfType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const WebAuthnAuthenticatorAllOfType = {
  webauthn: 'webauthn',
} as const;

export type WebAuthnAuthenticatorAllOf = {
  id: AuthenticatorID;
  /** Whether or not this authenticator represents a passkey. Absent if it is not specified.
   */
  is_passwordless?: boolean;
  name: string;
  type: WebAuthnAuthenticatorAllOfType;
};

export type WebAuthnAuthenticator = BaseAuthenticator & WebAuthnAuthenticatorAllOf;

export interface WebAuthnCredential {
  [key: string]: unknown;
}

export type WebAuthnCredentialCreationOptionsCreationOptions = { [key: string]: unknown };

export interface WebAuthnCredentialCreationOptions {
  creation_options: WebAuthnCredentialCreationOptionsCreationOptions;
}

export type WebAuthnCredentialRequestOptionsRequestOptions = { [key: string]: unknown };

export interface WebAuthnCredentialRequestOptions {
  request_options: WebAuthnCredentialRequestOptionsRequestOptions;
}

/**
 * The account prohibits adding an authenticator, e.g. because of an unverified email address.

 */
export type AddAuthenticatorConflictResponse = ConflictResponse;

export type AddWebAuthnAuthenticatorResponseMeta = {
  /** Whether or not recovery codes where generated automatically.
   */
  recovery_codes_generated?: boolean;
};

export type AddWebAuthnAuthenticatorResponse = {
  data: WebAuthnAuthenticator;
  meta: AddWebAuthnAuthenticatorResponseMeta;
  status: StatusOK;
};

/**
 * Authenticated by code.

 */
export type AuthenticatedByCodeResponse = AuthenticatedResponse;

/**
 * Authenticated by password.

 */
export type AuthenticatedByPasswordResponse = AuthenticatedResponse;

/**
 * Authenticated by password and 2FA.

 */
export type AuthenticatedByPasswordAnd2FAResponse = AuthenticatedResponse;

export type AuthenticationOrReauthenticationResponse =
  | AuthenticationResponse
  | ReauthenticationResponse;

export type AuthenticatorsResponse = {
  data: AuthenticatorList;
  status: StatusOK;
};

export type EmailAddressesResponse = {
  data: EmailAddress[];
  status: StatusOK;
};

/**
 * Email verification information.
 */
export type EmailVerificationInfoResponse = EmailVerificationInfo;

export type NotFoundResponseStatus =
  (typeof NotFoundResponseStatus)[keyof typeof NotFoundResponseStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const NotFoundResponseStatus = {
  number404: 404,
} as const;

export type NotFoundResponse = {
  status: NotFoundResponseStatus;
};

export type PasswordResetInfoResponseData = {
  user?: User;
};

export type PasswordResetInfoResponse = {
  data: PasswordResetInfoResponseData;
  status: StatusOK;
};

export type ProviderAccountsResponse = {
  data: ProviderAccount[];
  status: StatusOK;
};

export type ProviderSignupResponseData = {
  account: ProviderAccount;
  email: EmailAddress[];
  user: User;
};

export type ProviderSignupResponse = {
  data: ProviderSignupResponseData;
  status: StatusOK;
};

/**
 * The response indicates reauthentication is required.

 */
export type ReauthenticationRequiredResponse = ReauthenticationResponse;

export type RecoveryCodesResponse = {
  data: SensitiveRecoveryCodesAuthenticator;
  status: StatusOK;
};

export type RefreshTokenResponseData = {
  access_token: AccessToken;
  refresh_token?: RefreshToken;
};

export type RefreshTokenResponse = {
  data: RefreshTokenResponseData;
  status: StatusOK;
};

export type SessionsResponse = {
  data: Session[];
  status: StatusOK;
};

export type StatusOKResponse = {
  status: StatusOK;
};

export type TOTPAuthenticatorResponseMeta = {
  /** Whether or not recovery codes where generated automatically. */
  recovery_codes_generated?: boolean;
};

export type TOTPAuthenticatorResponse = {
  data: TOTPAuthenticator;
  meta?: TOTPAuthenticatorResponseMeta;
  status: StatusOK;
};

export type TOTPAuthenticatorNotFoundResponseMeta = {
  /** A TOTP secret that can be used to setup a new authenticator.
   */
  secret: string;
  /** otpauth URI from which a QR code can be generated and scanned by OTP clients.
   */
  totp_url: string;
};

export type TOTPAuthenticatorNotFoundResponseStatus =
  (typeof TOTPAuthenticatorNotFoundResponseStatus)[keyof typeof TOTPAuthenticatorNotFoundResponseStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TOTPAuthenticatorNotFoundResponseStatus = {
  number404: 404,
} as const;

export type TOTPAuthenticatorNotFoundResponse = {
  meta: TOTPAuthenticatorNotFoundResponseMeta;
  status: TOTPAuthenticatorNotFoundResponseStatus;
};

export type TooManyRequestsResponseStatus =
  (typeof TooManyRequestsResponseStatus)[keyof typeof TooManyRequestsResponseStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TooManyRequestsResponseStatus = {
  number429: 429,
} as const;

export type TooManyRequestsResponse = {
  status: TooManyRequestsResponseStatus;
};

/**
 * There is no authenticated session.

 */
export type UnauthenticatedResponse = AuthenticationResponse;

export type WebAuthnAuthenticatorResponse = {
  data: WebAuthnAuthenticator;
  status: StatusOK;
};

export type WebAuthnCreationOptionsResponseResponse = {
  data: WebAuthnCredentialCreationOptions;
  status: StatusOK;
};

export type WebAuthnRequestOptionsResponseResponse = {
  data: WebAuthnCredentialRequestOptions;
  status: StatusOK;
};

export type AddWebAuthnAuthenticatorBody = {
  credential: WebAuthnCredential;
  name?: string;
};

export type AuthenticateWebAuthnBody = {
  credential: WebAuthnCredential;
};

export type ChangePasswordBody = {
  current_password?: Password;
  /** The current password.
   */
  new_password: string;
};

export type ConfirmLoginCodeBody = ConfirmLoginCode;

export type DeleteWebAuthnBody = {
  /** The IDs of the authenticator that are to be deleted.
   */
  authenticators: AuthenticatorID[];
};

export type EmailBody = {
  email: Email;
};

export type EndSessionsBody = EndSessions;

/**
 * Login.
 */
export type LoginBody = Login;

export type LoginWebAuthnBody = {
  credential: WebAuthnCredential;
};

export type MFAAuthenticateBody = MFAAuthenticate;

export type MFATrustBody = MFATrust;

export type MarkPrimaryEmailBody = {
  /** An email address.
   */
  email: string;
  /** Primary flag.
   */
  primary: boolean;
};

/**
 * Signup using a passkey
 */
export type PasskeySignupBody = PasskeySignup;

export type PhoneBody = {
  phone: string;
};

export type ProviderAccountBody = {
  account: ProviderAccountID;
  provider: ProviderID;
};

/**
 * Initiate the provider redirect flow.

 */
export type ProviderRedirectBody = ProviderRedirect;

/**
 * Provider signup.
 */
export type ProviderSignupBody = ProviderSignup;

export type ProviderTokenBody = ProviderToken;

/**
 * Reauthenticate.
 */
export type ReauthenticateBody = Reauthenticate;

export type ReauthenticateWebAuthnBody = {
  credential: WebAuthnCredential;
};

export type RefreshTokenBody = {
  refresh_token: RefreshToken;
};

/**
 * Request a login code.
 */
export type RequestLoginCodeBody = RequestLoginCode;

/**
 * Request password.
 */
export type RequestPasswordBody = RequestPassword;

export type ResetPasswordBody = ResetPassword;

export type SetupTOTPBody = {
  code: AuthenticatorCode;
};

/**
 * Signup
 */
export type SignupBody = Signup;

export type UpdateWebAuthnBody = {
  id?: AuthenticatorID;
  name?: string;
};

export type VerifyEmailBody = VerifyEmail;

export type VerifyPhoneBody = VerifyPhone;

/**
 * The email verification key
 */
export type EmailVerificationKeyParameter = string;

/**
 * When present (regardless of its value), enables passwordless sign-in via a WebAuthn credential (Passkey),
but may enforce additional multi-factor authentication (MFA) requirements. Omit the parameter to disable.

 */
export type PasswordLessParameter = boolean;

/**
 * The password reset key
 */
export type PasswordResetKeyParameter = string;

/**
 * Session token. Only needed when `client` is equal to `app`.

 */
export type SessionTokenParameter = string;

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

/**
 * Used to retrieve a new access token. Depending on `settings.HEADLESS_JWT_ROTATE_REFRESH_TOKEN`,
a new refresh token is returned as well.

 * @summary Refresh the access token

 */
export const postTokensRefresh = (
  refreshTokenBody: BodyType<RefreshTokenBody>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<RefreshTokenResponse>(
    {
      url: `/api/_allauth/app/v1/tokens/refresh`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: refreshTokenBody,
      signal,
    },
    options,
  );
};

export const getPostTokensRefreshMutationOptions = <
  TError = ErrorType<ErrorResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postTokensRefresh>>,
    TError,
    { data: BodyType<RefreshTokenBody> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postTokensRefresh>>,
  TError,
  { data: BodyType<RefreshTokenBody> },
  TContext
> => {
  const mutationKey = ['postTokensRefresh'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postTokensRefresh>>,
    { data: BodyType<RefreshTokenBody> }
  > = props => {
    const { data } = props ?? {};

    return postTokensRefresh(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostTokensRefreshMutationResult = NonNullable<
  Awaited<ReturnType<typeof postTokensRefresh>>
>;
export type PostTokensRefreshMutationBody = BodyType<RefreshTokenBody>;
export type PostTokensRefreshMutationError = ErrorType<ErrorResponse>;

/**
 * @summary Refresh the access token

 */
export const usePostTokensRefresh = <TError = ErrorType<ErrorResponse>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postTokensRefresh>>,
      TError,
      { data: BodyType<RefreshTokenBody> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof postTokensRefresh>>,
  TError,
  { data: BodyType<RefreshTokenBody> },
  TContext
> => {
  const mutationOptions = getPostTokensRefreshMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Initiates the third-party provider authentication redirect flow. As calling
this endpoint results in a user facing redirect (302), this call is only
available in a browser, and must be called in a synchronous (non-XHR)
manner.

 * @summary Provider redirect
 */
export const postAuthProviderRedirect = (
  providerRedirectBody: BodyType<ProviderRedirectBody>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  const formUrlEncoded = new URLSearchParams();
  formUrlEncoded.append(`callback_url`, providerRedirectBody.callback_url);
  formUrlEncoded.append(`process`, providerRedirectBody.process);
  formUrlEncoded.append(`provider`, providerRedirectBody.provider);

  return customInstance<unknown>(
    {
      url: `/api/_allauth/browser/v1/auth/provider/redirect`,
      method: 'POST',
      headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
      data: formUrlEncoded,
      signal,
    },
    options,
  );
};

export const getPostAuthProviderRedirectMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postAuthProviderRedirect>>,
    TError,
    { data: BodyType<ProviderRedirectBody> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postAuthProviderRedirect>>,
  TError,
  { data: BodyType<ProviderRedirectBody> },
  TContext
> => {
  const mutationKey = ['postAuthProviderRedirect'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postAuthProviderRedirect>>,
    { data: BodyType<ProviderRedirectBody> }
  > = props => {
    const { data } = props ?? {};

    return postAuthProviderRedirect(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostAuthProviderRedirectMutationResult = NonNullable<
  Awaited<ReturnType<typeof postAuthProviderRedirect>>
>;
export type PostAuthProviderRedirectMutationBody = BodyType<ProviderRedirectBody>;
export type PostAuthProviderRedirectMutationError = ErrorType<void>;

/**
 * @summary Provider redirect
 */
export const usePostAuthProviderRedirect = <TError = ErrorType<void>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postAuthProviderRedirect>>,
      TError,
      { data: BodyType<ProviderRedirectBody> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof postAuthProviderRedirect>>,
  TError,
  { data: BodyType<ProviderRedirectBody> },
  TContext
> => {
  const mutationOptions = getPostAuthProviderRedirectMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Used to remove an email address.

 * @summary Remove an email address
 */
export const deleteAccountEmail = (
  emailBody: BodyType<EmailBody>,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<EmailAddressesResponse>(
    {
      url: `/api/_allauth/browser/v1/account/email`,
      method: 'DELETE',
      headers: { 'Content-Type': 'application/json' },
      data: emailBody,
    },
    options,
  );
};

export const getDeleteAccountEmailMutationOptions = <
  TError = ErrorType<ErrorResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteAccountEmail>>,
    TError,
    { data: BodyType<EmailBody> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteAccountEmail>>,
  TError,
  { data: BodyType<EmailBody> },
  TContext
> => {
  const mutationKey = ['deleteAccountEmail'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteAccountEmail>>,
    { data: BodyType<EmailBody> }
  > = props => {
    const { data } = props ?? {};

    return deleteAccountEmail(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteAccountEmailMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteAccountEmail>>
>;
export type DeleteAccountEmailMutationBody = BodyType<EmailBody>;
export type DeleteAccountEmailMutationError = ErrorType<ErrorResponse>;

/**
 * @summary Remove an email address
 */
export const useDeleteAccountEmail = <TError = ErrorType<ErrorResponse>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteAccountEmail>>,
      TError,
      { data: BodyType<EmailBody> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof deleteAccountEmail>>,
  TError,
  { data: BodyType<EmailBody> },
  TContext
> => {
  const mutationOptions = getDeleteAccountEmailMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Retrieves the list of email addresses of the account.

 * @summary List email addresses
 */
export const getAccountEmail = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<EmailAddressesResponse>(
    { url: `/api/_allauth/browser/v1/account/email`, method: 'GET', signal },
    options,
  );
};

export const getGetAccountEmailQueryKey = () => {
  return [`/api/_allauth/browser/v1/account/email`] as const;
};

export const getGetAccountEmailQueryOptions = <
  TData = Awaited<ReturnType<typeof getAccountEmail>>,
  TError = ErrorType<AuthenticationResponse>,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAccountEmail>>, TError, TData>>;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAccountEmailQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAccountEmail>>> = ({ signal }) =>
    getAccountEmail(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getAccountEmail>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetAccountEmailQueryResult = NonNullable<Awaited<ReturnType<typeof getAccountEmail>>>;
export type GetAccountEmailQueryError = ErrorType<AuthenticationResponse>;

export function useGetAccountEmail<
  TData = Awaited<ReturnType<typeof getAccountEmail>>,
  TError = ErrorType<AuthenticationResponse>,
>(
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAccountEmail>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAccountEmail>>,
          TError,
          Awaited<ReturnType<typeof getAccountEmail>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAccountEmail<
  TData = Awaited<ReturnType<typeof getAccountEmail>>,
  TError = ErrorType<AuthenticationResponse>,
>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAccountEmail>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAccountEmail>>,
          TError,
          Awaited<ReturnType<typeof getAccountEmail>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAccountEmail<
  TData = Awaited<ReturnType<typeof getAccountEmail>>,
  TError = ErrorType<AuthenticationResponse>,
>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAccountEmail>>, TError, TData>>;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary List email addresses
 */

export function useGetAccountEmail<
  TData = Awaited<ReturnType<typeof getAccountEmail>>,
  TError = ErrorType<AuthenticationResponse>,
>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAccountEmail>>, TError, TData>>;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetAccountEmailQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Used to change primary email address to a different one. Note that only verified email addresses
can be marked as primary.

 * @summary Change primary email address
 */
export const patchAccountEmail = (
  markPrimaryEmailBody: BodyType<MarkPrimaryEmailBody>,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<EmailAddressesResponse>(
    {
      url: `/api/_allauth/browser/v1/account/email`,
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      data: markPrimaryEmailBody,
    },
    options,
  );
};

export const getPatchAccountEmailMutationOptions = <
  TError = ErrorType<ErrorResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof patchAccountEmail>>,
    TError,
    { data: BodyType<MarkPrimaryEmailBody> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof patchAccountEmail>>,
  TError,
  { data: BodyType<MarkPrimaryEmailBody> },
  TContext
> => {
  const mutationKey = ['patchAccountEmail'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof patchAccountEmail>>,
    { data: BodyType<MarkPrimaryEmailBody> }
  > = props => {
    const { data } = props ?? {};

    return patchAccountEmail(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PatchAccountEmailMutationResult = NonNullable<
  Awaited<ReturnType<typeof patchAccountEmail>>
>;
export type PatchAccountEmailMutationBody = BodyType<MarkPrimaryEmailBody>;
export type PatchAccountEmailMutationError = ErrorType<ErrorResponse>;

/**
 * @summary Change primary email address
 */
export const usePatchAccountEmail = <TError = ErrorType<ErrorResponse>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof patchAccountEmail>>,
      TError,
      { data: BodyType<MarkPrimaryEmailBody> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof patchAccountEmail>>,
  TError,
  { data: BodyType<MarkPrimaryEmailBody> },
  TContext
> => {
  const mutationOptions = getPatchAccountEmailMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * The following functionality is available:

  - Adding a new email address for an already signed in user (`ACCOUNT_CHANGE_EMAIL = False`).
  - Change to a new email address for an already signed in user   (`ACCOUNT_CHANGE_EMAIL = True`).
  - Change to a new email address during the email verification process at signup (`ACCOUNT_EMAIL_VERIFICATION_SUPPORTS_CHANGE = True`).

In all cases, an email verification mail will be sent containing a link or code that needs to be verified.

 * @summary Add/Change email address

 */
export const postAccountEmail = (
  emailBody: BodyType<EmailBody>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<EmailAddressesResponse>(
    {
      url: `/api/_allauth/browser/v1/account/email`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: emailBody,
      signal,
    },
    options,
  );
};

export const getPostAccountEmailMutationOptions = <
  TError = ErrorType<ErrorResponse | AuthenticationOrReauthenticationResponse | ConflictResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postAccountEmail>>,
    TError,
    { data: BodyType<EmailBody> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postAccountEmail>>,
  TError,
  { data: BodyType<EmailBody> },
  TContext
> => {
  const mutationKey = ['postAccountEmail'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postAccountEmail>>,
    { data: BodyType<EmailBody> }
  > = props => {
    const { data } = props ?? {};

    return postAccountEmail(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostAccountEmailMutationResult = NonNullable<
  Awaited<ReturnType<typeof postAccountEmail>>
>;
export type PostAccountEmailMutationBody = BodyType<EmailBody>;
export type PostAccountEmailMutationError = ErrorType<
  ErrorResponse | AuthenticationOrReauthenticationResponse | ConflictResponse
>;

/**
 * @summary Add/Change email address

 */
export const usePostAccountEmail = <
  TError = ErrorType<ErrorResponse | AuthenticationOrReauthenticationResponse | ConflictResponse>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postAccountEmail>>,
      TError,
      { data: BodyType<EmailBody> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof postAccountEmail>>,
  TError,
  { data: BodyType<EmailBody> },
  TContext
> => {
  const mutationOptions = getPostAccountEmailMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Requests for (another) email verification email to be sent. Note that
sending emails is rate limited, so when you send too many requests the
email will not be sent.

 * @summary Request email verification
 */
export const putAccountEmail = (
  emailBody: BodyType<EmailBody>,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<StatusOKResponse>(
    {
      url: `/api/_allauth/browser/v1/account/email`,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      data: emailBody,
    },
    options,
  );
};

export const getPutAccountEmailMutationOptions = <
  TError = ErrorType<ErrorResponse | ForbiddenResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof putAccountEmail>>,
    TError,
    { data: BodyType<EmailBody> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof putAccountEmail>>,
  TError,
  { data: BodyType<EmailBody> },
  TContext
> => {
  const mutationKey = ['putAccountEmail'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof putAccountEmail>>,
    { data: BodyType<EmailBody> }
  > = props => {
    const { data } = props ?? {};

    return putAccountEmail(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PutAccountEmailMutationResult = NonNullable<
  Awaited<ReturnType<typeof putAccountEmail>>
>;
export type PutAccountEmailMutationBody = BodyType<EmailBody>;
export type PutAccountEmailMutationError = ErrorType<ErrorResponse | ForbiddenResponse>;

/**
 * @summary Request email verification
 */
export const usePutAccountEmail = <
  TError = ErrorType<ErrorResponse | ForbiddenResponse>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof putAccountEmail>>,
      TError,
      { data: BodyType<EmailBody> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof putAccountEmail>>,
  TError,
  { data: BodyType<EmailBody> },
  TContext
> => {
  const mutationOptions = getPutAccountEmailMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * In order to change the password of an account, the current and new
password must be provider.  However, accounts that were created by
signing up using a third-party provider do not have a password set. In
that case, the current password is not required.

 * @summary Change password
 */
export const postAccountPasswordChange = (
  changePasswordBody: BodyType<ChangePasswordBody>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<unknown>(
    {
      url: `/api/_allauth/browser/v1/account/password/change`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: changePasswordBody,
      signal,
    },
    options,
  );
};

export const getPostAccountPasswordChangeMutationOptions = <
  TError = ErrorType<ErrorResponse | AuthenticationResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postAccountPasswordChange>>,
    TError,
    { data: BodyType<ChangePasswordBody> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postAccountPasswordChange>>,
  TError,
  { data: BodyType<ChangePasswordBody> },
  TContext
> => {
  const mutationKey = ['postAccountPasswordChange'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postAccountPasswordChange>>,
    { data: BodyType<ChangePasswordBody> }
  > = props => {
    const { data } = props ?? {};

    return postAccountPasswordChange(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostAccountPasswordChangeMutationResult = NonNullable<
  Awaited<ReturnType<typeof postAccountPasswordChange>>
>;
export type PostAccountPasswordChangeMutationBody = BodyType<ChangePasswordBody>;
export type PostAccountPasswordChangeMutationError = ErrorType<
  ErrorResponse | AuthenticationResponse
>;

/**
 * @summary Change password
 */
export const usePostAccountPasswordChange = <
  TError = ErrorType<ErrorResponse | AuthenticationResponse>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postAccountPasswordChange>>,
      TError,
      { data: BodyType<ChangePasswordBody> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof postAccountPasswordChange>>,
  TError,
  { data: BodyType<ChangePasswordBody> },
  TContext
> => {
  const mutationOptions = getPostAccountPasswordChangeMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Retrieves the phone number of the account, if any. Note that while the
endpoint returns a list of phone numbers, at most one entry is returned.

 * @summary Get the phone number
 */
export const getAccountPhone = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<PhoneNumbersResponse>(
    { url: `/api/_allauth/browser/v1/account/phone`, method: 'GET', signal },
    options,
  );
};

export const getGetAccountPhoneQueryKey = () => {
  return [`/api/_allauth/browser/v1/account/phone`] as const;
};

export const getGetAccountPhoneQueryOptions = <
  TData = Awaited<ReturnType<typeof getAccountPhone>>,
  TError = ErrorType<AuthenticationResponse>,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAccountPhone>>, TError, TData>>;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAccountPhoneQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAccountPhone>>> = ({ signal }) =>
    getAccountPhone(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getAccountPhone>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetAccountPhoneQueryResult = NonNullable<Awaited<ReturnType<typeof getAccountPhone>>>;
export type GetAccountPhoneQueryError = ErrorType<AuthenticationResponse>;

export function useGetAccountPhone<
  TData = Awaited<ReturnType<typeof getAccountPhone>>,
  TError = ErrorType<AuthenticationResponse>,
>(
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAccountPhone>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAccountPhone>>,
          TError,
          Awaited<ReturnType<typeof getAccountPhone>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAccountPhone<
  TData = Awaited<ReturnType<typeof getAccountPhone>>,
  TError = ErrorType<AuthenticationResponse>,
>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAccountPhone>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAccountPhone>>,
          TError,
          Awaited<ReturnType<typeof getAccountPhone>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAccountPhone<
  TData = Awaited<ReturnType<typeof getAccountPhone>>,
  TError = ErrorType<AuthenticationResponse>,
>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAccountPhone>>, TError, TData>>;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get the phone number
 */

export function useGetAccountPhone<
  TData = Awaited<ReturnType<typeof getAccountPhone>>,
  TError = ErrorType<AuthenticationResponse>,
>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAccountPhone>>, TError, TData>>;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetAccountPhoneQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * The following functionality is available:

- Initiate the phone number change process for signed in users.
- Change to a new phone number during the phone number verification
  process at signup for unauthenticated users. Note that this requires:
  `ACCOUNT_PHONE_VERIFICATION_SUPPORTS_CHANGE = True`.

In both cases, after posting a new phone number, proceed with the phone
verification endpoint to confirm the change of the phone number by
posting the verification code.

 * @summary Change the phone number

 */
export const postAccountPhone = (
  phoneBody: BodyType<PhoneBody>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<PhoneNumberChangeResponse>(
    {
      url: `/api/_allauth/browser/v1/account/phone`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: phoneBody,
      signal,
    },
    options,
  );
};

export const getPostAccountPhoneMutationOptions = <
  TError = ErrorType<ErrorResponse | AuthenticationOrReauthenticationResponse | ConflictResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postAccountPhone>>,
    TError,
    { data: BodyType<PhoneBody> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postAccountPhone>>,
  TError,
  { data: BodyType<PhoneBody> },
  TContext
> => {
  const mutationKey = ['postAccountPhone'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postAccountPhone>>,
    { data: BodyType<PhoneBody> }
  > = props => {
    const { data } = props ?? {};

    return postAccountPhone(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostAccountPhoneMutationResult = NonNullable<
  Awaited<ReturnType<typeof postAccountPhone>>
>;
export type PostAccountPhoneMutationBody = BodyType<PhoneBody>;
export type PostAccountPhoneMutationError = ErrorType<
  ErrorResponse | AuthenticationOrReauthenticationResponse | ConflictResponse
>;

/**
 * @summary Change the phone number

 */
export const usePostAccountPhone = <
  TError = ErrorType<ErrorResponse | AuthenticationOrReauthenticationResponse | ConflictResponse>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postAccountPhone>>,
      TError,
      { data: BodyType<PhoneBody> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof postAccountPhone>>,
  TError,
  { data: BodyType<PhoneBody> },
  TContext
> => {
  const mutationOptions = getPostAccountPhoneMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Disconnect a third-party provider account, returning the remaining
accounts that are still connected. The disconnect is not allowed if it
would leave the account unusable. For example, if no password was
set up yet.

 * @summary Disconnect a third-party provider account

 */
export const deleteAccountProviders = (
  providerAccountBody: BodyType<ProviderAccountBody>,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<ProviderAccountsResponse>(
    {
      url: `/api/_allauth/browser/v1/account/providers`,
      method: 'DELETE',
      headers: { 'Content-Type': 'application/json' },
      data: providerAccountBody,
    },
    options,
  );
};

export const getDeleteAccountProvidersMutationOptions = <
  TError = ErrorType<ErrorResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteAccountProviders>>,
    TError,
    { data: BodyType<ProviderAccountBody> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteAccountProviders>>,
  TError,
  { data: BodyType<ProviderAccountBody> },
  TContext
> => {
  const mutationKey = ['deleteAccountProviders'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteAccountProviders>>,
    { data: BodyType<ProviderAccountBody> }
  > = props => {
    const { data } = props ?? {};

    return deleteAccountProviders(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteAccountProvidersMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteAccountProviders>>
>;
export type DeleteAccountProvidersMutationBody = BodyType<ProviderAccountBody>;
export type DeleteAccountProvidersMutationError = ErrorType<ErrorResponse>;

/**
 * @summary Disconnect a third-party provider account

 */
export const useDeleteAccountProviders = <TError = ErrorType<ErrorResponse>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteAccountProviders>>,
      TError,
      { data: BodyType<ProviderAccountBody> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof deleteAccountProviders>>,
  TError,
  { data: BodyType<ProviderAccountBody> },
  TContext
> => {
  const mutationOptions = getDeleteAccountProvidersMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary List the connected third-party provider accounts
 */
export const getAccountProviders = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<ProviderAccountsResponse>(
    { url: `/api/_allauth/browser/v1/account/providers`, method: 'GET', signal },
    options,
  );
};

export const getGetAccountProvidersQueryKey = () => {
  return [`/api/_allauth/browser/v1/account/providers`] as const;
};

export const getGetAccountProvidersQueryOptions = <
  TData = Awaited<ReturnType<typeof getAccountProviders>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAccountProviders>>, TError, TData>>;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAccountProvidersQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAccountProviders>>> = ({ signal }) =>
    getAccountProviders(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getAccountProviders>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetAccountProvidersQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAccountProviders>>
>;
export type GetAccountProvidersQueryError = ErrorType<unknown>;

export function useGetAccountProviders<
  TData = Awaited<ReturnType<typeof getAccountProviders>>,
  TError = ErrorType<unknown>,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAccountProviders>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAccountProviders>>,
          TError,
          Awaited<ReturnType<typeof getAccountProviders>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAccountProviders<
  TData = Awaited<ReturnType<typeof getAccountProviders>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAccountProviders>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAccountProviders>>,
          TError,
          Awaited<ReturnType<typeof getAccountProviders>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAccountProviders<
  TData = Awaited<ReturnType<typeof getAccountProviders>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAccountProviders>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary List the connected third-party provider accounts
 */

export function useGetAccountProviders<
  TData = Awaited<ReturnType<typeof getAccountProviders>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAccountProviders>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetAccountProvidersQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Use this endpoint to pass along the received "special" login code.

 * @summary Confirm login code
 */
export const postAuthCodeConfirm = (
  confirmLoginCodeBody: BodyType<ConfirmLoginCodeBody>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<AuthenticatedByCodeResponse>(
    {
      url: `/api/_allauth/browser/v1/auth/code/confirm`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: confirmLoginCodeBody,
      signal,
    },
    options,
  );
};

export const getPostAuthCodeConfirmMutationOptions = <
  TError = ErrorType<ErrorResponse | AuthenticationResponse | ConflictResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postAuthCodeConfirm>>,
    TError,
    { data: BodyType<ConfirmLoginCodeBody> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postAuthCodeConfirm>>,
  TError,
  { data: BodyType<ConfirmLoginCodeBody> },
  TContext
> => {
  const mutationKey = ['postAuthCodeConfirm'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postAuthCodeConfirm>>,
    { data: BodyType<ConfirmLoginCodeBody> }
  > = props => {
    const { data } = props ?? {};

    return postAuthCodeConfirm(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostAuthCodeConfirmMutationResult = NonNullable<
  Awaited<ReturnType<typeof postAuthCodeConfirm>>
>;
export type PostAuthCodeConfirmMutationBody = BodyType<ConfirmLoginCodeBody>;
export type PostAuthCodeConfirmMutationError = ErrorType<
  ErrorResponse | AuthenticationResponse | ConflictResponse
>;

/**
 * @summary Confirm login code
 */
export const usePostAuthCodeConfirm = <
  TError = ErrorType<ErrorResponse | AuthenticationResponse | ConflictResponse>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postAuthCodeConfirm>>,
      TError,
      { data: BodyType<ConfirmLoginCodeBody> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof postAuthCodeConfirm>>,
  TError,
  { data: BodyType<ConfirmLoginCodeBody> },
  TContext
> => {
  const mutationOptions = getPostAuthCodeConfirmMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Obtain email verification information, given the token that was sent to
the user by email.

 * @summary Get email verification information
 */
export const getAuthEmailVerify = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<EmailVerificationInfoResponse>(
    { url: `/api/_allauth/browser/v1/auth/email/verify`, method: 'GET', signal },
    options,
  );
};

export const getGetAuthEmailVerifyQueryKey = () => {
  return [`/api/_allauth/browser/v1/auth/email/verify`] as const;
};

export const getGetAuthEmailVerifyQueryOptions = <
  TData = Awaited<ReturnType<typeof getAuthEmailVerify>>,
  TError = ErrorType<ErrorResponse | ConflictResponse>,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAuthEmailVerify>>, TError, TData>>;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAuthEmailVerifyQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAuthEmailVerify>>> = ({ signal }) =>
    getAuthEmailVerify(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getAuthEmailVerify>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetAuthEmailVerifyQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAuthEmailVerify>>
>;
export type GetAuthEmailVerifyQueryError = ErrorType<ErrorResponse | ConflictResponse>;

export function useGetAuthEmailVerify<
  TData = Awaited<ReturnType<typeof getAuthEmailVerify>>,
  TError = ErrorType<ErrorResponse | ConflictResponse>,
>(
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAuthEmailVerify>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAuthEmailVerify>>,
          TError,
          Awaited<ReturnType<typeof getAuthEmailVerify>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAuthEmailVerify<
  TData = Awaited<ReturnType<typeof getAuthEmailVerify>>,
  TError = ErrorType<ErrorResponse | ConflictResponse>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAuthEmailVerify>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAuthEmailVerify>>,
          TError,
          Awaited<ReturnType<typeof getAuthEmailVerify>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAuthEmailVerify<
  TData = Awaited<ReturnType<typeof getAuthEmailVerify>>,
  TError = ErrorType<ErrorResponse | ConflictResponse>,
>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAuthEmailVerify>>, TError, TData>>;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get email verification information
 */

export function useGetAuthEmailVerify<
  TData = Awaited<ReturnType<typeof getAuthEmailVerify>>,
  TError = ErrorType<ErrorResponse | ConflictResponse>,
>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAuthEmailVerify>>, TError, TData>>;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetAuthEmailVerifyQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Complete the email verification process. Depending on the configuration,
email addresses are either verified by opening a link that is sent to
their email address, or, by inputting a code that is sent. On the API,
both cases are handled identically. Meaning, the required key is either
the one from the link, or, the code itself.

Note that a status code of 401 does not imply failure. It indicates that
the email verification was successful, yet, the user is still not signed
in. For example, in case `ACCOUNT_LOGIN_ON_EMAIL_CONFIRMATION` is set to
`False`, a 401 is returned when verifying as part of login/signup.

 * @summary Verify an email
 */
export const postAuthEmailVerify = (
  verifyEmailBody: BodyType<VerifyEmailBody>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<AuthenticatedResponse>(
    {
      url: `/api/_allauth/browser/v1/auth/email/verify`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: verifyEmailBody,
      signal,
    },
    options,
  );
};

export const getPostAuthEmailVerifyMutationOptions = <
  TError = ErrorType<ErrorResponse | UnauthenticatedResponse | ConflictResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postAuthEmailVerify>>,
    TError,
    { data: BodyType<VerifyEmailBody> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postAuthEmailVerify>>,
  TError,
  { data: BodyType<VerifyEmailBody> },
  TContext
> => {
  const mutationKey = ['postAuthEmailVerify'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postAuthEmailVerify>>,
    { data: BodyType<VerifyEmailBody> }
  > = props => {
    const { data } = props ?? {};

    return postAuthEmailVerify(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostAuthEmailVerifyMutationResult = NonNullable<
  Awaited<ReturnType<typeof postAuthEmailVerify>>
>;
export type PostAuthEmailVerifyMutationBody = BodyType<VerifyEmailBody>;
export type PostAuthEmailVerifyMutationError = ErrorType<
  ErrorResponse | UnauthenticatedResponse | ConflictResponse
>;

/**
 * @summary Verify an email
 */
export const usePostAuthEmailVerify = <
  TError = ErrorType<ErrorResponse | UnauthenticatedResponse | ConflictResponse>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postAuthEmailVerify>>,
      TError,
      { data: BodyType<VerifyEmailBody> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof postAuthEmailVerify>>,
  TError,
  { data: BodyType<VerifyEmailBody> },
  TContext
> => {
  const mutationOptions = getPostAuthEmailVerifyMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Requests a new email verification code.
Requires `ACCOUNT_EMAIL_VERIFICATION_SUPPORTS_RESEND = True`.

 * @summary Resend email verification code
 */
export const postAuthEmailVerifyResend = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<StatusOKResponse>(
    { url: `/api/_allauth/browser/v1/auth/email/verify/resend`, method: 'POST', signal },
    options,
  );
};

export const getPostAuthEmailVerifyResendMutationOptions = <
  TError = ErrorType<ConflictResponse | TooManyRequestsResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postAuthEmailVerifyResend>>,
    TError,
    void,
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postAuthEmailVerifyResend>>,
  TError,
  void,
  TContext
> => {
  const mutationKey = ['postAuthEmailVerifyResend'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postAuthEmailVerifyResend>>,
    void
  > = () => {
    return postAuthEmailVerifyResend(requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostAuthEmailVerifyResendMutationResult = NonNullable<
  Awaited<ReturnType<typeof postAuthEmailVerifyResend>>
>;

export type PostAuthEmailVerifyResendMutationError = ErrorType<
  ConflictResponse | TooManyRequestsResponse
>;

/**
 * @summary Resend email verification code
 */
export const usePostAuthEmailVerifyResend = <
  TError = ErrorType<ConflictResponse | TooManyRequestsResponse>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postAuthEmailVerifyResend>>,
      TError,
      void,
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof postAuthEmailVerifyResend>>,
  TError,
  void,
  TContext
> => {
  const mutationOptions = getPostAuthEmailVerifyResendMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Login using a username-password or email-password combination.

 * @summary Login
 */
export const postAuthLogin = (
  loginBody: BodyType<LoginBody>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<AuthenticatedByPasswordResponse>(
    {
      url: `/api/_allauth/browser/v1/auth/login`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: loginBody,
      signal,
    },
    options,
  );
};

export const getPostAuthLoginMutationOptions = <
  TError = ErrorType<ErrorResponse | AuthenticationResponse | ConflictResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postAuthLogin>>,
    TError,
    { data: BodyType<LoginBody> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postAuthLogin>>,
  TError,
  { data: BodyType<LoginBody> },
  TContext
> => {
  const mutationKey = ['postAuthLogin'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postAuthLogin>>,
    { data: BodyType<LoginBody> }
  > = props => {
    const { data } = props ?? {};

    return postAuthLogin(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostAuthLoginMutationResult = NonNullable<Awaited<ReturnType<typeof postAuthLogin>>>;
export type PostAuthLoginMutationBody = BodyType<LoginBody>;
export type PostAuthLoginMutationError = ErrorType<
  ErrorResponse | AuthenticationResponse | ConflictResponse
>;

/**
 * @summary Login
 */
export const usePostAuthLogin = <
  TError = ErrorType<ErrorResponse | AuthenticationResponse | ConflictResponse>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postAuthLogin>>,
      TError,
      { data: BodyType<LoginBody> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof postAuthLogin>>,
  TError,
  { data: BodyType<LoginBody> },
  TContext
> => {
  const mutationOptions = getPostAuthLoginMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Initiates the password reset procedure. Depending on whether or not
`ACCOUNT_PASSWORD_RESET_BY_CODE_ENABLED` is `True`, the procedure is
either stateless or stateful.

In case codes are used, it is stateful, and a new
`password_reset_by_code` flow is started. In this case, on a successful
password reset request, you will receive a 401 indicating the pending
status of this flow.

In case password reset is configured to use (stateless) links, you will
receive a 200 on a successful password reset request.

 * @summary Request password
 */
export const postAuthPasswordRequest = (
  requestPasswordBody: BodyType<RequestPasswordBody>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<StatusOKResponse>(
    {
      url: `/api/_allauth/browser/v1/auth/password/request`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: requestPasswordBody,
      signal,
    },
    options,
  );
};

export const getPostAuthPasswordRequestMutationOptions = <
  TError = ErrorType<ErrorResponse | AuthenticationResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postAuthPasswordRequest>>,
    TError,
    { data: BodyType<RequestPasswordBody> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postAuthPasswordRequest>>,
  TError,
  { data: BodyType<RequestPasswordBody> },
  TContext
> => {
  const mutationKey = ['postAuthPasswordRequest'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postAuthPasswordRequest>>,
    { data: BodyType<RequestPasswordBody> }
  > = props => {
    const { data } = props ?? {};

    return postAuthPasswordRequest(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostAuthPasswordRequestMutationResult = NonNullable<
  Awaited<ReturnType<typeof postAuthPasswordRequest>>
>;
export type PostAuthPasswordRequestMutationBody = BodyType<RequestPasswordBody>;
export type PostAuthPasswordRequestMutationError = ErrorType<
  ErrorResponse | AuthenticationResponse
>;

/**
 * @summary Request password
 */
export const usePostAuthPasswordRequest = <
  TError = ErrorType<ErrorResponse | AuthenticationResponse>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postAuthPasswordRequest>>,
      TError,
      { data: BodyType<RequestPasswordBody> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof postAuthPasswordRequest>>,
  TError,
  { data: BodyType<RequestPasswordBody> },
  TContext
> => {
  const mutationOptions = getPostAuthPasswordRequestMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Used to obtain information on and validate a password reset key.  The
key passed is either the key encoded in the password reset URL that the
user has received per email, or, the password reset code in case of
`ACCOUNT_PASSWORD_RESET_BY_CODE_ENABLED`. Note that in case of a code,
the number of requests you can make is limited (by
`ACCOUNT_PASSWORD_RESET_BY_CODE_MAX_ATTEMPTS`).

 * @summary Get password reset information
 */
export const getAuthPasswordReset = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<PasswordResetInfoResponse>(
    { url: `/api/_allauth/browser/v1/auth/password/reset`, method: 'GET', signal },
    options,
  );
};

export const getGetAuthPasswordResetQueryKey = () => {
  return [`/api/_allauth/browser/v1/auth/password/reset`] as const;
};

export const getGetAuthPasswordResetQueryOptions = <
  TData = Awaited<ReturnType<typeof getAuthPasswordReset>>,
  TError = ErrorType<ErrorResponse | ConflictResponse>,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAuthPasswordReset>>, TError, TData>>;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAuthPasswordResetQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAuthPasswordReset>>> = ({ signal }) =>
    getAuthPasswordReset(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getAuthPasswordReset>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetAuthPasswordResetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAuthPasswordReset>>
>;
export type GetAuthPasswordResetQueryError = ErrorType<ErrorResponse | ConflictResponse>;

export function useGetAuthPasswordReset<
  TData = Awaited<ReturnType<typeof getAuthPasswordReset>>,
  TError = ErrorType<ErrorResponse | ConflictResponse>,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAuthPasswordReset>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAuthPasswordReset>>,
          TError,
          Awaited<ReturnType<typeof getAuthPasswordReset>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAuthPasswordReset<
  TData = Awaited<ReturnType<typeof getAuthPasswordReset>>,
  TError = ErrorType<ErrorResponse | ConflictResponse>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAuthPasswordReset>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAuthPasswordReset>>,
          TError,
          Awaited<ReturnType<typeof getAuthPasswordReset>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAuthPasswordReset<
  TData = Awaited<ReturnType<typeof getAuthPasswordReset>>,
  TError = ErrorType<ErrorResponse | ConflictResponse>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAuthPasswordReset>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get password reset information
 */

export function useGetAuthPasswordReset<
  TData = Awaited<ReturnType<typeof getAuthPasswordReset>>,
  TError = ErrorType<ErrorResponse | ConflictResponse>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAuthPasswordReset>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetAuthPasswordResetQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Perform the password reset, by handing over the password reset key and
the new password. After successfully completing the password reset, the
user is either logged in (in case `ACCOUNT_LOGIN_ON_PASSWORD_RESET` is
`True`), or, the user will need to proceed to the login page.  In case
of the former, a `200` status code is returned, in case of the latter a
401.

 * @summary Reset password
 */
export const postAuthPasswordReset = (
  resetPasswordBody: BodyType<ResetPasswordBody>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<AuthenticatedByPasswordResponse>(
    {
      url: `/api/_allauth/browser/v1/auth/password/reset`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: resetPasswordBody,
      signal,
    },
    options,
  );
};

export const getPostAuthPasswordResetMutationOptions = <
  TError = ErrorType<ErrorResponse | AuthenticationResponse | ConflictResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postAuthPasswordReset>>,
    TError,
    { data: BodyType<ResetPasswordBody> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postAuthPasswordReset>>,
  TError,
  { data: BodyType<ResetPasswordBody> },
  TContext
> => {
  const mutationKey = ['postAuthPasswordReset'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postAuthPasswordReset>>,
    { data: BodyType<ResetPasswordBody> }
  > = props => {
    const { data } = props ?? {};

    return postAuthPasswordReset(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostAuthPasswordResetMutationResult = NonNullable<
  Awaited<ReturnType<typeof postAuthPasswordReset>>
>;
export type PostAuthPasswordResetMutationBody = BodyType<ResetPasswordBody>;
export type PostAuthPasswordResetMutationError = ErrorType<
  ErrorResponse | AuthenticationResponse | ConflictResponse
>;

/**
 * @summary Reset password
 */
export const usePostAuthPasswordReset = <
  TError = ErrorType<ErrorResponse | AuthenticationResponse | ConflictResponse>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postAuthPasswordReset>>,
      TError,
      { data: BodyType<ResetPasswordBody> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof postAuthPasswordReset>>,
  TError,
  { data: BodyType<ResetPasswordBody> },
  TContext
> => {
  const mutationOptions = getPostAuthPasswordResetMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Complete the phone number verification process. Note that a status code
of 401 does not imply failure. It merely indicates that the phone number
verification was successful, yet, the user is still not signed in.

 * @summary Verify a phone number
 */
export const postAuthPhoneVerify = (
  verifyPhoneBody: BodyType<VerifyPhoneBody>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<AuthenticatedResponse>(
    {
      url: `/api/_allauth/browser/v1/auth/phone/verify`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: verifyPhoneBody,
      signal,
    },
    options,
  );
};

export const getPostAuthPhoneVerifyMutationOptions = <
  TError = ErrorType<ErrorResponse | UnauthenticatedResponse | ConflictResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postAuthPhoneVerify>>,
    TError,
    { data: BodyType<VerifyPhoneBody> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postAuthPhoneVerify>>,
  TError,
  { data: BodyType<VerifyPhoneBody> },
  TContext
> => {
  const mutationKey = ['postAuthPhoneVerify'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postAuthPhoneVerify>>,
    { data: BodyType<VerifyPhoneBody> }
  > = props => {
    const { data } = props ?? {};

    return postAuthPhoneVerify(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostAuthPhoneVerifyMutationResult = NonNullable<
  Awaited<ReturnType<typeof postAuthPhoneVerify>>
>;
export type PostAuthPhoneVerifyMutationBody = BodyType<VerifyPhoneBody>;
export type PostAuthPhoneVerifyMutationError = ErrorType<
  ErrorResponse | UnauthenticatedResponse | ConflictResponse
>;

/**
 * @summary Verify a phone number
 */
export const usePostAuthPhoneVerify = <
  TError = ErrorType<ErrorResponse | UnauthenticatedResponse | ConflictResponse>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postAuthPhoneVerify>>,
      TError,
      { data: BodyType<VerifyPhoneBody> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof postAuthPhoneVerify>>,
  TError,
  { data: BodyType<VerifyPhoneBody> },
  TContext
> => {
  const mutationOptions = getPostAuthPhoneVerifyMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Requests a new phone number verification code.
Requires `ACCOUNT_PHONE_VERIFICATION_SUPPORTS_RESEND = True`.

 * @summary Resend phone number verification code
 */
export const postAuthPhoneVerifyResend = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<StatusOKResponse>(
    { url: `/api/_allauth/browser/v1/auth/phone/verify/resend`, method: 'POST', signal },
    options,
  );
};

export const getPostAuthPhoneVerifyResendMutationOptions = <
  TError = ErrorType<ConflictResponse | TooManyRequestsResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postAuthPhoneVerifyResend>>,
    TError,
    void,
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postAuthPhoneVerifyResend>>,
  TError,
  void,
  TContext
> => {
  const mutationKey = ['postAuthPhoneVerifyResend'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postAuthPhoneVerifyResend>>,
    void
  > = () => {
    return postAuthPhoneVerifyResend(requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostAuthPhoneVerifyResendMutationResult = NonNullable<
  Awaited<ReturnType<typeof postAuthPhoneVerifyResend>>
>;

export type PostAuthPhoneVerifyResendMutationError = ErrorType<
  ConflictResponse | TooManyRequestsResponse
>;

/**
 * @summary Resend phone number verification code
 */
export const usePostAuthPhoneVerifyResend = <
  TError = ErrorType<ConflictResponse | TooManyRequestsResponse>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postAuthPhoneVerifyResend>>,
      TError,
      void,
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof postAuthPhoneVerifyResend>>,
  TError,
  void,
  TContext
> => {
  const mutationOptions = getPostAuthPhoneVerifyResendMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * If, while signing up using a third-party provider account, there is
insufficient information received from the provider to automatically
complete the signup process, an additional step is needed to complete
the missing data before the user is fully signed up and authenticated.
The information available so far, such as the pending provider account,
can be retrieved via this endpoint.

 * @summary Provider signup information
 */
export const getAuthProviderSignup = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<ProviderSignupResponse>(
    { url: `/api/_allauth/browser/v1/auth/provider/signup`, method: 'GET', signal },
    options,
  );
};

export const getGetAuthProviderSignupQueryKey = () => {
  return [`/api/_allauth/browser/v1/auth/provider/signup`] as const;
};

export const getGetAuthProviderSignupQueryOptions = <
  TData = Awaited<ReturnType<typeof getAuthProviderSignup>>,
  TError = ErrorType<ConflictResponse>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getAuthProviderSignup>>, TError, TData>
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAuthProviderSignupQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAuthProviderSignup>>> = ({ signal }) =>
    getAuthProviderSignup(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getAuthProviderSignup>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetAuthProviderSignupQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAuthProviderSignup>>
>;
export type GetAuthProviderSignupQueryError = ErrorType<ConflictResponse>;

export function useGetAuthProviderSignup<
  TData = Awaited<ReturnType<typeof getAuthProviderSignup>>,
  TError = ErrorType<ConflictResponse>,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAuthProviderSignup>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAuthProviderSignup>>,
          TError,
          Awaited<ReturnType<typeof getAuthProviderSignup>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAuthProviderSignup<
  TData = Awaited<ReturnType<typeof getAuthProviderSignup>>,
  TError = ErrorType<ConflictResponse>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAuthProviderSignup>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAuthProviderSignup>>,
          TError,
          Awaited<ReturnType<typeof getAuthProviderSignup>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAuthProviderSignup<
  TData = Awaited<ReturnType<typeof getAuthProviderSignup>>,
  TError = ErrorType<ConflictResponse>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAuthProviderSignup>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Provider signup information
 */

export function useGetAuthProviderSignup<
  TData = Awaited<ReturnType<typeof getAuthProviderSignup>>,
  TError = ErrorType<ConflictResponse>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAuthProviderSignup>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetAuthProviderSignupQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * If, while signing up using a third-party provider account, there is
insufficient information received from the provider to automatically
complete the signup process, an additional step is needed to complete
the missing data before the user is fully signed up and authenticated.

 * @summary Provider signup
 */
export const postAuthProviderSignup = (
  providerSignupBody: BodyType<ProviderSignupBody>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<AuthenticatedResponse>(
    {
      url: `/api/_allauth/browser/v1/auth/provider/signup`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: providerSignupBody,
      signal,
    },
    options,
  );
};

export const getPostAuthProviderSignupMutationOptions = <
  TError = ErrorType<ErrorResponse | AuthenticationResponse | ForbiddenResponse | ConflictResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postAuthProviderSignup>>,
    TError,
    { data: BodyType<ProviderSignupBody> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postAuthProviderSignup>>,
  TError,
  { data: BodyType<ProviderSignupBody> },
  TContext
> => {
  const mutationKey = ['postAuthProviderSignup'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postAuthProviderSignup>>,
    { data: BodyType<ProviderSignupBody> }
  > = props => {
    const { data } = props ?? {};

    return postAuthProviderSignup(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostAuthProviderSignupMutationResult = NonNullable<
  Awaited<ReturnType<typeof postAuthProviderSignup>>
>;
export type PostAuthProviderSignupMutationBody = BodyType<ProviderSignupBody>;
export type PostAuthProviderSignupMutationError = ErrorType<
  ErrorResponse | AuthenticationResponse | ForbiddenResponse | ConflictResponse
>;

/**
 * @summary Provider signup
 */
export const usePostAuthProviderSignup = <
  TError = ErrorType<ErrorResponse | AuthenticationResponse | ForbiddenResponse | ConflictResponse>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postAuthProviderSignup>>,
      TError,
      { data: BodyType<ProviderSignupBody> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof postAuthProviderSignup>>,
  TError,
  { data: BodyType<ProviderSignupBody> },
  TContext
> => {
  const mutationOptions = getPostAuthProviderSignupMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Authenticates with a third-party provider using provider tokens received
by other means. For example, in case of a mobile app, the authentication
flow runs completely on the device itself, without any interaction with
the API. Then, when the (device) authentication completes and the mobile
app receives an access and/or ID token, it can hand over these tokens
via this endpoint to authenticate on the server.

 * @summary Provider token
 */
export const postAuthProviderToken = (
  providerTokenBody: BodyType<ProviderTokenBody>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<AuthenticatedResponse>(
    {
      url: `/api/_allauth/browser/v1/auth/provider/token`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: providerTokenBody,
      signal,
    },
    options,
  );
};

export const getPostAuthProviderTokenMutationOptions = <
  TError = ErrorType<ErrorResponse | AuthenticationResponse | ForbiddenResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postAuthProviderToken>>,
    TError,
    { data: BodyType<ProviderTokenBody> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postAuthProviderToken>>,
  TError,
  { data: BodyType<ProviderTokenBody> },
  TContext
> => {
  const mutationKey = ['postAuthProviderToken'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postAuthProviderToken>>,
    { data: BodyType<ProviderTokenBody> }
  > = props => {
    const { data } = props ?? {};

    return postAuthProviderToken(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostAuthProviderTokenMutationResult = NonNullable<
  Awaited<ReturnType<typeof postAuthProviderToken>>
>;
export type PostAuthProviderTokenMutationBody = BodyType<ProviderTokenBody>;
export type PostAuthProviderTokenMutationError = ErrorType<
  ErrorResponse | AuthenticationResponse | ForbiddenResponse
>;

/**
 * @summary Provider token
 */
export const usePostAuthProviderToken = <
  TError = ErrorType<ErrorResponse | AuthenticationResponse | ForbiddenResponse>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postAuthProviderToken>>,
      TError,
      { data: BodyType<ProviderTokenBody> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof postAuthProviderToken>>,
  TError,
  { data: BodyType<ProviderTokenBody> },
  TContext
> => {
  const mutationOptions = getPostAuthProviderTokenMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * In order to safeguard the account, some actions require the user to be
recently authenticated.  If you try to perform such an action without
having been recently authenticated, a `401` status is returned, listing
flows that can be performed to reauthenticate. One such flow is the flow
with ID `reauthenticate`, which allows for the user to input the
password. This is the endpoint related towards that flow.

 * @summary Reauthenticate
 */
export const postAuthReauthenticate = (
  reauthenticateBody: BodyType<ReauthenticateBody>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<AuthenticatedByPasswordResponse>(
    {
      url: `/api/_allauth/browser/v1/auth/reauthenticate`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: reauthenticateBody,
      signal,
    },
    options,
  );
};

export const getPostAuthReauthenticateMutationOptions = <
  TError = ErrorType<ErrorResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postAuthReauthenticate>>,
    TError,
    { data: BodyType<ReauthenticateBody> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postAuthReauthenticate>>,
  TError,
  { data: BodyType<ReauthenticateBody> },
  TContext
> => {
  const mutationKey = ['postAuthReauthenticate'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postAuthReauthenticate>>,
    { data: BodyType<ReauthenticateBody> }
  > = props => {
    const { data } = props ?? {};

    return postAuthReauthenticate(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostAuthReauthenticateMutationResult = NonNullable<
  Awaited<ReturnType<typeof postAuthReauthenticate>>
>;
export type PostAuthReauthenticateMutationBody = BodyType<ReauthenticateBody>;
export type PostAuthReauthenticateMutationError = ErrorType<ErrorResponse>;

/**
 * @summary Reauthenticate
 */
export const usePostAuthReauthenticate = <TError = ErrorType<ErrorResponse>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postAuthReauthenticate>>,
      TError,
      { data: BodyType<ReauthenticateBody> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof postAuthReauthenticate>>,
  TError,
  { data: BodyType<ReauthenticateBody> },
  TContext
> => {
  const mutationOptions = getPostAuthReauthenticateMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Logs out the user from the current session.

 * @summary Logout
 */
export const deleteAuthSession = (options?: SecondParameter<typeof customInstance>) => {
  return customInstance<unknown>(
    { url: `/api/_allauth/browser/v1/auth/session`, method: 'DELETE' },
    options,
  );
};

export const getDeleteAuthSessionMutationOptions = <
  TError = ErrorType<UnauthenticatedResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteAuthSession>>,
    TError,
    void,
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<Awaited<ReturnType<typeof deleteAuthSession>>, TError, void, TContext> => {
  const mutationKey = ['deleteAuthSession'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteAuthSession>>, void> = () => {
    return deleteAuthSession(requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteAuthSessionMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteAuthSession>>
>;

export type DeleteAuthSessionMutationError = ErrorType<UnauthenticatedResponse>;

/**
 * @summary Logout
 */
export const useDeleteAuthSession = <
  TError = ErrorType<UnauthenticatedResponse>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteAuthSession>>,
      TError,
      void,
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<Awaited<ReturnType<typeof deleteAuthSession>>, TError, void, TContext> => {
  const mutationOptions = getDeleteAuthSessionMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Retrieve information about the authentication status for the current
session.

 * @summary Get authentication status

 */
export const getAuthSession = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<AuthenticatedResponse>(
    { url: `/api/_allauth/browser/v1/auth/session`, method: 'GET', signal },
    options,
  );
};

export const getGetAuthSessionQueryKey = () => {
  return [`/api/_allauth/browser/v1/auth/session`] as const;
};

export const getGetAuthSessionQueryOptions = <
  TData = Awaited<ReturnType<typeof getAuthSession>>,
  TError = ErrorType<AuthenticationResponse | SessionGoneResponse>,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAuthSession>>, TError, TData>>;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAuthSessionQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAuthSession>>> = ({ signal }) =>
    getAuthSession(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getAuthSession>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetAuthSessionQueryResult = NonNullable<Awaited<ReturnType<typeof getAuthSession>>>;
export type GetAuthSessionQueryError = ErrorType<AuthenticationResponse | SessionGoneResponse>;

export function useGetAuthSession<
  TData = Awaited<ReturnType<typeof getAuthSession>>,
  TError = ErrorType<AuthenticationResponse | SessionGoneResponse>,
>(
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAuthSession>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAuthSession>>,
          TError,
          Awaited<ReturnType<typeof getAuthSession>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAuthSession<
  TData = Awaited<ReturnType<typeof getAuthSession>>,
  TError = ErrorType<AuthenticationResponse | SessionGoneResponse>,
>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAuthSession>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAuthSession>>,
          TError,
          Awaited<ReturnType<typeof getAuthSession>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAuthSession<
  TData = Awaited<ReturnType<typeof getAuthSession>>,
  TError = ErrorType<AuthenticationResponse | SessionGoneResponse>,
>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAuthSession>>, TError, TData>>;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get authentication status

 */

export function useGetAuthSession<
  TData = Awaited<ReturnType<typeof getAuthSession>>,
  TError = ErrorType<AuthenticationResponse | SessionGoneResponse>,
>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAuthSession>>, TError, TData>>;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetAuthSessionQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Whether or not `username`, `email`, `phone` or combination of those are
required depends on the configuration of django-allauth. Additionally,
if a custom signup form is used there may be other custom properties
required.

 * @summary Signup
 */
export const postAuthSignup = (
  signupBody: BodyType<SignupBody>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<AuthenticatedByPasswordResponse>(
    {
      url: `/api/_allauth/browser/v1/auth/signup`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: signupBody,
      signal,
    },
    options,
  );
};

export const getPostAuthSignupMutationOptions = <
  TError = ErrorType<ErrorResponse | AuthenticationResponse | ForbiddenResponse | ConflictResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postAuthSignup>>,
    TError,
    { data: BodyType<SignupBody> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postAuthSignup>>,
  TError,
  { data: BodyType<SignupBody> },
  TContext
> => {
  const mutationKey = ['postAuthSignup'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postAuthSignup>>,
    { data: BodyType<SignupBody> }
  > = props => {
    const { data } = props ?? {};

    return postAuthSignup(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostAuthSignupMutationResult = NonNullable<Awaited<ReturnType<typeof postAuthSignup>>>;
export type PostAuthSignupMutationBody = BodyType<SignupBody>;
export type PostAuthSignupMutationError = ErrorType<
  ErrorResponse | AuthenticationResponse | ForbiddenResponse | ConflictResponse
>;

/**
 * @summary Signup
 */
export const usePostAuthSignup = <
  TError = ErrorType<ErrorResponse | AuthenticationResponse | ForbiddenResponse | ConflictResponse>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postAuthSignup>>,
      TError,
      { data: BodyType<SignupBody> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof postAuthSignup>>,
  TError,
  { data: BodyType<SignupBody> },
  TContext
> => {
  const mutationOptions = getPostAuthSignupMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * There are many configuration options that alter the functionality
and behavior of django-allauth, some of which can also impact the
frontend. Therefore, relevant configuration options are exposed via
this endpoint. The data returned is not user/authentication
dependent. Hence, it suffices to only fetch this data once at boot
time of your application.

 * @summary Get configuration
 */
export const getConfig = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<ConfigurationResponse>(
    { url: `/api/_allauth/browser/v1/config`, method: 'GET', signal },
    options,
  );
};

export const getGetConfigQueryKey = () => {
  return [`/api/_allauth/browser/v1/config`] as const;
};

export const getGetConfigQueryOptions = <
  TData = Awaited<ReturnType<typeof getConfig>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getConfig>>, TError, TData>>;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetConfigQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getConfig>>> = ({ signal }) =>
    getConfig(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getConfig>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetConfigQueryResult = NonNullable<Awaited<ReturnType<typeof getConfig>>>;
export type GetConfigQueryError = ErrorType<unknown>;

export function useGetConfig<
  TData = Awaited<ReturnType<typeof getConfig>>,
  TError = ErrorType<unknown>,
>(
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getConfig>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getConfig>>,
          TError,
          Awaited<ReturnType<typeof getConfig>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetConfig<
  TData = Awaited<ReturnType<typeof getConfig>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getConfig>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getConfig>>,
          TError,
          Awaited<ReturnType<typeof getConfig>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetConfig<
  TData = Awaited<ReturnType<typeof getConfig>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getConfig>>, TError, TData>>;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get configuration
 */

export function useGetConfig<
  TData = Awaited<ReturnType<typeof getConfig>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getConfig>>, TError, TData>>;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetConfigQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}
