/**
 * Generated by orval v7.19.0 üç∫
 * Do not edit manually.
 * Designpvp API
 * artfight clone bluh
 * OpenAPI spec version: 1.0.0
 */
import { useMutation, useQuery } from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query';

import { customInstance } from './mutator/custom-instance';
import type { BodyType, ErrorType } from './mutator/custom-instance';

// https://stackoverflow.com/questions/49579094/typescript-conditional-types-filter-out-readonly-properties-pick-only-requir/49579497#49579497
type IfEquals<X, Y, A = X, B = never> =
  (<T>() => T extends X ? 1 : 2) extends <T>() => T extends Y ? 1 : 2 ? A : B;

type WritableKeys<T> = {
  [P in keyof T]-?: IfEquals<{ [Q in P]: T[P] }, { -readonly [Q in P]: T[P] }, P>;
}[keyof T];

type UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (k: infer I) => void
  ? I
  : never;
type DistributeReadOnlyOverUnions<T> = T extends any ? NonReadonly<T> : never;

type Writable<T> = Pick<T, WritableKeys<T>>;
type NonReadonly<T> = [T] extends [UnionToIntersection<T>]
  ? {
      [P in keyof Writable<T>]: T[P] extends object ? NonReadonly<NonNullable<T[P]>> : T[P];
    }
  : DistributeReadOnlyOverUnions<T>;

export interface Event {
  readonly id: number;
  /** @maxLength 50 */
  name: string;
  starts: string;
  ends: string;
}

export interface PatchedEvent {
  readonly id?: number;
  /** @maxLength 50 */
  name?: string;
  starts?: string;
  ends?: string;
}

export interface PatchedTeam {
  readonly id?: number;
  /** @maxLength 50 */
  name?: string;
  event?: number;
}

export interface Team {
  readonly id: number;
  /** @maxLength 50 */
  name: string;
  event: number;
}

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

export const eventsList = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<Event[]>({ url: `/api/events/`, method: 'GET', signal }, options);
};

export const getEventsListQueryKey = () => {
  return [`/api/events/`] as const;
};

export const getEventsListQueryOptions = <
  TData = Awaited<ReturnType<typeof eventsList>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof eventsList>>, TError, TData>>;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getEventsListQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof eventsList>>> = ({ signal }) =>
    eventsList(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof eventsList>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type EventsListQueryResult = NonNullable<Awaited<ReturnType<typeof eventsList>>>;
export type EventsListQueryError = ErrorType<unknown>;

export function useEventsList<
  TData = Awaited<ReturnType<typeof eventsList>>,
  TError = ErrorType<unknown>,
>(
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof eventsList>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof eventsList>>,
          TError,
          Awaited<ReturnType<typeof eventsList>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useEventsList<
  TData = Awaited<ReturnType<typeof eventsList>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof eventsList>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof eventsList>>,
          TError,
          Awaited<ReturnType<typeof eventsList>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useEventsList<
  TData = Awaited<ReturnType<typeof eventsList>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof eventsList>>, TError, TData>>;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

export function useEventsList<
  TData = Awaited<ReturnType<typeof eventsList>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof eventsList>>, TError, TData>>;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getEventsListQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const eventsCreate = (
  event: BodyType<NonReadonly<Event>>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  const formUrlEncoded = new URLSearchParams();
  formUrlEncoded.append(`name`, event.name);
  formUrlEncoded.append(`starts`, event.starts);
  formUrlEncoded.append(`ends`, event.ends);

  return customInstance<Event>(
    {
      url: `/api/events/`,
      method: 'POST',
      headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
      data: formUrlEncoded,
      signal,
    },
    options,
  );
};

export const getEventsCreateMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof eventsCreate>>,
    TError,
    { data: BodyType<NonReadonly<Event>> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof eventsCreate>>,
  TError,
  { data: BodyType<NonReadonly<Event>> },
  TContext
> => {
  const mutationKey = ['eventsCreate'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof eventsCreate>>,
    { data: BodyType<NonReadonly<Event>> }
  > = props => {
    const { data } = props ?? {};

    return eventsCreate(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type EventsCreateMutationResult = NonNullable<Awaited<ReturnType<typeof eventsCreate>>>;
export type EventsCreateMutationBody = BodyType<NonReadonly<Event>>;
export type EventsCreateMutationError = ErrorType<unknown>;

export const useEventsCreate = <TError = ErrorType<unknown>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof eventsCreate>>,
      TError,
      { data: BodyType<NonReadonly<Event>> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof eventsCreate>>,
  TError,
  { data: BodyType<NonReadonly<Event>> },
  TContext
> => {
  const mutationOptions = getEventsCreateMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const eventsRetrieve = (
  id: number,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<Event>({ url: `/api/events/${id}/`, method: 'GET', signal }, options);
};

export const getEventsRetrieveQueryKey = (id?: number) => {
  return [`/api/events/${id}/`] as const;
};

export const getEventsRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof eventsRetrieve>>,
  TError = ErrorType<unknown>,
>(
  id: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof eventsRetrieve>>, TError, TData>>;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getEventsRetrieveQueryKey(id);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof eventsRetrieve>>> = ({ signal }) =>
    eventsRetrieve(id, requestOptions, signal);

  return { queryKey, queryFn, enabled: !!id, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof eventsRetrieve>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type EventsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof eventsRetrieve>>>;
export type EventsRetrieveQueryError = ErrorType<unknown>;

export function useEventsRetrieve<
  TData = Awaited<ReturnType<typeof eventsRetrieve>>,
  TError = ErrorType<unknown>,
>(
  id: number,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof eventsRetrieve>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof eventsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof eventsRetrieve>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useEventsRetrieve<
  TData = Awaited<ReturnType<typeof eventsRetrieve>>,
  TError = ErrorType<unknown>,
>(
  id: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof eventsRetrieve>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof eventsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof eventsRetrieve>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useEventsRetrieve<
  TData = Awaited<ReturnType<typeof eventsRetrieve>>,
  TError = ErrorType<unknown>,
>(
  id: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof eventsRetrieve>>, TError, TData>>;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

export function useEventsRetrieve<
  TData = Awaited<ReturnType<typeof eventsRetrieve>>,
  TError = ErrorType<unknown>,
>(
  id: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof eventsRetrieve>>, TError, TData>>;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getEventsRetrieveQueryOptions(id, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const eventsUpdate = (
  id: number,
  event: BodyType<NonReadonly<Event>>,
  options?: SecondParameter<typeof customInstance>,
) => {
  const formUrlEncoded = new URLSearchParams();
  formUrlEncoded.append(`name`, event.name);
  formUrlEncoded.append(`starts`, event.starts);
  formUrlEncoded.append(`ends`, event.ends);

  return customInstance<Event>(
    {
      url: `/api/events/${id}/`,
      method: 'PUT',
      headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
      data: formUrlEncoded,
    },
    options,
  );
};

export const getEventsUpdateMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof eventsUpdate>>,
    TError,
    { id: number; data: BodyType<NonReadonly<Event>> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof eventsUpdate>>,
  TError,
  { id: number; data: BodyType<NonReadonly<Event>> },
  TContext
> => {
  const mutationKey = ['eventsUpdate'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof eventsUpdate>>,
    { id: number; data: BodyType<NonReadonly<Event>> }
  > = props => {
    const { id, data } = props ?? {};

    return eventsUpdate(id, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type EventsUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof eventsUpdate>>>;
export type EventsUpdateMutationBody = BodyType<NonReadonly<Event>>;
export type EventsUpdateMutationError = ErrorType<unknown>;

export const useEventsUpdate = <TError = ErrorType<unknown>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof eventsUpdate>>,
      TError,
      { id: number; data: BodyType<NonReadonly<Event>> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof eventsUpdate>>,
  TError,
  { id: number; data: BodyType<NonReadonly<Event>> },
  TContext
> => {
  const mutationOptions = getEventsUpdateMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const eventsPartialUpdate = (
  id: number,
  patchedEvent: BodyType<NonReadonly<PatchedEvent>>,
  options?: SecondParameter<typeof customInstance>,
) => {
  const formUrlEncoded = new URLSearchParams();
  if (patchedEvent.name !== undefined) {
    formUrlEncoded.append(`name`, patchedEvent.name);
  }
  if (patchedEvent.starts !== undefined) {
    formUrlEncoded.append(`starts`, patchedEvent.starts);
  }
  if (patchedEvent.ends !== undefined) {
    formUrlEncoded.append(`ends`, patchedEvent.ends);
  }

  return customInstance<Event>(
    {
      url: `/api/events/${id}/`,
      method: 'PATCH',
      headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
      data: formUrlEncoded,
    },
    options,
  );
};

export const getEventsPartialUpdateMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof eventsPartialUpdate>>,
    TError,
    { id: number; data: BodyType<NonReadonly<PatchedEvent>> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof eventsPartialUpdate>>,
  TError,
  { id: number; data: BodyType<NonReadonly<PatchedEvent>> },
  TContext
> => {
  const mutationKey = ['eventsPartialUpdate'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof eventsPartialUpdate>>,
    { id: number; data: BodyType<NonReadonly<PatchedEvent>> }
  > = props => {
    const { id, data } = props ?? {};

    return eventsPartialUpdate(id, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type EventsPartialUpdateMutationResult = NonNullable<
  Awaited<ReturnType<typeof eventsPartialUpdate>>
>;
export type EventsPartialUpdateMutationBody = BodyType<NonReadonly<PatchedEvent>>;
export type EventsPartialUpdateMutationError = ErrorType<unknown>;

export const useEventsPartialUpdate = <TError = ErrorType<unknown>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof eventsPartialUpdate>>,
      TError,
      { id: number; data: BodyType<NonReadonly<PatchedEvent>> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof eventsPartialUpdate>>,
  TError,
  { id: number; data: BodyType<NonReadonly<PatchedEvent>> },
  TContext
> => {
  const mutationOptions = getEventsPartialUpdateMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const eventsDestroy = (id: number, options?: SecondParameter<typeof customInstance>) => {
  return customInstance<void>({ url: `/api/events/${id}/`, method: 'DELETE' }, options);
};

export const getEventsDestroyMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof eventsDestroy>>,
    TError,
    { id: number },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof eventsDestroy>>,
  TError,
  { id: number },
  TContext
> => {
  const mutationKey = ['eventsDestroy'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof eventsDestroy>>,
    { id: number }
  > = props => {
    const { id } = props ?? {};

    return eventsDestroy(id, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type EventsDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof eventsDestroy>>>;

export type EventsDestroyMutationError = ErrorType<unknown>;

export const useEventsDestroy = <TError = ErrorType<unknown>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof eventsDestroy>>,
      TError,
      { id: number },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof eventsDestroy>>,
  TError,
  { id: number },
  TContext
> => {
  const mutationOptions = getEventsDestroyMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const teamsList = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<Team[]>({ url: `/api/teams/`, method: 'GET', signal }, options);
};

export const getTeamsListQueryKey = () => {
  return [`/api/teams/`] as const;
};

export const getTeamsListQueryOptions = <
  TData = Awaited<ReturnType<typeof teamsList>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof teamsList>>, TError, TData>>;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getTeamsListQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof teamsList>>> = ({ signal }) =>
    teamsList(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof teamsList>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type TeamsListQueryResult = NonNullable<Awaited<ReturnType<typeof teamsList>>>;
export type TeamsListQueryError = ErrorType<unknown>;

export function useTeamsList<
  TData = Awaited<ReturnType<typeof teamsList>>,
  TError = ErrorType<unknown>,
>(
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof teamsList>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof teamsList>>,
          TError,
          Awaited<ReturnType<typeof teamsList>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useTeamsList<
  TData = Awaited<ReturnType<typeof teamsList>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof teamsList>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof teamsList>>,
          TError,
          Awaited<ReturnType<typeof teamsList>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useTeamsList<
  TData = Awaited<ReturnType<typeof teamsList>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof teamsList>>, TError, TData>>;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

export function useTeamsList<
  TData = Awaited<ReturnType<typeof teamsList>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof teamsList>>, TError, TData>>;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getTeamsListQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const teamsCreate = (
  team: BodyType<NonReadonly<Team>>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  const formUrlEncoded = new URLSearchParams();
  formUrlEncoded.append(`name`, team.name);
  formUrlEncoded.append(`event`, team.event.toString());

  return customInstance<Team>(
    {
      url: `/api/teams/`,
      method: 'POST',
      headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
      data: formUrlEncoded,
      signal,
    },
    options,
  );
};

export const getTeamsCreateMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof teamsCreate>>,
    TError,
    { data: BodyType<NonReadonly<Team>> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof teamsCreate>>,
  TError,
  { data: BodyType<NonReadonly<Team>> },
  TContext
> => {
  const mutationKey = ['teamsCreate'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof teamsCreate>>,
    { data: BodyType<NonReadonly<Team>> }
  > = props => {
    const { data } = props ?? {};

    return teamsCreate(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type TeamsCreateMutationResult = NonNullable<Awaited<ReturnType<typeof teamsCreate>>>;
export type TeamsCreateMutationBody = BodyType<NonReadonly<Team>>;
export type TeamsCreateMutationError = ErrorType<unknown>;

export const useTeamsCreate = <TError = ErrorType<unknown>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof teamsCreate>>,
      TError,
      { data: BodyType<NonReadonly<Team>> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof teamsCreate>>,
  TError,
  { data: BodyType<NonReadonly<Team>> },
  TContext
> => {
  const mutationOptions = getTeamsCreateMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const teamsRetrieve = (
  id: number,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<Team>({ url: `/api/teams/${id}/`, method: 'GET', signal }, options);
};

export const getTeamsRetrieveQueryKey = (id?: number) => {
  return [`/api/teams/${id}/`] as const;
};

export const getTeamsRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof teamsRetrieve>>,
  TError = ErrorType<unknown>,
>(
  id: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof teamsRetrieve>>, TError, TData>>;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getTeamsRetrieveQueryKey(id);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof teamsRetrieve>>> = ({ signal }) =>
    teamsRetrieve(id, requestOptions, signal);

  return { queryKey, queryFn, enabled: !!id, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof teamsRetrieve>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type TeamsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof teamsRetrieve>>>;
export type TeamsRetrieveQueryError = ErrorType<unknown>;

export function useTeamsRetrieve<
  TData = Awaited<ReturnType<typeof teamsRetrieve>>,
  TError = ErrorType<unknown>,
>(
  id: number,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof teamsRetrieve>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof teamsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof teamsRetrieve>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useTeamsRetrieve<
  TData = Awaited<ReturnType<typeof teamsRetrieve>>,
  TError = ErrorType<unknown>,
>(
  id: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof teamsRetrieve>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof teamsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof teamsRetrieve>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useTeamsRetrieve<
  TData = Awaited<ReturnType<typeof teamsRetrieve>>,
  TError = ErrorType<unknown>,
>(
  id: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof teamsRetrieve>>, TError, TData>>;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

export function useTeamsRetrieve<
  TData = Awaited<ReturnType<typeof teamsRetrieve>>,
  TError = ErrorType<unknown>,
>(
  id: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof teamsRetrieve>>, TError, TData>>;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getTeamsRetrieveQueryOptions(id, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const teamsUpdate = (
  id: number,
  team: BodyType<NonReadonly<Team>>,
  options?: SecondParameter<typeof customInstance>,
) => {
  const formUrlEncoded = new URLSearchParams();
  formUrlEncoded.append(`name`, team.name);
  formUrlEncoded.append(`event`, team.event.toString());

  return customInstance<Team>(
    {
      url: `/api/teams/${id}/`,
      method: 'PUT',
      headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
      data: formUrlEncoded,
    },
    options,
  );
};

export const getTeamsUpdateMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof teamsUpdate>>,
    TError,
    { id: number; data: BodyType<NonReadonly<Team>> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof teamsUpdate>>,
  TError,
  { id: number; data: BodyType<NonReadonly<Team>> },
  TContext
> => {
  const mutationKey = ['teamsUpdate'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof teamsUpdate>>,
    { id: number; data: BodyType<NonReadonly<Team>> }
  > = props => {
    const { id, data } = props ?? {};

    return teamsUpdate(id, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type TeamsUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof teamsUpdate>>>;
export type TeamsUpdateMutationBody = BodyType<NonReadonly<Team>>;
export type TeamsUpdateMutationError = ErrorType<unknown>;

export const useTeamsUpdate = <TError = ErrorType<unknown>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof teamsUpdate>>,
      TError,
      { id: number; data: BodyType<NonReadonly<Team>> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof teamsUpdate>>,
  TError,
  { id: number; data: BodyType<NonReadonly<Team>> },
  TContext
> => {
  const mutationOptions = getTeamsUpdateMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const teamsPartialUpdate = (
  id: number,
  patchedTeam: BodyType<NonReadonly<PatchedTeam>>,
  options?: SecondParameter<typeof customInstance>,
) => {
  const formUrlEncoded = new URLSearchParams();
  if (patchedTeam.name !== undefined) {
    formUrlEncoded.append(`name`, patchedTeam.name);
  }
  if (patchedTeam.event !== undefined) {
    formUrlEncoded.append(`event`, patchedTeam.event.toString());
  }

  return customInstance<Team>(
    {
      url: `/api/teams/${id}/`,
      method: 'PATCH',
      headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
      data: formUrlEncoded,
    },
    options,
  );
};

export const getTeamsPartialUpdateMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof teamsPartialUpdate>>,
    TError,
    { id: number; data: BodyType<NonReadonly<PatchedTeam>> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof teamsPartialUpdate>>,
  TError,
  { id: number; data: BodyType<NonReadonly<PatchedTeam>> },
  TContext
> => {
  const mutationKey = ['teamsPartialUpdate'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof teamsPartialUpdate>>,
    { id: number; data: BodyType<NonReadonly<PatchedTeam>> }
  > = props => {
    const { id, data } = props ?? {};

    return teamsPartialUpdate(id, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type TeamsPartialUpdateMutationResult = NonNullable<
  Awaited<ReturnType<typeof teamsPartialUpdate>>
>;
export type TeamsPartialUpdateMutationBody = BodyType<NonReadonly<PatchedTeam>>;
export type TeamsPartialUpdateMutationError = ErrorType<unknown>;

export const useTeamsPartialUpdate = <TError = ErrorType<unknown>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof teamsPartialUpdate>>,
      TError,
      { id: number; data: BodyType<NonReadonly<PatchedTeam>> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof teamsPartialUpdate>>,
  TError,
  { id: number; data: BodyType<NonReadonly<PatchedTeam>> },
  TContext
> => {
  const mutationOptions = getTeamsPartialUpdateMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const teamsDestroy = (id: number, options?: SecondParameter<typeof customInstance>) => {
  return customInstance<void>({ url: `/api/teams/${id}/`, method: 'DELETE' }, options);
};

export const getTeamsDestroyMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof teamsDestroy>>,
    TError,
    { id: number },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof teamsDestroy>>,
  TError,
  { id: number },
  TContext
> => {
  const mutationKey = ['teamsDestroy'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof teamsDestroy>>,
    { id: number }
  > = props => {
    const { id } = props ?? {};

    return teamsDestroy(id, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type TeamsDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof teamsDestroy>>>;

export type TeamsDestroyMutationError = ErrorType<unknown>;

export const useTeamsDestroy = <TError = ErrorType<unknown>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof teamsDestroy>>,
      TError,
      { id: number },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof teamsDestroy>>,
  TError,
  { id: number },
  TContext
> => {
  const mutationOptions = getTeamsDestroyMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
