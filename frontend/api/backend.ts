/**
 * Generated by orval v7.19.0 üç∫
 * Do not edit manually.
 * Designpvp API
 * artfight clone bluh
 * OpenAPI spec version: 1.0.0
 */
import { useMutation, useQuery } from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query';

import { customInstance } from './mutator/custom-instance';
import type { BodyType, ErrorType } from './mutator/custom-instance';

export interface Event {
  readonly id: number;
  /** @maxLength 50 */
  name: string;
  starts: string;
  ends: string;
}

export interface EventRequest {
  /**
   * @minLength 1
   * @maxLength 50
   */
  name: string;
  starts: string;
  ends: string;
}

export interface PatchedEventRequest {
  /**
   * @minLength 1
   * @maxLength 50
   */
  name?: string;
  starts?: string;
  ends?: string;
}

export interface PatchedTeamRequest {
  /**
   * @minLength 1
   * @maxLength 50
   */
  name?: string;
  event?: number;
}

export interface Team {
  readonly id: number;
  /** @maxLength 50 */
  name: string;
  event: number;
}

export interface TeamRequest {
  /**
   * @minLength 1
   * @maxLength 50
   */
  name: string;
  event: number;
}

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

export const eventsList = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<Event[]>({ url: `/api/events/`, method: 'GET', signal }, options);
};

export const getEventsListQueryKey = () => {
  return [`/api/events/`] as const;
};

export const getEventsListQueryOptions = <
  TData = Awaited<ReturnType<typeof eventsList>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof eventsList>>, TError, TData>>;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getEventsListQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof eventsList>>> = ({ signal }) =>
    eventsList(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof eventsList>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type EventsListQueryResult = NonNullable<Awaited<ReturnType<typeof eventsList>>>;
export type EventsListQueryError = ErrorType<unknown>;

export function useEventsList<
  TData = Awaited<ReturnType<typeof eventsList>>,
  TError = ErrorType<unknown>,
>(
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof eventsList>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof eventsList>>,
          TError,
          Awaited<ReturnType<typeof eventsList>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useEventsList<
  TData = Awaited<ReturnType<typeof eventsList>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof eventsList>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof eventsList>>,
          TError,
          Awaited<ReturnType<typeof eventsList>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useEventsList<
  TData = Awaited<ReturnType<typeof eventsList>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof eventsList>>, TError, TData>>;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

export function useEventsList<
  TData = Awaited<ReturnType<typeof eventsList>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof eventsList>>, TError, TData>>;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getEventsListQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const eventsCreate = (
  eventRequest: BodyType<EventRequest>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  const formUrlEncoded = new URLSearchParams();
  formUrlEncoded.append(`name`, eventRequest.name);
  formUrlEncoded.append(`starts`, eventRequest.starts);
  formUrlEncoded.append(`ends`, eventRequest.ends);

  return customInstance<Event>(
    {
      url: `/api/events/`,
      method: 'POST',
      headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
      data: formUrlEncoded,
      signal,
    },
    options,
  );
};

export const getEventsCreateMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof eventsCreate>>,
    TError,
    { data: BodyType<EventRequest> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof eventsCreate>>,
  TError,
  { data: BodyType<EventRequest> },
  TContext
> => {
  const mutationKey = ['eventsCreate'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof eventsCreate>>,
    { data: BodyType<EventRequest> }
  > = props => {
    const { data } = props ?? {};

    return eventsCreate(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type EventsCreateMutationResult = NonNullable<Awaited<ReturnType<typeof eventsCreate>>>;
export type EventsCreateMutationBody = BodyType<EventRequest>;
export type EventsCreateMutationError = ErrorType<unknown>;

export const useEventsCreate = <TError = ErrorType<unknown>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof eventsCreate>>,
      TError,
      { data: BodyType<EventRequest> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof eventsCreate>>,
  TError,
  { data: BodyType<EventRequest> },
  TContext
> => {
  const mutationOptions = getEventsCreateMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const eventsRetrieve = (
  id: number,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<Event>({ url: `/api/events/${id}/`, method: 'GET', signal }, options);
};

export const getEventsRetrieveQueryKey = (id?: number) => {
  return [`/api/events/${id}/`] as const;
};

export const getEventsRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof eventsRetrieve>>,
  TError = ErrorType<unknown>,
>(
  id: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof eventsRetrieve>>, TError, TData>>;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getEventsRetrieveQueryKey(id);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof eventsRetrieve>>> = ({ signal }) =>
    eventsRetrieve(id, requestOptions, signal);

  return { queryKey, queryFn, enabled: !!id, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof eventsRetrieve>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type EventsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof eventsRetrieve>>>;
export type EventsRetrieveQueryError = ErrorType<unknown>;

export function useEventsRetrieve<
  TData = Awaited<ReturnType<typeof eventsRetrieve>>,
  TError = ErrorType<unknown>,
>(
  id: number,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof eventsRetrieve>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof eventsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof eventsRetrieve>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useEventsRetrieve<
  TData = Awaited<ReturnType<typeof eventsRetrieve>>,
  TError = ErrorType<unknown>,
>(
  id: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof eventsRetrieve>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof eventsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof eventsRetrieve>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useEventsRetrieve<
  TData = Awaited<ReturnType<typeof eventsRetrieve>>,
  TError = ErrorType<unknown>,
>(
  id: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof eventsRetrieve>>, TError, TData>>;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

export function useEventsRetrieve<
  TData = Awaited<ReturnType<typeof eventsRetrieve>>,
  TError = ErrorType<unknown>,
>(
  id: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof eventsRetrieve>>, TError, TData>>;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getEventsRetrieveQueryOptions(id, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const eventsUpdate = (
  id: number,
  eventRequest: BodyType<EventRequest>,
  options?: SecondParameter<typeof customInstance>,
) => {
  const formUrlEncoded = new URLSearchParams();
  formUrlEncoded.append(`name`, eventRequest.name);
  formUrlEncoded.append(`starts`, eventRequest.starts);
  formUrlEncoded.append(`ends`, eventRequest.ends);

  return customInstance<Event>(
    {
      url: `/api/events/${id}/`,
      method: 'PUT',
      headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
      data: formUrlEncoded,
    },
    options,
  );
};

export const getEventsUpdateMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof eventsUpdate>>,
    TError,
    { id: number; data: BodyType<EventRequest> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof eventsUpdate>>,
  TError,
  { id: number; data: BodyType<EventRequest> },
  TContext
> => {
  const mutationKey = ['eventsUpdate'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof eventsUpdate>>,
    { id: number; data: BodyType<EventRequest> }
  > = props => {
    const { id, data } = props ?? {};

    return eventsUpdate(id, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type EventsUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof eventsUpdate>>>;
export type EventsUpdateMutationBody = BodyType<EventRequest>;
export type EventsUpdateMutationError = ErrorType<unknown>;

export const useEventsUpdate = <TError = ErrorType<unknown>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof eventsUpdate>>,
      TError,
      { id: number; data: BodyType<EventRequest> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof eventsUpdate>>,
  TError,
  { id: number; data: BodyType<EventRequest> },
  TContext
> => {
  const mutationOptions = getEventsUpdateMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const eventsPartialUpdate = (
  id: number,
  patchedEventRequest: BodyType<PatchedEventRequest>,
  options?: SecondParameter<typeof customInstance>,
) => {
  const formUrlEncoded = new URLSearchParams();
  if (patchedEventRequest.name !== undefined) {
    formUrlEncoded.append(`name`, patchedEventRequest.name);
  }
  if (patchedEventRequest.starts !== undefined) {
    formUrlEncoded.append(`starts`, patchedEventRequest.starts);
  }
  if (patchedEventRequest.ends !== undefined) {
    formUrlEncoded.append(`ends`, patchedEventRequest.ends);
  }

  return customInstance<Event>(
    {
      url: `/api/events/${id}/`,
      method: 'PATCH',
      headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
      data: formUrlEncoded,
    },
    options,
  );
};

export const getEventsPartialUpdateMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof eventsPartialUpdate>>,
    TError,
    { id: number; data: BodyType<PatchedEventRequest> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof eventsPartialUpdate>>,
  TError,
  { id: number; data: BodyType<PatchedEventRequest> },
  TContext
> => {
  const mutationKey = ['eventsPartialUpdate'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof eventsPartialUpdate>>,
    { id: number; data: BodyType<PatchedEventRequest> }
  > = props => {
    const { id, data } = props ?? {};

    return eventsPartialUpdate(id, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type EventsPartialUpdateMutationResult = NonNullable<
  Awaited<ReturnType<typeof eventsPartialUpdate>>
>;
export type EventsPartialUpdateMutationBody = BodyType<PatchedEventRequest>;
export type EventsPartialUpdateMutationError = ErrorType<unknown>;

export const useEventsPartialUpdate = <TError = ErrorType<unknown>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof eventsPartialUpdate>>,
      TError,
      { id: number; data: BodyType<PatchedEventRequest> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof eventsPartialUpdate>>,
  TError,
  { id: number; data: BodyType<PatchedEventRequest> },
  TContext
> => {
  const mutationOptions = getEventsPartialUpdateMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const eventsDestroy = (id: number, options?: SecondParameter<typeof customInstance>) => {
  return customInstance<void>({ url: `/api/events/${id}/`, method: 'DELETE' }, options);
};

export const getEventsDestroyMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof eventsDestroy>>,
    TError,
    { id: number },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof eventsDestroy>>,
  TError,
  { id: number },
  TContext
> => {
  const mutationKey = ['eventsDestroy'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof eventsDestroy>>,
    { id: number }
  > = props => {
    const { id } = props ?? {};

    return eventsDestroy(id, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type EventsDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof eventsDestroy>>>;

export type EventsDestroyMutationError = ErrorType<unknown>;

export const useEventsDestroy = <TError = ErrorType<unknown>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof eventsDestroy>>,
      TError,
      { id: number },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof eventsDestroy>>,
  TError,
  { id: number },
  TContext
> => {
  const mutationOptions = getEventsDestroyMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const teamsList = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<Team[]>({ url: `/api/teams/`, method: 'GET', signal }, options);
};

export const getTeamsListQueryKey = () => {
  return [`/api/teams/`] as const;
};

export const getTeamsListQueryOptions = <
  TData = Awaited<ReturnType<typeof teamsList>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof teamsList>>, TError, TData>>;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getTeamsListQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof teamsList>>> = ({ signal }) =>
    teamsList(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof teamsList>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type TeamsListQueryResult = NonNullable<Awaited<ReturnType<typeof teamsList>>>;
export type TeamsListQueryError = ErrorType<unknown>;

export function useTeamsList<
  TData = Awaited<ReturnType<typeof teamsList>>,
  TError = ErrorType<unknown>,
>(
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof teamsList>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof teamsList>>,
          TError,
          Awaited<ReturnType<typeof teamsList>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useTeamsList<
  TData = Awaited<ReturnType<typeof teamsList>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof teamsList>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof teamsList>>,
          TError,
          Awaited<ReturnType<typeof teamsList>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useTeamsList<
  TData = Awaited<ReturnType<typeof teamsList>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof teamsList>>, TError, TData>>;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

export function useTeamsList<
  TData = Awaited<ReturnType<typeof teamsList>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof teamsList>>, TError, TData>>;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getTeamsListQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const teamsCreate = (
  teamRequest: BodyType<TeamRequest>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  const formUrlEncoded = new URLSearchParams();
  formUrlEncoded.append(`name`, teamRequest.name);
  formUrlEncoded.append(`event`, teamRequest.event.toString());

  return customInstance<Team>(
    {
      url: `/api/teams/`,
      method: 'POST',
      headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
      data: formUrlEncoded,
      signal,
    },
    options,
  );
};

export const getTeamsCreateMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof teamsCreate>>,
    TError,
    { data: BodyType<TeamRequest> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof teamsCreate>>,
  TError,
  { data: BodyType<TeamRequest> },
  TContext
> => {
  const mutationKey = ['teamsCreate'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof teamsCreate>>,
    { data: BodyType<TeamRequest> }
  > = props => {
    const { data } = props ?? {};

    return teamsCreate(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type TeamsCreateMutationResult = NonNullable<Awaited<ReturnType<typeof teamsCreate>>>;
export type TeamsCreateMutationBody = BodyType<TeamRequest>;
export type TeamsCreateMutationError = ErrorType<unknown>;

export const useTeamsCreate = <TError = ErrorType<unknown>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof teamsCreate>>,
      TError,
      { data: BodyType<TeamRequest> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof teamsCreate>>,
  TError,
  { data: BodyType<TeamRequest> },
  TContext
> => {
  const mutationOptions = getTeamsCreateMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const teamsRetrieve = (
  id: number,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<Team>({ url: `/api/teams/${id}/`, method: 'GET', signal }, options);
};

export const getTeamsRetrieveQueryKey = (id?: number) => {
  return [`/api/teams/${id}/`] as const;
};

export const getTeamsRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof teamsRetrieve>>,
  TError = ErrorType<unknown>,
>(
  id: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof teamsRetrieve>>, TError, TData>>;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getTeamsRetrieveQueryKey(id);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof teamsRetrieve>>> = ({ signal }) =>
    teamsRetrieve(id, requestOptions, signal);

  return { queryKey, queryFn, enabled: !!id, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof teamsRetrieve>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type TeamsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof teamsRetrieve>>>;
export type TeamsRetrieveQueryError = ErrorType<unknown>;

export function useTeamsRetrieve<
  TData = Awaited<ReturnType<typeof teamsRetrieve>>,
  TError = ErrorType<unknown>,
>(
  id: number,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof teamsRetrieve>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof teamsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof teamsRetrieve>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useTeamsRetrieve<
  TData = Awaited<ReturnType<typeof teamsRetrieve>>,
  TError = ErrorType<unknown>,
>(
  id: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof teamsRetrieve>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof teamsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof teamsRetrieve>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useTeamsRetrieve<
  TData = Awaited<ReturnType<typeof teamsRetrieve>>,
  TError = ErrorType<unknown>,
>(
  id: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof teamsRetrieve>>, TError, TData>>;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

export function useTeamsRetrieve<
  TData = Awaited<ReturnType<typeof teamsRetrieve>>,
  TError = ErrorType<unknown>,
>(
  id: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof teamsRetrieve>>, TError, TData>>;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getTeamsRetrieveQueryOptions(id, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const teamsUpdate = (
  id: number,
  teamRequest: BodyType<TeamRequest>,
  options?: SecondParameter<typeof customInstance>,
) => {
  const formUrlEncoded = new URLSearchParams();
  formUrlEncoded.append(`name`, teamRequest.name);
  formUrlEncoded.append(`event`, teamRequest.event.toString());

  return customInstance<Team>(
    {
      url: `/api/teams/${id}/`,
      method: 'PUT',
      headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
      data: formUrlEncoded,
    },
    options,
  );
};

export const getTeamsUpdateMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof teamsUpdate>>,
    TError,
    { id: number; data: BodyType<TeamRequest> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof teamsUpdate>>,
  TError,
  { id: number; data: BodyType<TeamRequest> },
  TContext
> => {
  const mutationKey = ['teamsUpdate'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof teamsUpdate>>,
    { id: number; data: BodyType<TeamRequest> }
  > = props => {
    const { id, data } = props ?? {};

    return teamsUpdate(id, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type TeamsUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof teamsUpdate>>>;
export type TeamsUpdateMutationBody = BodyType<TeamRequest>;
export type TeamsUpdateMutationError = ErrorType<unknown>;

export const useTeamsUpdate = <TError = ErrorType<unknown>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof teamsUpdate>>,
      TError,
      { id: number; data: BodyType<TeamRequest> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof teamsUpdate>>,
  TError,
  { id: number; data: BodyType<TeamRequest> },
  TContext
> => {
  const mutationOptions = getTeamsUpdateMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const teamsPartialUpdate = (
  id: number,
  patchedTeamRequest: BodyType<PatchedTeamRequest>,
  options?: SecondParameter<typeof customInstance>,
) => {
  const formUrlEncoded = new URLSearchParams();
  if (patchedTeamRequest.name !== undefined) {
    formUrlEncoded.append(`name`, patchedTeamRequest.name);
  }
  if (patchedTeamRequest.event !== undefined) {
    formUrlEncoded.append(`event`, patchedTeamRequest.event.toString());
  }

  return customInstance<Team>(
    {
      url: `/api/teams/${id}/`,
      method: 'PATCH',
      headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
      data: formUrlEncoded,
    },
    options,
  );
};

export const getTeamsPartialUpdateMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof teamsPartialUpdate>>,
    TError,
    { id: number; data: BodyType<PatchedTeamRequest> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof teamsPartialUpdate>>,
  TError,
  { id: number; data: BodyType<PatchedTeamRequest> },
  TContext
> => {
  const mutationKey = ['teamsPartialUpdate'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof teamsPartialUpdate>>,
    { id: number; data: BodyType<PatchedTeamRequest> }
  > = props => {
    const { id, data } = props ?? {};

    return teamsPartialUpdate(id, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type TeamsPartialUpdateMutationResult = NonNullable<
  Awaited<ReturnType<typeof teamsPartialUpdate>>
>;
export type TeamsPartialUpdateMutationBody = BodyType<PatchedTeamRequest>;
export type TeamsPartialUpdateMutationError = ErrorType<unknown>;

export const useTeamsPartialUpdate = <TError = ErrorType<unknown>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof teamsPartialUpdate>>,
      TError,
      { id: number; data: BodyType<PatchedTeamRequest> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof teamsPartialUpdate>>,
  TError,
  { id: number; data: BodyType<PatchedTeamRequest> },
  TContext
> => {
  const mutationOptions = getTeamsPartialUpdateMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const teamsDestroy = (id: number, options?: SecondParameter<typeof customInstance>) => {
  return customInstance<void>({ url: `/api/teams/${id}/`, method: 'DELETE' }, options);
};

export const getTeamsDestroyMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof teamsDestroy>>,
    TError,
    { id: number },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof teamsDestroy>>,
  TError,
  { id: number },
  TContext
> => {
  const mutationKey = ['teamsDestroy'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof teamsDestroy>>,
    { id: number }
  > = props => {
    const { id } = props ?? {};

    return teamsDestroy(id, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type TeamsDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof teamsDestroy>>>;

export type TeamsDestroyMutationError = ErrorType<unknown>;

export const useTeamsDestroy = <TError = ErrorType<unknown>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof teamsDestroy>>,
      TError,
      { id: number },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof teamsDestroy>>,
  TError,
  { id: number },
  TContext
> => {
  const mutationOptions = getTeamsDestroyMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
